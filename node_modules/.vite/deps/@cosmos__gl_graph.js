import "./chunk-5WRI5ZAA.js";

// node_modules/@cosmos.gl/graph/dist/index.js
var Ps = "http://www.w3.org/1999/xhtml";
var Zl = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Ps,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function ca(t3) {
  var e = t3 += "", n = e.indexOf(":");
  return n >= 0 && (e = t3.slice(0, n)) !== "xmlns" && (t3 = t3.slice(n + 1)), Zl.hasOwnProperty(e) ? { space: Zl[e], local: t3 } : t3;
}
function mm(t3) {
  return function() {
    var e = this.ownerDocument, n = this.namespaceURI;
    return n === Ps && e.documentElement.namespaceURI === Ps ? e.createElement(t3) : e.createElementNS(n, t3);
  };
}
function pm(t3) {
  return function() {
    return this.ownerDocument.createElementNS(t3.space, t3.local);
  };
}
function ju(t3) {
  var e = ca(t3);
  return (e.local ? pm : mm)(e);
}
function vm() {
}
function qs(t3) {
  return t3 == null ? vm : function() {
    return this.querySelector(t3);
  };
}
function gm(t3) {
  typeof t3 != "function" && (t3 = qs(t3));
  for (var e = this._groups, n = e.length, i = new Array(n), r = 0; r < n; ++r)
    for (var o = e[r], s = o.length, f = i[r] = new Array(s), l, u, m = 0; m < s; ++m)
      (l = o[m]) && (u = t3.call(l, l.__data__, m, o)) && ("__data__" in l && (u.__data__ = l.__data__), f[m] = u);
  return new nn(i, this._parents);
}
function ym(t3) {
  return t3 == null ? [] : Array.isArray(t3) ? t3 : Array.from(t3);
}
function xm() {
  return [];
}
function qu(t3) {
  return t3 == null ? xm : function() {
    return this.querySelectorAll(t3);
  };
}
function bm(t3) {
  return function() {
    return ym(t3.apply(this, arguments));
  };
}
function _m(t3) {
  typeof t3 == "function" ? t3 = bm(t3) : t3 = qu(t3);
  for (var e = this._groups, n = e.length, i = [], r = [], o = 0; o < n; ++o)
    for (var s = e[o], f = s.length, l, u = 0; u < f; ++u)
      (l = s[u]) && (i.push(t3.call(l, l.__data__, u, s)), r.push(l));
  return new nn(i, r);
}
function Yu(t3) {
  return function() {
    return this.matches(t3);
  };
}
function Zu(t3) {
  return function(e) {
    return e.matches(t3);
  };
}
var Sm = Array.prototype.find;
function Tm(t3) {
  return function() {
    return Sm.call(this.children, t3);
  };
}
function wm() {
  return this.firstElementChild;
}
function Am(t3) {
  return this.select(t3 == null ? wm : Tm(typeof t3 == "function" ? t3 : Zu(t3)));
}
var Em = Array.prototype.filter;
function Cm() {
  return Array.from(this.children);
}
function Pm(t3) {
  return function() {
    return Em.call(this.children, t3);
  };
}
function km(t3) {
  return this.selectAll(t3 == null ? Cm : Pm(typeof t3 == "function" ? t3 : Zu(t3)));
}
function Im(t3) {
  typeof t3 != "function" && (t3 = Yu(t3));
  for (var e = this._groups, n = e.length, i = new Array(n), r = 0; r < n; ++r)
    for (var o = e[r], s = o.length, f = i[r] = [], l, u = 0; u < s; ++u)
      (l = o[u]) && t3.call(l, l.__data__, u, o) && f.push(l);
  return new nn(i, this._parents);
}
function Qu(t3) {
  return new Array(t3.length);
}
function Lm() {
  return new nn(this._enter || this._groups.map(Qu), this._parents);
}
function na(t3, e) {
  this.ownerDocument = t3.ownerDocument, this.namespaceURI = t3.namespaceURI, this._next = null, this._parent = t3, this.__data__ = e;
}
na.prototype = {
  constructor: na,
  appendChild: function(t3) {
    return this._parent.insertBefore(t3, this._next);
  },
  insertBefore: function(t3, e) {
    return this._parent.insertBefore(t3, e);
  },
  querySelector: function(t3) {
    return this._parent.querySelector(t3);
  },
  querySelectorAll: function(t3) {
    return this._parent.querySelectorAll(t3);
  }
};
function Dm(t3) {
  return function() {
    return t3;
  };
}
function Fm(t3, e, n, i, r, o) {
  for (var s = 0, f, l = e.length, u = o.length; s < u; ++s)
    (f = e[s]) ? (f.__data__ = o[s], i[s] = f) : n[s] = new na(t3, o[s]);
  for (; s < l; ++s)
    (f = e[s]) && (r[s] = f);
}
function zm(t3, e, n, i, r, o, s) {
  var f, l, u = /* @__PURE__ */ new Map(), m = e.length, y = o.length, S = new Array(m), D;
  for (f = 0; f < m; ++f)
    (l = e[f]) && (S[f] = D = s.call(l, l.__data__, f, e) + "", u.has(D) ? r[f] = l : u.set(D, l));
  for (f = 0; f < y; ++f)
    D = s.call(t3, o[f], f, o) + "", (l = u.get(D)) ? (i[f] = l, l.__data__ = o[f], u.delete(D)) : n[f] = new na(t3, o[f]);
  for (f = 0; f < m; ++f)
    (l = e[f]) && u.get(S[f]) === l && (r[f] = l);
}
function Rm(t3) {
  return t3.__data__;
}
function Mm(t3, e) {
  if (!arguments.length) return Array.from(this, Rm);
  var n = e ? zm : Fm, i = this._parents, r = this._groups;
  typeof t3 != "function" && (t3 = Dm(t3));
  for (var o = r.length, s = new Array(o), f = new Array(o), l = new Array(o), u = 0; u < o; ++u) {
    var m = i[u], y = r[u], S = y.length, D = Om(t3.call(m, m && m.__data__, u, i)), q = D.length, Te = f[u] = new Array(q), we = s[u] = new Array(q), fe = l[u] = new Array(S);
    n(m, y, Te, we, fe, D, e);
    for (var Oe = 0, Ve = 0, V, se; Oe < q; ++Oe)
      if (V = Te[Oe]) {
        for (Oe >= Ve && (Ve = Oe + 1); !(se = we[Ve]) && ++Ve < q; ) ;
        V._next = se || null;
      }
  }
  return s = new nn(s, i), s._enter = f, s._exit = l, s;
}
function Om(t3) {
  return typeof t3 == "object" && "length" in t3 ? t3 : Array.from(t3);
}
function Nm() {
  return new nn(this._exit || this._groups.map(Qu), this._parents);
}
function Gm(t3, e, n) {
  var i = this.enter(), r = this, o = this.exit();
  return typeof t3 == "function" ? (i = t3(i), i && (i = i.selection())) : i = i.append(t3 + ""), e != null && (r = e(r), r && (r = r.selection())), n == null ? o.remove() : n(o), i && r ? i.merge(r).order() : r;
}
function Bm(t3) {
  for (var e = t3.selection ? t3.selection() : t3, n = this._groups, i = e._groups, r = n.length, o = i.length, s = Math.min(r, o), f = new Array(r), l = 0; l < s; ++l)
    for (var u = n[l], m = i[l], y = u.length, S = f[l] = new Array(y), D, q = 0; q < y; ++q)
      (D = u[q] || m[q]) && (S[q] = D);
  for (; l < r; ++l)
    f[l] = n[l];
  return new nn(f, this._parents);
}
function Um() {
  for (var t3 = this._groups, e = -1, n = t3.length; ++e < n; )
    for (var i = t3[e], r = i.length - 1, o = i[r], s; --r >= 0; )
      (s = i[r]) && (o && s.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(s, o), o = s);
  return this;
}
function Vm(t3) {
  t3 || (t3 = $m);
  function e(y, S) {
    return y && S ? t3(y.__data__, S.__data__) : !y - !S;
  }
  for (var n = this._groups, i = n.length, r = new Array(i), o = 0; o < i; ++o) {
    for (var s = n[o], f = s.length, l = r[o] = new Array(f), u, m = 0; m < f; ++m)
      (u = s[m]) && (l[m] = u);
    l.sort(e);
  }
  return new nn(r, this._parents).order();
}
function $m(t3, e) {
  return t3 < e ? -1 : t3 > e ? 1 : t3 >= e ? 0 : NaN;
}
function Hm() {
  var t3 = arguments[0];
  return arguments[0] = this, t3.apply(null, arguments), this;
}
function Wm() {
  return Array.from(this);
}
function Xm() {
  for (var t3 = this._groups, e = 0, n = t3.length; e < n; ++e)
    for (var i = t3[e], r = 0, o = i.length; r < o; ++r) {
      var s = i[r];
      if (s) return s;
    }
  return null;
}
function jm() {
  let t3 = 0;
  for (const e of this) ++t3;
  return t3;
}
function qm() {
  return !this.node();
}
function Ym(t3) {
  for (var e = this._groups, n = 0, i = e.length; n < i; ++n)
    for (var r = e[n], o = 0, s = r.length, f; o < s; ++o)
      (f = r[o]) && t3.call(f, f.__data__, o, r);
  return this;
}
function Zm(t3) {
  return function() {
    this.removeAttribute(t3);
  };
}
function Qm(t3) {
  return function() {
    this.removeAttributeNS(t3.space, t3.local);
  };
}
function Km(t3, e) {
  return function() {
    this.setAttribute(t3, e);
  };
}
function Jm(t3, e) {
  return function() {
    this.setAttributeNS(t3.space, t3.local, e);
  };
}
function ep(t3, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.removeAttribute(t3) : this.setAttribute(t3, n);
  };
}
function tp(t3, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.removeAttributeNS(t3.space, t3.local) : this.setAttributeNS(t3.space, t3.local, n);
  };
}
function np(t3, e) {
  var n = ca(t3);
  if (arguments.length < 2) {
    var i = this.node();
    return n.local ? i.getAttributeNS(n.space, n.local) : i.getAttribute(n);
  }
  return this.each((e == null ? n.local ? Qm : Zm : typeof e == "function" ? n.local ? tp : ep : n.local ? Jm : Km)(n, e));
}
function Ku(t3) {
  return t3.ownerDocument && t3.ownerDocument.defaultView || t3.document && t3 || t3.defaultView;
}
function ip(t3) {
  return function() {
    this.style.removeProperty(t3);
  };
}
function rp(t3, e, n) {
  return function() {
    this.style.setProperty(t3, e, n);
  };
}
function op(t3, e, n) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? this.style.removeProperty(t3) : this.style.setProperty(t3, i, n);
  };
}
function ap(t3, e, n) {
  return arguments.length > 1 ? this.each((e == null ? ip : typeof e == "function" ? op : rp)(t3, e, n ?? "")) : Qi(this.node(), t3);
}
function Qi(t3, e) {
  return t3.style.getPropertyValue(e) || Ku(t3).getComputedStyle(t3, null).getPropertyValue(e);
}
function sp(t3) {
  return function() {
    delete this[t3];
  };
}
function fp(t3, e) {
  return function() {
    this[t3] = e;
  };
}
function lp(t3, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? delete this[t3] : this[t3] = n;
  };
}
function up(t3, e) {
  return arguments.length > 1 ? this.each((e == null ? sp : typeof e == "function" ? lp : fp)(t3, e)) : this.node()[t3];
}
function Ju(t3) {
  return t3.trim().split(/^|\s+/);
}
function Ys(t3) {
  return t3.classList || new ec(t3);
}
function ec(t3) {
  this._node = t3, this._names = Ju(t3.getAttribute("class") || "");
}
ec.prototype = {
  add: function(t3) {
    var e = this._names.indexOf(t3);
    e < 0 && (this._names.push(t3), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t3) {
    var e = this._names.indexOf(t3);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t3) {
    return this._names.indexOf(t3) >= 0;
  }
};
function tc(t3, e) {
  for (var n = Ys(t3), i = -1, r = e.length; ++i < r; ) n.add(e[i]);
}
function nc(t3, e) {
  for (var n = Ys(t3), i = -1, r = e.length; ++i < r; ) n.remove(e[i]);
}
function cp(t3) {
  return function() {
    tc(this, t3);
  };
}
function hp(t3) {
  return function() {
    nc(this, t3);
  };
}
function dp(t3, e) {
  return function() {
    (e.apply(this, arguments) ? tc : nc)(this, t3);
  };
}
function mp(t3, e) {
  var n = Ju(t3 + "");
  if (arguments.length < 2) {
    for (var i = Ys(this.node()), r = -1, o = n.length; ++r < o; ) if (!i.contains(n[r])) return false;
    return true;
  }
  return this.each((typeof e == "function" ? dp : e ? cp : hp)(n, e));
}
function pp() {
  this.textContent = "";
}
function vp(t3) {
  return function() {
    this.textContent = t3;
  };
}
function gp(t3) {
  return function() {
    var e = t3.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function yp(t3) {
  return arguments.length ? this.each(t3 == null ? pp : (typeof t3 == "function" ? gp : vp)(t3)) : this.node().textContent;
}
function xp() {
  this.innerHTML = "";
}
function bp(t3) {
  return function() {
    this.innerHTML = t3;
  };
}
function _p(t3) {
  return function() {
    var e = t3.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function Sp(t3) {
  return arguments.length ? this.each(t3 == null ? xp : (typeof t3 == "function" ? _p : bp)(t3)) : this.node().innerHTML;
}
function Tp() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function wp() {
  return this.each(Tp);
}
function Ap() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Ep() {
  return this.each(Ap);
}
function Cp(t3) {
  var e = typeof t3 == "function" ? t3 : ju(t3);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function Pp() {
  return null;
}
function kp(t3, e) {
  var n = typeof t3 == "function" ? t3 : ju(t3), i = e == null ? Pp : typeof e == "function" ? e : qs(e);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), i.apply(this, arguments) || null);
  });
}
function Ip() {
  var t3 = this.parentNode;
  t3 && t3.removeChild(this);
}
function Lp() {
  return this.each(Ip);
}
function Dp() {
  var t3 = this.cloneNode(false), e = this.parentNode;
  return e ? e.insertBefore(t3, this.nextSibling) : t3;
}
function Fp() {
  var t3 = this.cloneNode(true), e = this.parentNode;
  return e ? e.insertBefore(t3, this.nextSibling) : t3;
}
function zp(t3) {
  return this.select(t3 ? Fp : Dp);
}
function Rp(t3) {
  return arguments.length ? this.property("__data__", t3) : this.node().__data__;
}
function Mp(t3) {
  return function(e) {
    t3.call(this, e, this.__data__);
  };
}
function Op(t3) {
  return t3.trim().split(/^|\s+/).map(function(e) {
    var n = "", i = e.indexOf(".");
    return i >= 0 && (n = e.slice(i + 1), e = e.slice(0, i)), { type: e, name: n };
  });
}
function Np(t3) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var n = 0, i = -1, r = e.length, o; n < r; ++n)
        o = e[n], (!t3.type || o.type === t3.type) && o.name === t3.name ? this.removeEventListener(o.type, o.listener, o.options) : e[++i] = o;
      ++i ? e.length = i : delete this.__on;
    }
  };
}
function Gp(t3, e, n) {
  return function() {
    var i = this.__on, r, o = Mp(e);
    if (i) {
      for (var s = 0, f = i.length; s < f; ++s)
        if ((r = i[s]).type === t3.type && r.name === t3.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = o, r.options = n), r.value = e;
          return;
        }
    }
    this.addEventListener(t3.type, o, n), r = { type: t3.type, name: t3.name, value: e, listener: o, options: n }, i ? i.push(r) : this.__on = [r];
  };
}
function Bp(t3, e, n) {
  var i = Op(t3 + ""), r, o = i.length, s;
  if (arguments.length < 2) {
    var f = this.node().__on;
    if (f) {
      for (var l = 0, u = f.length, m; l < u; ++l)
        for (r = 0, m = f[l]; r < o; ++r)
          if ((s = i[r]).type === m.type && s.name === m.name)
            return m.value;
    }
    return;
  }
  for (f = e ? Gp : Np, r = 0; r < o; ++r) this.each(f(i[r], e, n));
  return this;
}
function ic(t3, e, n) {
  var i = Ku(t3), r = i.CustomEvent;
  typeof r == "function" ? r = new r(e, n) : (r = i.document.createEvent("Event"), n ? (r.initEvent(e, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(e, false, false)), t3.dispatchEvent(r);
}
function Up(t3, e) {
  return function() {
    return ic(this, t3, e);
  };
}
function Vp(t3, e) {
  return function() {
    return ic(this, t3, e.apply(this, arguments));
  };
}
function $p(t3, e) {
  return this.each((typeof e == "function" ? Vp : Up)(t3, e));
}
function* Hp() {
  for (var t3 = this._groups, e = 0, n = t3.length; e < n; ++e)
    for (var i = t3[e], r = 0, o = i.length, s; r < o; ++r)
      (s = i[r]) && (yield s);
}
var rc = [null];
function nn(t3, e) {
  this._groups = t3, this._parents = e;
}
function Mr() {
  return new nn([[document.documentElement]], rc);
}
function Wp() {
  return this;
}
nn.prototype = Mr.prototype = {
  constructor: nn,
  select: gm,
  selectAll: _m,
  selectChild: Am,
  selectChildren: km,
  filter: Im,
  data: Mm,
  enter: Lm,
  exit: Nm,
  join: Gm,
  merge: Bm,
  selection: Wp,
  order: Um,
  sort: Vm,
  call: Hm,
  nodes: Wm,
  node: Xm,
  size: jm,
  empty: qm,
  each: Ym,
  attr: np,
  style: ap,
  property: up,
  classed: mp,
  text: yp,
  html: Sp,
  raise: wp,
  lower: Ep,
  append: Cp,
  insert: kp,
  remove: Lp,
  clone: zp,
  datum: Rp,
  on: Bp,
  dispatch: $p,
  [Symbol.iterator]: Hp
};
function zt(t3) {
  return typeof t3 == "string" ? new nn([[document.querySelector(t3)]], [document.documentElement]) : new nn([[t3]], rc);
}
function Xp(t3) {
  let e;
  for (; e = t3.sourceEvent; ) t3 = e;
  return t3;
}
function Mn(t3, e) {
  if (t3 = Xp(t3), e === void 0 && (e = t3.currentTarget), e) {
    var n = e.ownerSVGElement || e;
    if (n.createSVGPoint) {
      var i = n.createSVGPoint();
      return i.x = t3.clientX, i.y = t3.clientY, i = i.matrixTransform(e.getScreenCTM().inverse()), [i.x, i.y];
    }
    if (e.getBoundingClientRect) {
      var r = e.getBoundingClientRect();
      return [t3.clientX - r.left - e.clientLeft, t3.clientY - r.top - e.clientTop];
    }
  }
  return [t3.pageX, t3.pageY];
}
var jp = { value: () => {
} };
function ha() {
  for (var t3 = 0, e = arguments.length, n = {}, i; t3 < e; ++t3) {
    if (!(i = arguments[t3] + "") || i in n || /[\s.]/.test(i)) throw new Error("illegal type: " + i);
    n[i] = [];
  }
  return new Uo(n);
}
function Uo(t3) {
  this._ = t3;
}
function qp(t3, e) {
  return t3.trim().split(/^|\s+/).map(function(n) {
    var i = "", r = n.indexOf(".");
    if (r >= 0 && (i = n.slice(r + 1), n = n.slice(0, r)), n && !e.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: i };
  });
}
Uo.prototype = ha.prototype = {
  constructor: Uo,
  on: function(t3, e) {
    var n = this._, i = qp(t3 + "", n), r, o = -1, s = i.length;
    if (arguments.length < 2) {
      for (; ++o < s; ) if ((r = (t3 = i[o]).type) && (r = Yp(n[r], t3.name))) return r;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++o < s; )
      if (r = (t3 = i[o]).type) n[r] = Ql(n[r], t3.name, e);
      else if (e == null) for (r in n) n[r] = Ql(n[r], t3.name, null);
    return this;
  },
  copy: function() {
    var t3 = {}, e = this._;
    for (var n in e) t3[n] = e[n].slice();
    return new Uo(t3);
  },
  call: function(t3, e) {
    if ((r = arguments.length - 2) > 0) for (var n = new Array(r), i = 0, r, o; i < r; ++i) n[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(t3)) throw new Error("unknown type: " + t3);
    for (o = this._[t3], i = 0, r = o.length; i < r; ++i) o[i].value.apply(e, n);
  },
  apply: function(t3, e, n) {
    if (!this._.hasOwnProperty(t3)) throw new Error("unknown type: " + t3);
    for (var i = this._[t3], r = 0, o = i.length; r < o; ++r) i[r].value.apply(e, n);
  }
};
function Yp(t3, e) {
  for (var n = 0, i = t3.length, r; n < i; ++n)
    if ((r = t3[n]).name === e)
      return r.value;
}
function Ql(t3, e, n) {
  for (var i = 0, r = t3.length; i < r; ++i)
    if (t3[i].name === e) {
      t3[i] = jp, t3 = t3.slice(0, i).concat(t3.slice(i + 1));
      break;
    }
  return n != null && t3.push({ name: e, value: n }), t3;
}
var Ki = 0;
var kr = 0;
var Sr = 0;
var oc = 1e3;
var ia;
var Ir;
var ra = 0;
var wi = 0;
var da = 0;
var Dr = typeof performance == "object" && performance.now ? performance : Date;
var ac = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t3) {
  setTimeout(t3, 17);
};
function Zs() {
  return wi || (ac(Zp), wi = Dr.now() + da);
}
function Zp() {
  wi = 0;
}
function oa() {
  this._call = this._time = this._next = null;
}
oa.prototype = sc.prototype = {
  constructor: oa,
  restart: function(t3, e, n) {
    if (typeof t3 != "function") throw new TypeError("callback is not a function");
    n = (n == null ? Zs() : +n) + (e == null ? 0 : +e), !this._next && Ir !== this && (Ir ? Ir._next = this : ia = this, Ir = this), this._call = t3, this._time = n, ks();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, ks());
  }
};
function sc(t3, e, n) {
  var i = new oa();
  return i.restart(t3, e, n), i;
}
function Qp() {
  Zs(), ++Ki;
  for (var t3 = ia, e; t3; )
    (e = wi - t3._time) >= 0 && t3._call.call(null, e), t3 = t3._next;
  --Ki;
}
function Kl() {
  wi = (ra = Dr.now()) + da, Ki = kr = 0;
  try {
    Qp();
  } finally {
    Ki = 0, Jp(), wi = 0;
  }
}
function Kp() {
  var t3 = Dr.now(), e = t3 - ra;
  e > oc && (da -= e, ra = t3);
}
function Jp() {
  for (var t3, e = ia, n, i = 1 / 0; e; )
    e._call ? (i > e._time && (i = e._time), t3 = e, e = e._next) : (n = e._next, e._next = null, e = t3 ? t3._next = n : ia = n);
  Ir = t3, ks(i);
}
function ks(t3) {
  if (!Ki) {
    kr && (kr = clearTimeout(kr));
    var e = t3 - wi;
    e > 24 ? (t3 < 1 / 0 && (kr = setTimeout(Kl, t3 - Dr.now() - da)), Sr && (Sr = clearInterval(Sr))) : (Sr || (ra = Dr.now(), Sr = setInterval(Kp, oc)), Ki = 1, ac(Kl));
  }
}
function Jl(t3, e, n) {
  var i = new oa();
  return e = e == null ? 0 : +e, i.restart((r) => {
    i.stop(), t3(r + e);
  }, e, n), i;
}
var e0 = ha("start", "end", "cancel", "interrupt");
var t0 = [];
var fc = 0;
var eu = 1;
var Is = 2;
var Vo = 3;
var tu = 4;
var Ls = 5;
var $o = 6;
function ma(t3, e, n, i, r, o) {
  var s = t3.__transition;
  if (!s) t3.__transition = {};
  else if (n in s) return;
  n0(t3, n, {
    name: e,
    index: i,
    // For context during callback.
    group: r,
    // For context during callback.
    on: e0,
    tween: t0,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: fc
  });
}
function Qs(t3, e) {
  var n = yn(t3, e);
  if (n.state > fc) throw new Error("too late; already scheduled");
  return n;
}
function Cn(t3, e) {
  var n = yn(t3, e);
  if (n.state > Vo) throw new Error("too late; already running");
  return n;
}
function yn(t3, e) {
  var n = t3.__transition;
  if (!n || !(n = n[e])) throw new Error("transition not found");
  return n;
}
function n0(t3, e, n) {
  var i = t3.__transition, r;
  i[e] = n, n.timer = sc(o, 0, n.time);
  function o(u) {
    n.state = eu, n.timer.restart(s, n.delay, n.time), n.delay <= u && s(u - n.delay);
  }
  function s(u) {
    var m, y, S, D;
    if (n.state !== eu) return l();
    for (m in i)
      if (D = i[m], D.name === n.name) {
        if (D.state === Vo) return Jl(s);
        D.state === tu ? (D.state = $o, D.timer.stop(), D.on.call("interrupt", t3, t3.__data__, D.index, D.group), delete i[m]) : +m < e && (D.state = $o, D.timer.stop(), D.on.call("cancel", t3, t3.__data__, D.index, D.group), delete i[m]);
      }
    if (Jl(function() {
      n.state === Vo && (n.state = tu, n.timer.restart(f, n.delay, n.time), f(u));
    }), n.state = Is, n.on.call("start", t3, t3.__data__, n.index, n.group), n.state === Is) {
      for (n.state = Vo, r = new Array(S = n.tween.length), m = 0, y = -1; m < S; ++m)
        (D = n.tween[m].value.call(t3, t3.__data__, n.index, n.group)) && (r[++y] = D);
      r.length = y + 1;
    }
  }
  function f(u) {
    for (var m = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(l), n.state = Ls, 1), y = -1, S = r.length; ++y < S; )
      r[y].call(t3, m);
    n.state === Ls && (n.on.call("end", t3, t3.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = $o, n.timer.stop(), delete i[e];
    for (var u in i) return;
    delete t3.__transition;
  }
}
function Ho(t3, e) {
  var n = t3.__transition, i, r, o = true, s;
  if (n) {
    e = e == null ? null : e + "";
    for (s in n) {
      if ((i = n[s]).name !== e) {
        o = false;
        continue;
      }
      r = i.state > Is && i.state < Ls, i.state = $o, i.timer.stop(), i.on.call(r ? "interrupt" : "cancel", t3, t3.__data__, i.index, i.group), delete n[s];
    }
    o && delete t3.__transition;
  }
}
function i0(t3) {
  return this.each(function() {
    Ho(this, t3);
  });
}
function Ks(t3, e, n) {
  t3.prototype = e.prototype = n, n.constructor = t3;
}
function lc(t3, e) {
  var n = Object.create(t3.prototype);
  for (var i in e) n[i] = e[i];
  return n;
}
function Or() {
}
var Fr = 0.7;
var aa = 1 / Fr;
var Yi = "\\s*([+-]?\\d+)\\s*";
var zr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var En = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var r0 = /^#([0-9a-f]{3,8})$/;
var o0 = new RegExp(`^rgb\\(${Yi},${Yi},${Yi}\\)$`);
var a0 = new RegExp(`^rgb\\(${En},${En},${En}\\)$`);
var s0 = new RegExp(`^rgba\\(${Yi},${Yi},${Yi},${zr}\\)$`);
var f0 = new RegExp(`^rgba\\(${En},${En},${En},${zr}\\)$`);
var l0 = new RegExp(`^hsl\\(${zr},${En},${En}\\)$`);
var u0 = new RegExp(`^hsla\\(${zr},${En},${En},${zr}\\)$`);
var nu = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Ks(Or, Jn, {
  copy(t3) {
    return Object.assign(new this.constructor(), this, t3);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: iu,
  // Deprecated! Use color.formatHex.
  formatHex: iu,
  formatHex8: c0,
  formatHsl: h0,
  formatRgb: ru,
  toString: ru
});
function iu() {
  return this.rgb().formatHex();
}
function c0() {
  return this.rgb().formatHex8();
}
function h0() {
  return uc(this).formatHsl();
}
function ru() {
  return this.rgb().formatRgb();
}
function Jn(t3) {
  var e, n;
  return t3 = (t3 + "").trim().toLowerCase(), (e = r0.exec(t3)) ? (n = e[1].length, e = parseInt(e[1], 16), n === 6 ? ou(e) : n === 3 ? new Kt(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : n === 8 ? Fo(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : n === 4 ? Fo(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = o0.exec(t3)) ? new Kt(e[1], e[2], e[3], 1) : (e = a0.exec(t3)) ? new Kt(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = s0.exec(t3)) ? Fo(e[1], e[2], e[3], e[4]) : (e = f0.exec(t3)) ? Fo(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = l0.exec(t3)) ? fu(e[1], e[2] / 100, e[3] / 100, 1) : (e = u0.exec(t3)) ? fu(e[1], e[2] / 100, e[3] / 100, e[4]) : nu.hasOwnProperty(t3) ? ou(nu[t3]) : t3 === "transparent" ? new Kt(NaN, NaN, NaN, 0) : null;
}
function ou(t3) {
  return new Kt(t3 >> 16 & 255, t3 >> 8 & 255, t3 & 255, 1);
}
function Fo(t3, e, n, i) {
  return i <= 0 && (t3 = e = n = NaN), new Kt(t3, e, n, i);
}
function d0(t3) {
  return t3 instanceof Or || (t3 = Jn(t3)), t3 ? (t3 = t3.rgb(), new Kt(t3.r, t3.g, t3.b, t3.opacity)) : new Kt();
}
function Ds(t3, e, n, i) {
  return arguments.length === 1 ? d0(t3) : new Kt(t3, e, n, i ?? 1);
}
function Kt(t3, e, n, i) {
  this.r = +t3, this.g = +e, this.b = +n, this.opacity = +i;
}
Ks(Kt, Ds, lc(Or, {
  brighter(t3) {
    return t3 = t3 == null ? aa : Math.pow(aa, t3), new Kt(this.r * t3, this.g * t3, this.b * t3, this.opacity);
  },
  darker(t3) {
    return t3 = t3 == null ? Fr : Math.pow(Fr, t3), new Kt(this.r * t3, this.g * t3, this.b * t3, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Kt(Si(this.r), Si(this.g), Si(this.b), sa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: au,
  // Deprecated! Use color.formatHex.
  formatHex: au,
  formatHex8: m0,
  formatRgb: su,
  toString: su
}));
function au() {
  return `#${_i(this.r)}${_i(this.g)}${_i(this.b)}`;
}
function m0() {
  return `#${_i(this.r)}${_i(this.g)}${_i(this.b)}${_i((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function su() {
  const t3 = sa(this.opacity);
  return `${t3 === 1 ? "rgb(" : "rgba("}${Si(this.r)}, ${Si(this.g)}, ${Si(this.b)}${t3 === 1 ? ")" : `, ${t3})`}`;
}
function sa(t3) {
  return isNaN(t3) ? 1 : Math.max(0, Math.min(1, t3));
}
function Si(t3) {
  return Math.max(0, Math.min(255, Math.round(t3) || 0));
}
function _i(t3) {
  return t3 = Si(t3), (t3 < 16 ? "0" : "") + t3.toString(16);
}
function fu(t3, e, n, i) {
  return i <= 0 ? t3 = e = n = NaN : n <= 0 || n >= 1 ? t3 = e = NaN : e <= 0 && (t3 = NaN), new vn(t3, e, n, i);
}
function uc(t3) {
  if (t3 instanceof vn) return new vn(t3.h, t3.s, t3.l, t3.opacity);
  if (t3 instanceof Or || (t3 = Jn(t3)), !t3) return new vn();
  if (t3 instanceof vn) return t3;
  t3 = t3.rgb();
  var e = t3.r / 255, n = t3.g / 255, i = t3.b / 255, r = Math.min(e, n, i), o = Math.max(e, n, i), s = NaN, f = o - r, l = (o + r) / 2;
  return f ? (e === o ? s = (n - i) / f + (n < i) * 6 : n === o ? s = (i - e) / f + 2 : s = (e - n) / f + 4, f /= l < 0.5 ? o + r : 2 - o - r, s *= 60) : f = l > 0 && l < 1 ? 0 : s, new vn(s, f, l, t3.opacity);
}
function p0(t3, e, n, i) {
  return arguments.length === 1 ? uc(t3) : new vn(t3, e, n, i ?? 1);
}
function vn(t3, e, n, i) {
  this.h = +t3, this.s = +e, this.l = +n, this.opacity = +i;
}
Ks(vn, p0, lc(Or, {
  brighter(t3) {
    return t3 = t3 == null ? aa : Math.pow(aa, t3), new vn(this.h, this.s, this.l * t3, this.opacity);
  },
  darker(t3) {
    return t3 = t3 == null ? Fr : Math.pow(Fr, t3), new vn(this.h, this.s, this.l * t3, this.opacity);
  },
  rgb() {
    var t3 = this.h % 360 + (this.h < 0) * 360, e = isNaN(t3) || isNaN(this.s) ? 0 : this.s, n = this.l, i = n + (n < 0.5 ? n : 1 - n) * e, r = 2 * n - i;
    return new Kt(
      gs(t3 >= 240 ? t3 - 240 : t3 + 120, r, i),
      gs(t3, r, i),
      gs(t3 < 120 ? t3 + 240 : t3 - 120, r, i),
      this.opacity
    );
  },
  clamp() {
    return new vn(lu(this.h), zo(this.s), zo(this.l), sa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t3 = sa(this.opacity);
    return `${t3 === 1 ? "hsl(" : "hsla("}${lu(this.h)}, ${zo(this.s) * 100}%, ${zo(this.l) * 100}%${t3 === 1 ? ")" : `, ${t3})`}`;
  }
}));
function lu(t3) {
  return t3 = (t3 || 0) % 360, t3 < 0 ? t3 + 360 : t3;
}
function zo(t3) {
  return Math.max(0, Math.min(1, t3 || 0));
}
function gs(t3, e, n) {
  return (t3 < 60 ? e + (n - e) * t3 / 60 : t3 < 180 ? n : t3 < 240 ? e + (n - e) * (240 - t3) / 60 : e) * 255;
}
var Js = (t3) => () => t3;
function v0(t3, e) {
  return function(n) {
    return t3 + n * e;
  };
}
function g0(t3, e, n) {
  return t3 = Math.pow(t3, n), e = Math.pow(e, n) - t3, n = 1 / n, function(i) {
    return Math.pow(t3 + i * e, n);
  };
}
function y0(t3) {
  return (t3 = +t3) == 1 ? cc : function(e, n) {
    return n - e ? g0(e, n, t3) : Js(isNaN(e) ? n : e);
  };
}
function cc(t3, e) {
  var n = e - t3;
  return n ? v0(t3, n) : Js(isNaN(t3) ? e : t3);
}
var fa = (function t(e) {
  var n = y0(e);
  function i(r, o) {
    var s = n((r = Ds(r)).r, (o = Ds(o)).r), f = n(r.g, o.g), l = n(r.b, o.b), u = cc(r.opacity, o.opacity);
    return function(m) {
      return r.r = s(m), r.g = f(m), r.b = l(m), r.opacity = u(m), r + "";
    };
  }
  return i.gamma = t, i;
})(1);
function x0(t3, e) {
  e || (e = []);
  var n = t3 ? Math.min(e.length, t3.length) : 0, i = e.slice(), r;
  return function(o) {
    for (r = 0; r < n; ++r) i[r] = t3[r] * (1 - o) + e[r] * o;
    return i;
  };
}
function b0(t3) {
  return ArrayBuffer.isView(t3) && !(t3 instanceof DataView);
}
function _0(t3, e) {
  var n = e ? e.length : 0, i = t3 ? Math.min(n, t3.length) : 0, r = new Array(i), o = new Array(n), s;
  for (s = 0; s < i; ++s) r[s] = ef(t3[s], e[s]);
  for (; s < n; ++s) o[s] = e[s];
  return function(f) {
    for (s = 0; s < i; ++s) o[s] = r[s](f);
    return o;
  };
}
function S0(t3, e) {
  var n = /* @__PURE__ */ new Date();
  return t3 = +t3, e = +e, function(i) {
    return n.setTime(t3 * (1 - i) + e * i), n;
  };
}
function pn(t3, e) {
  return t3 = +t3, e = +e, function(n) {
    return t3 * (1 - n) + e * n;
  };
}
function T0(t3, e) {
  var n = {}, i = {}, r;
  (t3 === null || typeof t3 != "object") && (t3 = {}), (e === null || typeof e != "object") && (e = {});
  for (r in e)
    r in t3 ? n[r] = ef(t3[r], e[r]) : i[r] = e[r];
  return function(o) {
    for (r in n) i[r] = n[r](o);
    return i;
  };
}
var Fs = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var ys = new RegExp(Fs.source, "g");
function w0(t3) {
  return function() {
    return t3;
  };
}
function A0(t3) {
  return function(e) {
    return t3(e) + "";
  };
}
function hc(t3, e) {
  var n = Fs.lastIndex = ys.lastIndex = 0, i, r, o, s = -1, f = [], l = [];
  for (t3 = t3 + "", e = e + ""; (i = Fs.exec(t3)) && (r = ys.exec(e)); )
    (o = r.index) > n && (o = e.slice(n, o), f[s] ? f[s] += o : f[++s] = o), (i = i[0]) === (r = r[0]) ? f[s] ? f[s] += r : f[++s] = r : (f[++s] = null, l.push({ i: s, x: pn(i, r) })), n = ys.lastIndex;
  return n < e.length && (o = e.slice(n), f[s] ? f[s] += o : f[++s] = o), f.length < 2 ? l[0] ? A0(l[0].x) : w0(e) : (e = l.length, function(u) {
    for (var m = 0, y; m < e; ++m) f[(y = l[m]).i] = y.x(u);
    return f.join("");
  });
}
function ef(t3, e) {
  var n = typeof e, i;
  return e == null || n === "boolean" ? Js(e) : (n === "number" ? pn : n === "string" ? (i = Jn(e)) ? (e = i, fa) : hc : e instanceof Jn ? fa : e instanceof Date ? S0 : b0(e) ? x0 : Array.isArray(e) ? _0 : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? T0 : pn)(t3, e);
}
function E0(t3, e) {
  return t3 = +t3, e = +e, function(n) {
    return Math.round(t3 * (1 - n) + e * n);
  };
}
var uu = 180 / Math.PI;
var zs = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function dc(t3, e, n, i, r, o) {
  var s, f, l;
  return (s = Math.sqrt(t3 * t3 + e * e)) && (t3 /= s, e /= s), (l = t3 * n + e * i) && (n -= t3 * l, i -= e * l), (f = Math.sqrt(n * n + i * i)) && (n /= f, i /= f, l /= f), t3 * i < e * n && (t3 = -t3, e = -e, l = -l, s = -s), {
    translateX: r,
    translateY: o,
    rotate: Math.atan2(e, t3) * uu,
    skewX: Math.atan(l) * uu,
    scaleX: s,
    scaleY: f
  };
}
var Ro;
function C0(t3) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t3 + "");
  return e.isIdentity ? zs : dc(e.a, e.b, e.c, e.d, e.e, e.f);
}
function P0(t3) {
  return t3 == null || (Ro || (Ro = document.createElementNS("http://www.w3.org/2000/svg", "g")), Ro.setAttribute("transform", t3), !(t3 = Ro.transform.baseVal.consolidate())) ? zs : (t3 = t3.matrix, dc(t3.a, t3.b, t3.c, t3.d, t3.e, t3.f));
}
function mc(t3, e, n, i) {
  function r(u) {
    return u.length ? u.pop() + " " : "";
  }
  function o(u, m, y, S, D, q) {
    if (u !== y || m !== S) {
      var Te = D.push("translate(", null, e, null, n);
      q.push({ i: Te - 4, x: pn(u, y) }, { i: Te - 2, x: pn(m, S) });
    } else (y || S) && D.push("translate(" + y + e + S + n);
  }
  function s(u, m, y, S) {
    u !== m ? (u - m > 180 ? m += 360 : m - u > 180 && (u += 360), S.push({ i: y.push(r(y) + "rotate(", null, i) - 2, x: pn(u, m) })) : m && y.push(r(y) + "rotate(" + m + i);
  }
  function f(u, m, y, S) {
    u !== m ? S.push({ i: y.push(r(y) + "skewX(", null, i) - 2, x: pn(u, m) }) : m && y.push(r(y) + "skewX(" + m + i);
  }
  function l(u, m, y, S, D, q) {
    if (u !== y || m !== S) {
      var Te = D.push(r(D) + "scale(", null, ",", null, ")");
      q.push({ i: Te - 4, x: pn(u, y) }, { i: Te - 2, x: pn(m, S) });
    } else (y !== 1 || S !== 1) && D.push(r(D) + "scale(" + y + "," + S + ")");
  }
  return function(u, m) {
    var y = [], S = [];
    return u = t3(u), m = t3(m), o(u.translateX, u.translateY, m.translateX, m.translateY, y, S), s(u.rotate, m.rotate, y, S), f(u.skewX, m.skewX, y, S), l(u.scaleX, u.scaleY, m.scaleX, m.scaleY, y, S), u = m = null, function(D) {
      for (var q = -1, Te = S.length, we; ++q < Te; ) y[(we = S[q]).i] = we.x(D);
      return y.join("");
    };
  };
}
var k0 = mc(C0, "px, ", "px)", "deg)");
var I0 = mc(P0, ", ", ")", ")");
var L0 = 1e-12;
function cu(t3) {
  return ((t3 = Math.exp(t3)) + 1 / t3) / 2;
}
function D0(t3) {
  return ((t3 = Math.exp(t3)) - 1 / t3) / 2;
}
function F0(t3) {
  return ((t3 = Math.exp(2 * t3)) - 1) / (t3 + 1);
}
var z0 = (function t2(e, n, i) {
  function r(o, s) {
    var f = o[0], l = o[1], u = o[2], m = s[0], y = s[1], S = s[2], D = m - f, q = y - l, Te = D * D + q * q, we, fe;
    if (Te < L0)
      fe = Math.log(S / u) / e, we = function(Be) {
        return [
          f + Be * D,
          l + Be * q,
          u * Math.exp(e * Be * fe)
        ];
      };
    else {
      var Oe = Math.sqrt(Te), Ve = (S * S - u * u + i * Te) / (2 * u * n * Oe), V = (S * S - u * u - i * Te) / (2 * S * n * Oe), se = Math.log(Math.sqrt(Ve * Ve + 1) - Ve), Le = Math.log(Math.sqrt(V * V + 1) - V);
      fe = (Le - se) / e, we = function(Be) {
        var Xe = Be * fe, nt = cu(se), lt = u / (n * Oe) * (nt * F0(e * Xe + se) - D0(se));
        return [
          f + lt * D,
          l + lt * q,
          u * nt / cu(e * Xe + se)
        ];
      };
    }
    return we.duration = fe * 1e3 * e / Math.SQRT2, we;
  }
  return r.rho = function(o) {
    var s = Math.max(1e-3, +o), f = s * s, l = f * f;
    return t2(s, f, l);
  }, r;
})(Math.SQRT2, 2, 4);
function R0(t3, e) {
  var n, i;
  return function() {
    var r = Cn(this, t3), o = r.tween;
    if (o !== n) {
      i = n = o;
      for (var s = 0, f = i.length; s < f; ++s)
        if (i[s].name === e) {
          i = i.slice(), i.splice(s, 1);
          break;
        }
    }
    r.tween = i;
  };
}
function M0(t3, e, n) {
  var i, r;
  if (typeof n != "function") throw new Error();
  return function() {
    var o = Cn(this, t3), s = o.tween;
    if (s !== i) {
      r = (i = s).slice();
      for (var f = { name: e, value: n }, l = 0, u = r.length; l < u; ++l)
        if (r[l].name === e) {
          r[l] = f;
          break;
        }
      l === u && r.push(f);
    }
    o.tween = r;
  };
}
function O0(t3, e) {
  var n = this._id;
  if (t3 += "", arguments.length < 2) {
    for (var i = yn(this.node(), n).tween, r = 0, o = i.length, s; r < o; ++r)
      if ((s = i[r]).name === t3)
        return s.value;
    return null;
  }
  return this.each((e == null ? R0 : M0)(n, t3, e));
}
function tf(t3, e, n) {
  var i = t3._id;
  return t3.each(function() {
    var r = Cn(this, i);
    (r.value || (r.value = {}))[e] = n.apply(this, arguments);
  }), function(r) {
    return yn(r, i).value[e];
  };
}
function pc(t3, e) {
  var n;
  return (typeof e == "number" ? pn : e instanceof Jn ? fa : (n = Jn(e)) ? (e = n, fa) : hc)(t3, e);
}
function N0(t3) {
  return function() {
    this.removeAttribute(t3);
  };
}
function G0(t3) {
  return function() {
    this.removeAttributeNS(t3.space, t3.local);
  };
}
function B0(t3, e, n) {
  var i, r = n + "", o;
  return function() {
    var s = this.getAttribute(t3);
    return s === r ? null : s === i ? o : o = e(i = s, n);
  };
}
function U0(t3, e, n) {
  var i, r = n + "", o;
  return function() {
    var s = this.getAttributeNS(t3.space, t3.local);
    return s === r ? null : s === i ? o : o = e(i = s, n);
  };
}
function V0(t3, e, n) {
  var i, r, o;
  return function() {
    var s, f = n(this), l;
    return f == null ? void this.removeAttribute(t3) : (s = this.getAttribute(t3), l = f + "", s === l ? null : s === i && l === r ? o : (r = l, o = e(i = s, f)));
  };
}
function $0(t3, e, n) {
  var i, r, o;
  return function() {
    var s, f = n(this), l;
    return f == null ? void this.removeAttributeNS(t3.space, t3.local) : (s = this.getAttributeNS(t3.space, t3.local), l = f + "", s === l ? null : s === i && l === r ? o : (r = l, o = e(i = s, f)));
  };
}
function H0(t3, e) {
  var n = ca(t3), i = n === "transform" ? I0 : pc;
  return this.attrTween(t3, typeof e == "function" ? (n.local ? $0 : V0)(n, i, tf(this, "attr." + t3, e)) : e == null ? (n.local ? G0 : N0)(n) : (n.local ? U0 : B0)(n, i, e));
}
function W0(t3, e) {
  return function(n) {
    this.setAttribute(t3, e.call(this, n));
  };
}
function X0(t3, e) {
  return function(n) {
    this.setAttributeNS(t3.space, t3.local, e.call(this, n));
  };
}
function j0(t3, e) {
  var n, i;
  function r() {
    var o = e.apply(this, arguments);
    return o !== i && (n = (i = o) && X0(t3, o)), n;
  }
  return r._value = e, r;
}
function q0(t3, e) {
  var n, i;
  function r() {
    var o = e.apply(this, arguments);
    return o !== i && (n = (i = o) && W0(t3, o)), n;
  }
  return r._value = e, r;
}
function Y0(t3, e) {
  var n = "attr." + t3;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  var i = ca(t3);
  return this.tween(n, (i.local ? j0 : q0)(i, e));
}
function Z0(t3, e) {
  return function() {
    Qs(this, t3).delay = +e.apply(this, arguments);
  };
}
function Q0(t3, e) {
  return e = +e, function() {
    Qs(this, t3).delay = e;
  };
}
function K0(t3) {
  var e = this._id;
  return arguments.length ? this.each((typeof t3 == "function" ? Z0 : Q0)(e, t3)) : yn(this.node(), e).delay;
}
function J0(t3, e) {
  return function() {
    Cn(this, t3).duration = +e.apply(this, arguments);
  };
}
function ev(t3, e) {
  return e = +e, function() {
    Cn(this, t3).duration = e;
  };
}
function tv(t3) {
  var e = this._id;
  return arguments.length ? this.each((typeof t3 == "function" ? J0 : ev)(e, t3)) : yn(this.node(), e).duration;
}
function nv(t3, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    Cn(this, t3).ease = e;
  };
}
function iv(t3) {
  var e = this._id;
  return arguments.length ? this.each(nv(e, t3)) : yn(this.node(), e).ease;
}
function rv(t3, e) {
  return function() {
    var n = e.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    Cn(this, t3).ease = n;
  };
}
function ov(t3) {
  if (typeof t3 != "function") throw new Error();
  return this.each(rv(this._id, t3));
}
function av(t3) {
  typeof t3 != "function" && (t3 = Yu(t3));
  for (var e = this._groups, n = e.length, i = new Array(n), r = 0; r < n; ++r)
    for (var o = e[r], s = o.length, f = i[r] = [], l, u = 0; u < s; ++u)
      (l = o[u]) && t3.call(l, l.__data__, u, o) && f.push(l);
  return new Nn(i, this._parents, this._name, this._id);
}
function sv(t3) {
  if (t3._id !== this._id) throw new Error();
  for (var e = this._groups, n = t3._groups, i = e.length, r = n.length, o = Math.min(i, r), s = new Array(i), f = 0; f < o; ++f)
    for (var l = e[f], u = n[f], m = l.length, y = s[f] = new Array(m), S, D = 0; D < m; ++D)
      (S = l[D] || u[D]) && (y[D] = S);
  for (; f < i; ++f)
    s[f] = e[f];
  return new Nn(s, this._parents, this._name, this._id);
}
function fv(t3) {
  return (t3 + "").trim().split(/^|\s+/).every(function(e) {
    var n = e.indexOf(".");
    return n >= 0 && (e = e.slice(0, n)), !e || e === "start";
  });
}
function lv(t3, e, n) {
  var i, r, o = fv(e) ? Qs : Cn;
  return function() {
    var s = o(this, t3), f = s.on;
    f !== i && (r = (i = f).copy()).on(e, n), s.on = r;
  };
}
function uv(t3, e) {
  var n = this._id;
  return arguments.length < 2 ? yn(this.node(), n).on.on(t3) : this.each(lv(n, t3, e));
}
function cv(t3) {
  return function() {
    var e = this.parentNode;
    for (var n in this.__transition) if (+n !== t3) return;
    e && e.removeChild(this);
  };
}
function hv() {
  return this.on("end.remove", cv(this._id));
}
function dv(t3) {
  var e = this._name, n = this._id;
  typeof t3 != "function" && (t3 = qs(t3));
  for (var i = this._groups, r = i.length, o = new Array(r), s = 0; s < r; ++s)
    for (var f = i[s], l = f.length, u = o[s] = new Array(l), m, y, S = 0; S < l; ++S)
      (m = f[S]) && (y = t3.call(m, m.__data__, S, f)) && ("__data__" in m && (y.__data__ = m.__data__), u[S] = y, ma(u[S], e, n, S, u, yn(m, n)));
  return new Nn(o, this._parents, e, n);
}
function mv(t3) {
  var e = this._name, n = this._id;
  typeof t3 != "function" && (t3 = qu(t3));
  for (var i = this._groups, r = i.length, o = [], s = [], f = 0; f < r; ++f)
    for (var l = i[f], u = l.length, m, y = 0; y < u; ++y)
      if (m = l[y]) {
        for (var S = t3.call(m, m.__data__, y, l), D, q = yn(m, n), Te = 0, we = S.length; Te < we; ++Te)
          (D = S[Te]) && ma(D, e, n, Te, S, q);
        o.push(S), s.push(m);
      }
  return new Nn(o, s, e, n);
}
var pv = Mr.prototype.constructor;
function vv() {
  return new pv(this._groups, this._parents);
}
function gv(t3, e) {
  var n, i, r;
  return function() {
    var o = Qi(this, t3), s = (this.style.removeProperty(t3), Qi(this, t3));
    return o === s ? null : o === n && s === i ? r : r = e(n = o, i = s);
  };
}
function vc(t3) {
  return function() {
    this.style.removeProperty(t3);
  };
}
function yv(t3, e, n) {
  var i, r = n + "", o;
  return function() {
    var s = Qi(this, t3);
    return s === r ? null : s === i ? o : o = e(i = s, n);
  };
}
function xv(t3, e, n) {
  var i, r, o;
  return function() {
    var s = Qi(this, t3), f = n(this), l = f + "";
    return f == null && (l = f = (this.style.removeProperty(t3), Qi(this, t3))), s === l ? null : s === i && l === r ? o : (r = l, o = e(i = s, f));
  };
}
function bv(t3, e) {
  var n, i, r, o = "style." + e, s = "end." + o, f;
  return function() {
    var l = Cn(this, t3), u = l.on, m = l.value[o] == null ? f || (f = vc(e)) : void 0;
    (u !== n || r !== m) && (i = (n = u).copy()).on(s, r = m), l.on = i;
  };
}
function _v(t3, e, n) {
  var i = (t3 += "") == "transform" ? k0 : pc;
  return e == null ? this.styleTween(t3, gv(t3, i)).on("end.style." + t3, vc(t3)) : typeof e == "function" ? this.styleTween(t3, xv(t3, i, tf(this, "style." + t3, e))).each(bv(this._id, t3)) : this.styleTween(t3, yv(t3, i, e), n).on("end.style." + t3, null);
}
function Sv(t3, e, n) {
  return function(i) {
    this.style.setProperty(t3, e.call(this, i), n);
  };
}
function Tv(t3, e, n) {
  var i, r;
  function o() {
    var s = e.apply(this, arguments);
    return s !== r && (i = (r = s) && Sv(t3, s, n)), i;
  }
  return o._value = e, o;
}
function wv(t3, e, n) {
  var i = "style." + (t3 += "");
  if (arguments.length < 2) return (i = this.tween(i)) && i._value;
  if (e == null) return this.tween(i, null);
  if (typeof e != "function") throw new Error();
  return this.tween(i, Tv(t3, e, n ?? ""));
}
function Av(t3) {
  return function() {
    this.textContent = t3;
  };
}
function Ev(t3) {
  return function() {
    var e = t3(this);
    this.textContent = e ?? "";
  };
}
function Cv(t3) {
  return this.tween("text", typeof t3 == "function" ? Ev(tf(this, "text", t3)) : Av(t3 == null ? "" : t3 + ""));
}
function Pv(t3) {
  return function(e) {
    this.textContent = t3.call(this, e);
  };
}
function kv(t3) {
  var e, n;
  function i() {
    var r = t3.apply(this, arguments);
    return r !== n && (e = (n = r) && Pv(r)), e;
  }
  return i._value = t3, i;
}
function Iv(t3) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t3 == null) return this.tween(e, null);
  if (typeof t3 != "function") throw new Error();
  return this.tween(e, kv(t3));
}
function Lv() {
  for (var t3 = this._name, e = this._id, n = gc(), i = this._groups, r = i.length, o = 0; o < r; ++o)
    for (var s = i[o], f = s.length, l, u = 0; u < f; ++u)
      if (l = s[u]) {
        var m = yn(l, e);
        ma(l, t3, n, u, s, {
          time: m.time + m.delay + m.duration,
          delay: 0,
          duration: m.duration,
          ease: m.ease
        });
      }
  return new Nn(i, this._parents, t3, n);
}
function Dv() {
  var t3, e, n = this, i = n._id, r = n.size();
  return new Promise(function(o, s) {
    var f = { value: s }, l = { value: function() {
      --r === 0 && o();
    } };
    n.each(function() {
      var u = Cn(this, i), m = u.on;
      m !== t3 && (e = (t3 = m).copy(), e._.cancel.push(f), e._.interrupt.push(f), e._.end.push(l)), u.on = e;
    }), r === 0 && o();
  });
}
var Fv = 0;
function Nn(t3, e, n, i) {
  this._groups = t3, this._parents = e, this._name = n, this._id = i;
}
function gc() {
  return ++Fv;
}
var zn = Mr.prototype;
Nn.prototype = {
  constructor: Nn,
  select: dv,
  selectAll: mv,
  selectChild: zn.selectChild,
  selectChildren: zn.selectChildren,
  filter: av,
  merge: sv,
  selection: vv,
  transition: Lv,
  call: zn.call,
  nodes: zn.nodes,
  node: zn.node,
  size: zn.size,
  empty: zn.empty,
  each: zn.each,
  on: uv,
  attr: H0,
  attrTween: Y0,
  style: _v,
  styleTween: wv,
  text: Cv,
  textTween: Iv,
  remove: hv,
  tween: O0,
  delay: K0,
  duration: tv,
  ease: iv,
  easeVarying: ov,
  end: Dv,
  [Symbol.iterator]: zn[Symbol.iterator]
};
function zv(t3) {
  return t3 * t3;
}
function Rv(t3) {
  return t3 * (2 - t3);
}
function Mv(t3) {
  return ((t3 *= 2) <= 1 ? t3 * t3 : --t3 * (2 - t3) + 1) / 2;
}
function Ov(t3) {
  return ((t3 *= 2) <= 1 ? t3 * t3 * t3 : (t3 -= 2) * t3 * t3 + 2) / 2;
}
var Nv = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Ov
};
function Gv(t3, e) {
  for (var n; !(n = t3.__transition) || !(n = n[e]); )
    if (!(t3 = t3.parentNode))
      throw new Error(`transition ${e} not found`);
  return n;
}
function Bv(t3) {
  var e, n;
  t3 instanceof Nn ? (e = t3._id, t3 = t3._name) : (e = gc(), (n = Nv).time = Zs(), t3 = t3 == null ? null : t3 + "");
  for (var i = this._groups, r = i.length, o = 0; o < r; ++o)
    for (var s = i[o], f = s.length, l, u = 0; u < f; ++u)
      (l = s[u]) && ma(l, t3, e, u, s, n || Gv(l, e));
  return new Nn(i, this._parents, t3, e);
}
Mr.prototype.interrupt = i0;
Mr.prototype.transition = Bv;
function nf(t3) {
  return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
}
function Uv(t3) {
  if (Object.prototype.hasOwnProperty.call(t3, "__esModule")) return t3;
  var e = t3.default;
  if (typeof e == "function") {
    var n = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: true }), Object.keys(t3).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(t3, i);
    Object.defineProperty(n, i, r.get ? r : {
      enumerable: true,
      get: function() {
        return t3[i];
      }
    });
  }), n;
}
var Wo = { exports: {} };
var Vv = Wo.exports;
var hu;
function $v() {
  return hu || (hu = 1, (function(t3, e) {
    (function(n, i) {
      t3.exports = i();
    })(Vv, function() {
      var n = function(a) {
        return a instanceof Uint8Array || a instanceof Uint16Array || a instanceof Uint32Array || a instanceof Int8Array || a instanceof Int16Array || a instanceof Int32Array || a instanceof Float32Array || a instanceof Float64Array || a instanceof Uint8ClampedArray;
      }, i = function(a, h) {
        for (var _ = Object.keys(h), M = 0; M < _.length; ++M)
          a[_[M]] = h[_[M]];
        return a;
      }, r = `
`;
      function o(a) {
        return typeof atob < "u" ? atob(a) : "base64:" + a;
      }
      function s(a) {
        var h = new Error("(regl) " + a);
        throw console.error(h), h;
      }
      function f(a, h) {
        a || s(h);
      }
      function l(a) {
        return a ? ": " + a : "";
      }
      function u(a, h, _) {
        a in h || s("unknown parameter (" + a + ")" + l(_) + ". possible values: " + Object.keys(h).join());
      }
      function m(a, h) {
        n(a) || s(
          "invalid parameter type" + l(h) + ". must be a typed array"
        );
      }
      function y(a, h) {
        switch (h) {
          case "number":
            return typeof a == "number";
          case "object":
            return typeof a == "object";
          case "string":
            return typeof a == "string";
          case "boolean":
            return typeof a == "boolean";
          case "function":
            return typeof a == "function";
          case "undefined":
            return typeof a > "u";
          case "symbol":
            return typeof a == "symbol";
        }
      }
      function S(a, h, _) {
        y(a, h) || s(
          "invalid parameter type" + l(_) + ". expected " + h + ", got " + typeof a
        );
      }
      function D(a, h) {
        a >= 0 && (a | 0) === a || s("invalid parameter type, (" + a + ")" + l(h) + ". must be a nonnegative integer");
      }
      function q(a, h, _) {
        h.indexOf(a) < 0 && s("invalid value" + l(_) + ". must be one of: " + h);
      }
      var Te = [
        "gl",
        "canvas",
        "container",
        "attributes",
        "pixelRatio",
        "extensions",
        "optionalExtensions",
        "profile",
        "onDone"
      ];
      function we(a) {
        Object.keys(a).forEach(function(h) {
          Te.indexOf(h) < 0 && s('invalid regl constructor argument "' + h + '". must be one of ' + Te);
        });
      }
      function fe(a, h) {
        for (a = a + ""; a.length < h; )
          a = " " + a;
        return a;
      }
      function Oe() {
        this.name = "unknown", this.lines = [], this.index = {}, this.hasErrors = false;
      }
      function Ve(a, h) {
        this.number = a, this.line = h, this.errors = [];
      }
      function V(a, h, _) {
        this.file = a, this.line = h, this.message = _;
      }
      function se() {
        var a = new Error(), h = (a.stack || a).toString(), _ = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(h);
        if (_)
          return _[1];
        var M = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(h);
        return M ? M[1] : "unknown";
      }
      function Le() {
        var a = new Error(), h = (a.stack || a).toString(), _ = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(h);
        if (_)
          return _[1];
        var M = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(h);
        return M ? M[1] : "unknown";
      }
      function Be(a, h) {
        var _ = a.split(`
`), M = 1, W = 0, R = {
          unknown: new Oe(),
          0: new Oe()
        };
        R.unknown.name = R[0].name = h || se(), R.unknown.lines.push(new Ve(0, ""));
        for (var B = 0; B < _.length; ++B) {
          var K = _[B], Q = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(K);
          if (Q)
            switch (Q[1]) {
              case "line":
                var re = /(\d+)(\s+\d+)?/.exec(Q[2]);
                re && (M = re[1] | 0, re[2] && (W = re[2] | 0, W in R || (R[W] = new Oe())));
                break;
              case "define":
                var ae = /SHADER_NAME(_B64)?\s+(.*)$/.exec(Q[2]);
                ae && (R[W].name = ae[1] ? o(ae[2]) : ae[2]);
                break;
            }
          R[W].lines.push(new Ve(M++, K));
        }
        return Object.keys(R).forEach(function(oe) {
          var ue = R[oe];
          ue.lines.forEach(function(J) {
            ue.index[J.number] = J;
          });
        }), R;
      }
      function Xe(a) {
        var h = [];
        return a.split(`
`).forEach(function(_) {
          if (!(_.length < 5)) {
            var M = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(_);
            M ? h.push(new V(
              M[1] | 0,
              M[2] | 0,
              M[3].trim()
            )) : _.length > 0 && h.push(new V("unknown", 0, _));
          }
        }), h;
      }
      function nt(a, h) {
        h.forEach(function(_) {
          var M = a[_.file];
          if (M) {
            var W = M.index[_.line];
            if (W) {
              W.errors.push(_), M.hasErrors = true;
              return;
            }
          }
          a.unknown.hasErrors = true, a.unknown.lines[0].errors.push(_);
        });
      }
      function lt(a, h, _, M, W) {
        if (!a.getShaderParameter(h, a.COMPILE_STATUS)) {
          var R = a.getShaderInfoLog(h), B = M === a.FRAGMENT_SHADER ? "fragment" : "vertex";
          ke(_, "string", B + " shader source must be a string", W);
          var K = Be(_, W), Q = Xe(R);
          nt(K, Q), Object.keys(K).forEach(function(re) {
            var ae = K[re];
            if (!ae.hasErrors)
              return;
            var oe = [""], ue = [""];
            function J(ne, k) {
              oe.push(ne), ue.push(k || "");
            }
            J("file number " + re + ": " + ae.name + `
`, "color:red;text-decoration:underline;font-weight:bold"), ae.lines.forEach(function(ne) {
              if (ne.errors.length > 0) {
                J(fe(ne.number, 4) + "|  ", "background-color:yellow; font-weight:bold"), J(ne.line + r, "color:red; background-color:yellow; font-weight:bold");
                var k = 0;
                ne.errors.forEach(function(G) {
                  var te = G.message, xe = /^\s*'(.*)'\s*:\s*(.*)$/.exec(te);
                  if (xe) {
                    var Z = xe[1];
                    switch (te = xe[2], Z) {
                      case "assign":
                        Z = "=";
                        break;
                    }
                    k = Math.max(ne.line.indexOf(Z, k), 0);
                  } else
                    k = 0;
                  J(fe("| ", 6)), J(fe("^^^", k + 3) + r, "font-weight:bold"), J(fe("| ", 6)), J(te + r, "font-weight:bold");
                }), J(fe("| ", 6) + r);
              } else
                J(fe(ne.number, 4) + "|  "), J(ne.line + r, "color:red");
            }), typeof document < "u" && !window.chrome ? (ue[0] = oe.join("%c"), console.log.apply(console, ue)) : console.log(oe.join(""));
          }), f.raise("Error compiling " + B + " shader, " + K[0].name);
        }
      }
      function Ee(a, h, _, M, W) {
        if (!a.getProgramParameter(h, a.LINK_STATUS)) {
          var R = a.getProgramInfoLog(h), B = Be(_, W), K = Be(M, W), Q = 'Error linking program with vertex shader, "' + K[0].name + '", and fragment shader "' + B[0].name + '"';
          typeof document < "u" ? console.log(
            "%c" + Q + r + "%c" + R,
            "color:red;text-decoration:underline;font-weight:bold",
            "color:red"
          ) : console.log(Q + r + R), f.raise(Q);
        }
      }
      function ut(a) {
        a._commandRef = se();
      }
      function rt(a, h, _, M) {
        ut(a);
        function W(Q) {
          return Q ? M.id(Q) : 0;
        }
        a._fragId = W(a.static.frag), a._vertId = W(a.static.vert);
        function R(Q, re) {
          Object.keys(re).forEach(function(ae) {
            Q[M.id(ae)] = true;
          });
        }
        var B = a._uniformSet = {};
        R(B, h.static), R(B, h.dynamic);
        var K = a._attributeSet = {};
        R(K, _.static), R(K, _.dynamic), a._hasCount = "count" in a.static || "count" in a.dynamic || "elements" in a.static || "elements" in a.dynamic;
      }
      function N(a, h) {
        var _ = Le();
        s(a + " in command " + (h || se()) + (_ === "unknown" ? "" : " called from " + _));
      }
      function Pe(a, h, _) {
        a || N(h, _ || se());
      }
      function ie(a, h, _, M) {
        a in h || N(
          "unknown parameter (" + a + ")" + l(_) + ". possible values: " + Object.keys(h).join(),
          M || se()
        );
      }
      function ke(a, h, _, M) {
        y(a, h) || N(
          "invalid parameter type" + l(_) + ". expected " + h + ", got " + typeof a,
          M || se()
        );
      }
      function qe(a) {
        a();
      }
      function je(a, h, _) {
        a.texture ? q(
          a.texture._texture.internalformat,
          h,
          "unsupported texture format for attachment"
        ) : q(
          a.renderbuffer._renderbuffer.format,
          _,
          "unsupported renderbuffer format for attachment"
        );
      }
      var Qe = 33071, Ze = 9728, dt = 9984, ct = 9985, _t = 9986, st = 9987, Vt = 5120, $t = 5121, Yt = 5122, Pn = 5123, Nr = 5124, Gr = 5125, kn = 5126, ei = 32819, xn = 32820, Ei = 33635, Ci = 34042, Bn = 36193, Rt = {};
      Rt[Vt] = Rt[$t] = 1, Rt[Yt] = Rt[Pn] = Rt[Bn] = Rt[Ei] = Rt[ei] = Rt[xn] = 2, Rt[Nr] = Rt[Gr] = Rt[kn] = Rt[Ci] = 4;
      function ti(a, h) {
        return a === xn || a === ei || a === Ei ? 2 : a === Ci ? 4 : Rt[a] * h;
      }
      function ni(a) {
        return !(a & a - 1) && !!a;
      }
      function Br(a, h, _) {
        var M, W = h.width, R = h.height, B = h.channels;
        f(
          W > 0 && W <= _.maxTextureSize && R > 0 && R <= _.maxTextureSize,
          "invalid texture shape"
        ), (a.wrapS !== Qe || a.wrapT !== Qe) && f(
          ni(W) && ni(R),
          "incompatible wrap mode for texture, both width and height must be power of 2"
        ), h.mipmask === 1 ? W !== 1 && R !== 1 && f(
          a.minFilter !== dt && a.minFilter !== _t && a.minFilter !== ct && a.minFilter !== st,
          "min filter requires mipmap"
        ) : (f(
          ni(W) && ni(R),
          "texture must be a square power of 2 to support mipmapping"
        ), f(
          h.mipmask === (W << 1) - 1,
          "missing or incomplete mipmap data"
        )), h.type === kn && (_.extensions.indexOf("oes_texture_float_linear") < 0 && f(
          a.minFilter === Ze && a.magFilter === Ze,
          "filter not supported, must enable oes_texture_float_linear"
        ), f(
          !a.genMipmaps,
          "mipmap generation not supported with float textures"
        ));
        var K = h.images;
        for (M = 0; M < 16; ++M)
          if (K[M]) {
            var Q = W >> M, re = R >> M;
            f(h.mipmask & 1 << M, "missing mipmap data");
            var ae = K[M];
            if (f(
              ae.width === Q && ae.height === re,
              "invalid shape for mip images"
            ), f(
              ae.format === h.format && ae.internalformat === h.internalformat && ae.type === h.type,
              "incompatible type for mip image"
            ), !ae.compressed) if (ae.data) {
              var oe = Math.ceil(ti(ae.type, B) * Q / ae.unpackAlignment) * ae.unpackAlignment;
              f(
                ae.data.byteLength === oe * re,
                "invalid data for image, buffer size is inconsistent with image format"
              );
            } else ae.element || ae.copy;
          } else a.genMipmaps || f((h.mipmask & 1 << M) === 0, "extra mipmap data");
        h.compressed && f(
          !a.genMipmaps,
          "mipmap generation for compressed images not supported"
        );
      }
      function va(a, h, _, M) {
        var W = a.width, R = a.height, B = a.channels;
        f(
          W > 0 && W <= M.maxTextureSize && R > 0 && R <= M.maxTextureSize,
          "invalid texture shape"
        ), f(
          W === R,
          "cube map must be square"
        ), f(
          h.wrapS === Qe && h.wrapT === Qe,
          "wrap mode not supported by cube map"
        );
        for (var K = 0; K < _.length; ++K) {
          var Q = _[K];
          f(
            Q.width === W && Q.height === R,
            "inconsistent cube map face shape"
          ), h.genMipmaps && (f(
            !Q.compressed,
            "can not generate mipmap for compressed textures"
          ), f(
            Q.mipmask === 1,
            "can not specify mipmaps and generate mipmaps"
          ));
          for (var re = Q.images, ae = 0; ae < 16; ++ae) {
            var oe = re[ae];
            if (oe) {
              var ue = W >> ae, J = R >> ae;
              f(Q.mipmask & 1 << ae, "missing mipmap data"), f(
                oe.width === ue && oe.height === J,
                "invalid shape for mip images"
              ), f(
                oe.format === a.format && oe.internalformat === a.internalformat && oe.type === a.type,
                "incompatible type for mip image"
              ), oe.compressed || (oe.data ? f(
                oe.data.byteLength === ue * J * Math.max(ti(oe.type, B), oe.unpackAlignment),
                "invalid data for image, buffer size is inconsistent with image format"
              ) : oe.element || oe.copy);
            }
          }
        }
      }
      var d = i(f, {
        optional: qe,
        raise: s,
        commandRaise: N,
        command: Pe,
        parameter: u,
        commandParameter: ie,
        constructor: we,
        type: S,
        commandType: ke,
        isTypedArray: m,
        nni: D,
        oneOf: q,
        shaderError: lt,
        linkError: Ee,
        callSite: Le,
        saveCommandRef: ut,
        saveDrawInfo: rt,
        framebufferFormat: je,
        guessCommand: se,
        texture2D: Br,
        textureCube: va
      }), ii = 0, Un = 0, Vn = 5, Ur = 6;
      function bn(a, h) {
        this.id = ii++, this.type = a, this.data = h;
      }
      function er(a) {
        return a.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      }
      function In(a) {
        if (a.length === 0)
          return [];
        var h = a.charAt(0), _ = a.charAt(a.length - 1);
        if (a.length > 1 && h === _ && (h === '"' || h === "'"))
          return ['"' + er(a.substr(1, a.length - 2)) + '"'];
        var M = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(a);
        if (M)
          return In(a.substr(0, M.index)).concat(In(M[1])).concat(In(a.substr(M.index + M[0].length)));
        var W = a.split(".");
        if (W.length === 1)
          return ['"' + er(a) + '"'];
        for (var R = [], B = 0; B < W.length; ++B)
          R = R.concat(In(W[B]));
        return R;
      }
      function tr(a) {
        return "[" + In(a).join("][") + "]";
      }
      function Pi(a, h) {
        return new bn(a, tr(h + ""));
      }
      function ki(a) {
        return typeof a == "function" && !a._reglType || a instanceof bn;
      }
      function rn(a, h) {
        if (typeof a == "function")
          return new bn(Un, a);
        if (typeof a == "number" || typeof a == "boolean")
          return new bn(Vn, a);
        if (Array.isArray(a))
          return new bn(Ur, a.map(function(_, M) {
            return rn(_, h + "[" + M + "]");
          }));
        if (a instanceof bn)
          return a;
        d(false, "invalid option type in uniform " + h);
      }
      var kt = {
        DynamicVariable: bn,
        define: Pi,
        isDynamic: ki,
        unbox: rn,
        accessor: tr
      }, ri = {
        next: typeof requestAnimationFrame == "function" ? function(a) {
          return requestAnimationFrame(a);
        } : function(a) {
          return setTimeout(a, 16);
        },
        cancel: typeof cancelAnimationFrame == "function" ? function(a) {
          return cancelAnimationFrame(a);
        } : clearTimeout
      }, Ii = typeof performance < "u" && performance.now ? function() {
        return performance.now();
      } : function() {
        return +/* @__PURE__ */ new Date();
      };
      function ga() {
        var a = { "": 0 }, h = [""];
        return {
          id: function(_) {
            var M = a[_];
            return M || (M = a[_] = h.length, h.push(_), M);
          },
          str: function(_) {
            return h[_];
          }
        };
      }
      function Li(a, h, _) {
        var M = document.createElement("canvas");
        i(M.style, {
          border: 0,
          margin: 0,
          padding: 0,
          top: 0,
          left: 0,
          width: "100%",
          height: "100%"
        }), a.appendChild(M), a === document.body && (M.style.position = "absolute", i(a.style, {
          margin: 0,
          padding: 0
        }));
        function W() {
          var K = window.innerWidth, Q = window.innerHeight;
          if (a !== document.body) {
            var re = M.getBoundingClientRect();
            K = re.right - re.left, Q = re.bottom - re.top;
          }
          M.width = _ * K, M.height = _ * Q;
        }
        var R;
        a !== document.body && typeof ResizeObserver == "function" ? (R = new ResizeObserver(function() {
          setTimeout(W);
        }), R.observe(a)) : window.addEventListener("resize", W, false);
        function B() {
          R ? R.disconnect() : window.removeEventListener("resize", W), a.removeChild(M);
        }
        return W(), {
          canvas: M,
          onDestroy: B
        };
      }
      function Di(a, h) {
        function _(M) {
          try {
            return a.getContext(M, h);
          } catch {
            return null;
          }
        }
        return _("webgl") || _("experimental-webgl") || _("webgl-experimental");
      }
      function ya(a) {
        return typeof a.nodeName == "string" && typeof a.appendChild == "function" && typeof a.getBoundingClientRect == "function";
      }
      function oi(a) {
        return typeof a.drawArrays == "function" || typeof a.drawElements == "function";
      }
      function Vr(a) {
        return typeof a == "string" ? a.split() : (d(Array.isArray(a), "invalid extension array"), a);
      }
      function $r(a) {
        return typeof a == "string" ? (d(typeof document < "u", "not supported outside of DOM"), document.querySelector(a)) : a;
      }
      function It(a) {
        var h = a || {}, _, M, W, R, B = {}, K = [], Q = [], re = typeof window > "u" ? 1 : window.devicePixelRatio, ae = false, oe = function(ne) {
          ne && d.raise(ne);
        }, ue = function() {
        };
        if (typeof h == "string" ? (d(
          typeof document < "u",
          "selector queries only supported in DOM enviroments"
        ), _ = document.querySelector(h), d(_, "invalid query string for element")) : typeof h == "object" ? ya(h) ? _ = h : oi(h) ? (R = h, W = R.canvas) : (d.constructor(h), "gl" in h ? R = h.gl : "canvas" in h ? W = $r(h.canvas) : "container" in h && (M = $r(h.container)), "attributes" in h && (B = h.attributes, d.type(B, "object", "invalid context attributes")), "extensions" in h && (K = Vr(h.extensions)), "optionalExtensions" in h && (Q = Vr(h.optionalExtensions)), "onDone" in h && (d.type(
          h.onDone,
          "function",
          "invalid or missing onDone callback"
        ), oe = h.onDone), "profile" in h && (ae = !!h.profile), "pixelRatio" in h && (re = +h.pixelRatio, d(re > 0, "invalid pixel ratio"))) : d.raise("invalid arguments to regl"), _ && (_.nodeName.toLowerCase() === "canvas" ? W = _ : M = _), !R) {
          if (!W) {
            d(
              typeof document < "u",
              "must manually specify webgl context outside of DOM environments"
            );
            var J = Li(M || document.body, oe, re);
            if (!J)
              return null;
            W = J.canvas, ue = J.onDestroy;
          }
          B.premultipliedAlpha === void 0 && (B.premultipliedAlpha = true), R = Di(W, B);
        }
        return R ? {
          gl: R,
          canvas: W,
          container: M,
          extensions: K,
          optionalExtensions: Q,
          pixelRatio: re,
          profile: ae,
          onDone: oe,
          onDestroy: ue
        } : (ue(), oe("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"), null);
      }
      function $n(a, h) {
        var _ = {};
        function M(B) {
          d.type(B, "string", "extension name must be string");
          var K = B.toLowerCase(), Q;
          try {
            Q = _[K] = a.getExtension(K);
          } catch {
          }
          return !!Q;
        }
        for (var W = 0; W < h.extensions.length; ++W) {
          var R = h.extensions[W];
          if (!M(R))
            return h.onDestroy(), h.onDone('"' + R + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser'), null;
        }
        return h.optionalExtensions.forEach(M), {
          extensions: _,
          restore: function() {
            Object.keys(_).forEach(function(B) {
              if (_[B] && !M(B))
                throw new Error("(regl): error restoring extension " + B);
            });
          }
        };
      }
      function Wt(a, h) {
        for (var _ = Array(a), M = 0; M < a; ++M)
          _[M] = h(M);
        return _;
      }
      var Hr = 5120, nr = 5121, Wr = 5122, Xr = 5123, xa = 5124, on = 5125, Hn = 5126;
      function jr(a) {
        for (var h = 16; h <= 1 << 28; h *= 16)
          if (a <= h)
            return h;
        return 0;
      }
      function ir(a) {
        var h, _;
        return h = (a > 65535) << 4, a >>>= h, _ = (a > 255) << 3, a >>>= _, h |= _, _ = (a > 15) << 2, a >>>= _, h |= _, _ = (a > 3) << 1, a >>>= _, h |= _, h | a >> 1;
      }
      function Fi() {
        var a = Wt(8, function() {
          return [];
        });
        function h(R) {
          var B = jr(R), K = a[ir(B) >> 2];
          return K.length > 0 ? K.pop() : new ArrayBuffer(B);
        }
        function _(R) {
          a[ir(R.byteLength) >> 2].push(R);
        }
        function M(R, B) {
          var K = null;
          switch (R) {
            case Hr:
              K = new Int8Array(h(B), 0, B);
              break;
            case nr:
              K = new Uint8Array(h(B), 0, B);
              break;
            case Wr:
              K = new Int16Array(h(2 * B), 0, B);
              break;
            case Xr:
              K = new Uint16Array(h(2 * B), 0, B);
              break;
            case xa:
              K = new Int32Array(h(4 * B), 0, B);
              break;
            case on:
              K = new Uint32Array(h(4 * B), 0, B);
              break;
            case Hn:
              K = new Float32Array(h(4 * B), 0, B);
              break;
            default:
              return null;
          }
          return K.length !== B ? K.subarray(0, B) : K;
        }
        function W(R) {
          _(R.buffer);
        }
        return {
          alloc: h,
          free: _,
          allocType: M,
          freeType: W
        };
      }
      var gt = Fi();
      gt.zero = Fi();
      var un = 3408, qr = 3410, Yr = 3411, Zr = 3412, Qr = 3413, ba = 3414, $e = 3415, P = 33901, ve = 33902, ze = 3379, mt = 3386, Mt = 34921, wt = 36347, Ht = 36348, cn = 35661, ai = 35660, rr = 34930, Ot = 36349, Kr = 34076, Jr = 34024, Uc = 7936, Vc = 7937, $c = 7938, Hc = 35724, Wc = 34047, Xc = 36063, jc = 34852, eo = 3553, af = 34067, qc = 34069, Yc = 33984, or = 6408, _a = 5126, sf = 5121, Sa = 36160, Zc = 36053, Qc = 36064, Kc = 16384, Jc = function(a, h) {
        var _ = 1;
        h.ext_texture_filter_anisotropic && (_ = a.getParameter(Wc));
        var M = 1, W = 1;
        h.webgl_draw_buffers && (M = a.getParameter(jc), W = a.getParameter(Xc));
        var R = !!h.oes_texture_float;
        if (R) {
          var B = a.createTexture();
          a.bindTexture(eo, B), a.texImage2D(eo, 0, or, 1, 1, 0, or, _a, null);
          var K = a.createFramebuffer();
          if (a.bindFramebuffer(Sa, K), a.framebufferTexture2D(Sa, Qc, eo, B, 0), a.bindTexture(eo, null), a.checkFramebufferStatus(Sa) !== Zc) R = false;
          else {
            a.viewport(0, 0, 1, 1), a.clearColor(1, 0, 0, 1), a.clear(Kc);
            var Q = gt.allocType(_a, 4);
            a.readPixels(0, 0, 1, 1, or, _a, Q), a.getError() ? R = false : (a.deleteFramebuffer(K), a.deleteTexture(B), R = Q[0] === 1), gt.freeType(Q);
          }
        }
        var re = typeof navigator < "u" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent)), ae = true;
        if (!re) {
          var oe = a.createTexture(), ue = gt.allocType(sf, 36);
          a.activeTexture(Yc), a.bindTexture(af, oe), a.texImage2D(qc, 0, or, 3, 3, 0, or, sf, ue), gt.freeType(ue), a.bindTexture(af, null), a.deleteTexture(oe), ae = !a.getError();
        }
        return {
          // drawing buffer bit depth
          colorBits: [
            a.getParameter(qr),
            a.getParameter(Yr),
            a.getParameter(Zr),
            a.getParameter(Qr)
          ],
          depthBits: a.getParameter(ba),
          stencilBits: a.getParameter($e),
          subpixelBits: a.getParameter(un),
          // supported extensions
          extensions: Object.keys(h).filter(function(J) {
            return !!h[J];
          }),
          // max aniso samples
          maxAnisotropic: _,
          // max draw buffers
          maxDrawbuffers: M,
          maxColorAttachments: W,
          // point and line size ranges
          pointSizeDims: a.getParameter(P),
          lineWidthDims: a.getParameter(ve),
          maxViewportDims: a.getParameter(mt),
          maxCombinedTextureUnits: a.getParameter(cn),
          maxCubeMapSize: a.getParameter(Kr),
          maxRenderbufferSize: a.getParameter(Jr),
          maxTextureUnits: a.getParameter(rr),
          maxTextureSize: a.getParameter(ze),
          maxAttributes: a.getParameter(Mt),
          maxVertexUniforms: a.getParameter(wt),
          maxVertexTextureUnits: a.getParameter(ai),
          maxVaryingVectors: a.getParameter(Ht),
          maxFragmentUniforms: a.getParameter(Ot),
          // vendor info
          glsl: a.getParameter(Hc),
          renderer: a.getParameter(Vc),
          vendor: a.getParameter(Uc),
          version: a.getParameter($c),
          // quirks
          readFloat: R,
          npotTextureCube: ae
        };
      };
      function hn(a) {
        return !!a && typeof a == "object" && Array.isArray(a.shape) && Array.isArray(a.stride) && typeof a.offset == "number" && a.shape.length === a.stride.length && (Array.isArray(a.data) || n(a.data));
      }
      var Jt = function(a) {
        return Object.keys(a).map(function(h) {
          return a[h];
        });
      }, to = {
        shape: ih,
        flatten: nh
      };
      function eh(a, h, _) {
        for (var M = 0; M < h; ++M)
          _[M] = a[M];
      }
      function th(a, h, _, M) {
        for (var W = 0, R = 0; R < h; ++R)
          for (var B = a[R], K = 0; K < _; ++K)
            M[W++] = B[K];
      }
      function ff(a, h, _, M, W, R) {
        for (var B = R, K = 0; K < h; ++K)
          for (var Q = a[K], re = 0; re < _; ++re)
            for (var ae = Q[re], oe = 0; oe < M; ++oe)
              W[B++] = ae[oe];
      }
      function lf(a, h, _, M, W) {
        for (var R = 1, B = _ + 1; B < h.length; ++B)
          R *= h[B];
        var K = h[_];
        if (h.length - _ === 4) {
          var Q = h[_ + 1], re = h[_ + 2], ae = h[_ + 3];
          for (B = 0; B < K; ++B)
            ff(a[B], Q, re, ae, M, W), W += R;
        } else
          for (B = 0; B < K; ++B)
            lf(a[B], h, _ + 1, M, W), W += R;
      }
      function nh(a, h, _, M) {
        var W = 1;
        if (h.length)
          for (var R = 0; R < h.length; ++R)
            W *= h[R];
        else
          W = 0;
        var B = M || gt.allocType(_, W);
        switch (h.length) {
          case 0:
            break;
          case 1:
            eh(a, h[0], B);
            break;
          case 2:
            th(a, h[0], h[1], B);
            break;
          case 3:
            ff(a, h[0], h[1], h[2], B, 0);
            break;
          default:
            lf(a, h, 0, B, 0);
        }
        return B;
      }
      function ih(a) {
        for (var h = [], _ = a; _.length; _ = _[0])
          h.push(_.length);
        return h;
      }
      var Ta = {
        "[object Int8Array]": 5120,
        "[object Int16Array]": 5122,
        "[object Int32Array]": 5124,
        "[object Uint8Array]": 5121,
        "[object Uint8ClampedArray]": 5121,
        "[object Uint16Array]": 5123,
        "[object Uint32Array]": 5125,
        "[object Float32Array]": 5126,
        "[object Float64Array]": 5121,
        "[object ArrayBuffer]": 5121
      }, rh = 5120, oh = 5122, ah = 5124, sh = 5121, fh = 5123, lh = 5125, uh = 5126, ch = 5126, si = {
        int8: rh,
        int16: oh,
        int32: ah,
        uint8: sh,
        uint16: fh,
        uint32: lh,
        float: uh,
        float32: ch
      }, hh = 35048, dh = 35040, no = {
        dynamic: hh,
        stream: dh,
        static: 35044
      }, wa = to.flatten, uf = to.shape, cf = 35044, mh = 35040, Aa = 5121, Ea = 5126, Wn = [];
      Wn[5120] = 1, Wn[5122] = 2, Wn[5124] = 4, Wn[5121] = 1, Wn[5123] = 2, Wn[5125] = 4, Wn[5126] = 4;
      function io(a) {
        return Ta[Object.prototype.toString.call(a)] | 0;
      }
      function hf(a, h) {
        for (var _ = 0; _ < h.length; ++_)
          a[_] = h[_];
      }
      function df(a, h, _, M, W, R, B) {
        for (var K = 0, Q = 0; Q < _; ++Q)
          for (var re = 0; re < M; ++re)
            a[K++] = h[W * Q + R * re + B];
      }
      function ph(a, h, _, M) {
        var W = 0, R = {};
        function B(k) {
          this.id = W++, this.buffer = a.createBuffer(), this.type = k, this.usage = cf, this.byteLength = 0, this.dimension = 1, this.dtype = Aa, this.persistentData = null, _.profile && (this.stats = { size: 0 });
        }
        B.prototype.bind = function() {
          a.bindBuffer(this.type, this.buffer);
        }, B.prototype.destroy = function() {
          ue(this);
        };
        var K = [];
        function Q(k, G) {
          var te = K.pop();
          return te || (te = new B(k)), te.bind(), oe(te, G, mh, 0, 1, false), te;
        }
        function re(k) {
          K.push(k);
        }
        function ae(k, G, te) {
          k.byteLength = G.byteLength, a.bufferData(k.type, G, te);
        }
        function oe(k, G, te, xe, Z, ge) {
          var me;
          if (k.usage = te, Array.isArray(G)) {
            if (k.dtype = xe || Ea, G.length > 0) {
              var De;
              if (Array.isArray(G[0])) {
                me = uf(G);
                for (var X = 1, H = 1; H < me.length; ++H)
                  X *= me[H];
                k.dimension = X, De = wa(G, me, k.dtype), ae(k, De, te), ge ? k.persistentData = De : gt.freeType(De);
              } else if (typeof G[0] == "number") {
                k.dimension = Z;
                var Se = gt.allocType(k.dtype, G.length);
                hf(Se, G), ae(k, Se, te), ge ? k.persistentData = Se : gt.freeType(Se);
              } else n(G[0]) ? (k.dimension = G[0].length, k.dtype = xe || io(G[0]) || Ea, De = wa(
                G,
                [G.length, G[0].length],
                k.dtype
              ), ae(k, De, te), ge ? k.persistentData = De : gt.freeType(De)) : d.raise("invalid buffer data");
            }
          } else if (n(G))
            k.dtype = xe || io(G), k.dimension = Z, ae(k, G, te), ge && (k.persistentData = new Uint8Array(new Uint8Array(G.buffer)));
          else if (hn(G)) {
            me = G.shape;
            var ce = G.stride, ee = G.offset, he = 0, de = 0, He = 0, Ue = 0;
            me.length === 1 ? (he = me[0], de = 1, He = ce[0], Ue = 0) : me.length === 2 ? (he = me[0], de = me[1], He = ce[0], Ue = ce[1]) : d.raise("invalid shape"), k.dtype = xe || io(G.data) || Ea, k.dimension = de;
            var pe = gt.allocType(k.dtype, he * de);
            df(
              pe,
              G.data,
              he,
              de,
              He,
              Ue,
              ee
            ), ae(k, pe, te), ge ? k.persistentData = pe : gt.freeType(pe);
          } else G instanceof ArrayBuffer ? (k.dtype = Aa, k.dimension = Z, ae(k, G, te), ge && (k.persistentData = new Uint8Array(new Uint8Array(G)))) : d.raise("invalid buffer data");
        }
        function ue(k) {
          h.bufferCount--, M(k);
          var G = k.buffer;
          d(G, "buffer must not be deleted already"), a.deleteBuffer(G), k.buffer = null, delete R[k.id];
        }
        function J(k, G, te, xe) {
          h.bufferCount++;
          var Z = new B(G);
          R[Z.id] = Z;
          function ge(X) {
            var H = cf, Se = null, ce = 0, ee = 0, he = 1;
            return Array.isArray(X) || n(X) || hn(X) || X instanceof ArrayBuffer ? Se = X : typeof X == "number" ? ce = X | 0 : X && (d.type(
              X,
              "object",
              "buffer arguments must be an object, a number or an array"
            ), "data" in X && (d(
              Se === null || Array.isArray(Se) || n(Se) || hn(Se),
              "invalid data for buffer"
            ), Se = X.data), "usage" in X && (d.parameter(X.usage, no, "invalid buffer usage"), H = no[X.usage]), "type" in X && (d.parameter(X.type, si, "invalid buffer type"), ee = si[X.type]), "dimension" in X && (d.type(X.dimension, "number", "invalid dimension"), he = X.dimension | 0), "length" in X && (d.nni(ce, "buffer length must be a nonnegative integer"), ce = X.length | 0)), Z.bind(), Se ? oe(Z, Se, H, ee, he, xe) : (ce && a.bufferData(Z.type, ce, H), Z.dtype = ee || Aa, Z.usage = H, Z.dimension = he, Z.byteLength = ce), _.profile && (Z.stats.size = Z.byteLength * Wn[Z.dtype]), ge;
          }
          function me(X, H) {
            d(
              H + X.byteLength <= Z.byteLength,
              "invalid buffer subdata call, buffer is too small.  Can't write data of size " + X.byteLength + " starting from offset " + H + " to a buffer of size " + Z.byteLength
            ), a.bufferSubData(Z.type, H, X);
          }
          function De(X, H) {
            var Se = (H || 0) | 0, ce;
            if (Z.bind(), n(X) || X instanceof ArrayBuffer)
              me(X, Se);
            else if (Array.isArray(X)) {
              if (X.length > 0)
                if (typeof X[0] == "number") {
                  var ee = gt.allocType(Z.dtype, X.length);
                  hf(ee, X), me(ee, Se), gt.freeType(ee);
                } else if (Array.isArray(X[0]) || n(X[0])) {
                  ce = uf(X);
                  var he = wa(X, ce, Z.dtype);
                  me(he, Se), gt.freeType(he);
                } else
                  d.raise("invalid buffer data");
            } else if (hn(X)) {
              ce = X.shape;
              var de = X.stride, He = 0, Ue = 0, pe = 0, ye = 0;
              ce.length === 1 ? (He = ce[0], Ue = 1, pe = de[0], ye = 0) : ce.length === 2 ? (He = ce[0], Ue = ce[1], pe = de[0], ye = de[1]) : d.raise("invalid shape");
              var Re = Array.isArray(X.data) ? Z.dtype : io(X.data), We = gt.allocType(Re, He * Ue);
              df(
                We,
                X.data,
                He,
                Ue,
                pe,
                ye,
                X.offset
              ), me(We, Se), gt.freeType(We);
            } else
              d.raise("invalid data for buffer subdata");
            return ge;
          }
          return te || ge(k), ge._reglType = "buffer", ge._buffer = Z, ge.subdata = De, _.profile && (ge.stats = Z.stats), ge.destroy = function() {
            ue(Z);
          }, ge;
        }
        function ne() {
          Jt(R).forEach(function(k) {
            k.buffer = a.createBuffer(), a.bindBuffer(k.type, k.buffer), a.bufferData(
              k.type,
              k.persistentData || k.byteLength,
              k.usage
            );
          });
        }
        return _.profile && (h.getTotalBufferSize = function() {
          var k = 0;
          return Object.keys(R).forEach(function(G) {
            k += R[G].stats.size;
          }), k;
        }), {
          create: J,
          createStream: Q,
          destroyStream: re,
          clear: function() {
            Jt(R).forEach(ue), K.forEach(ue);
          },
          getBuffer: function(k) {
            return k && k._buffer instanceof B ? k._buffer : null;
          },
          restore: ne,
          _initBuffer: oe
        };
      }
      var vh = 0, gh = 0, yh = 1, xh = 1, bh = 4, _h = 4, Xn = {
        points: vh,
        point: gh,
        lines: yh,
        line: xh,
        triangles: bh,
        triangle: _h,
        "line loop": 2,
        "line strip": 3,
        "triangle strip": 5,
        "triangle fan": 6
      }, Sh = 0, Th = 1, ar = 4, wh = 5120, zi = 5121, mf = 5122, Ri = 5123, pf = 5124, fi = 5125, Ca = 34963, Ah = 35040, Eh = 35044;
      function Ch(a, h, _, M) {
        var W = {}, R = 0, B = {
          uint8: zi,
          uint16: Ri
        };
        h.oes_element_index_uint && (B.uint32 = fi);
        function K(ne) {
          this.id = R++, W[this.id] = this, this.buffer = ne, this.primType = ar, this.vertCount = 0, this.type = 0;
        }
        K.prototype.bind = function() {
          this.buffer.bind();
        };
        var Q = [];
        function re(ne) {
          var k = Q.pop();
          return k || (k = new K(_.create(
            null,
            Ca,
            true,
            false
          )._buffer)), oe(k, ne, Ah, -1, -1, 0, 0), k;
        }
        function ae(ne) {
          Q.push(ne);
        }
        function oe(ne, k, G, te, xe, Z, ge) {
          ne.buffer.bind();
          var me;
          if (k) {
            var De = ge;
            !ge && (!n(k) || hn(k) && !n(k.data)) && (De = h.oes_element_index_uint ? fi : Ri), _._initBuffer(
              ne.buffer,
              k,
              G,
              De,
              3
            );
          } else
            a.bufferData(Ca, Z, G), ne.buffer.dtype = me || zi, ne.buffer.usage = G, ne.buffer.dimension = 3, ne.buffer.byteLength = Z;
          if (me = ge, !ge) {
            switch (ne.buffer.dtype) {
              case zi:
              case wh:
                me = zi;
                break;
              case Ri:
              case mf:
                me = Ri;
                break;
              case fi:
              case pf:
                me = fi;
                break;
              default:
                d.raise("unsupported type for element array");
            }
            ne.buffer.dtype = me;
          }
          ne.type = me, d(
            me !== fi || !!h.oes_element_index_uint,
            "32 bit element buffers not supported, enable oes_element_index_uint first"
          );
          var X = xe;
          X < 0 && (X = ne.buffer.byteLength, me === Ri ? X >>= 1 : me === fi && (X >>= 2)), ne.vertCount = X;
          var H = te;
          if (te < 0) {
            H = ar;
            var Se = ne.buffer.dimension;
            Se === 1 && (H = Sh), Se === 2 && (H = Th), Se === 3 && (H = ar);
          }
          ne.primType = H;
        }
        function ue(ne) {
          M.elementsCount--, d(ne.buffer !== null, "must not double destroy elements"), delete W[ne.id], ne.buffer.destroy(), ne.buffer = null;
        }
        function J(ne, k) {
          var G = _.create(null, Ca, true), te = new K(G._buffer);
          M.elementsCount++;
          function xe(Z) {
            if (!Z)
              G(), te.primType = ar, te.vertCount = 0, te.type = zi;
            else if (typeof Z == "number")
              G(Z), te.primType = ar, te.vertCount = Z | 0, te.type = zi;
            else {
              var ge = null, me = Eh, De = -1, X = -1, H = 0, Se = 0;
              Array.isArray(Z) || n(Z) || hn(Z) ? ge = Z : (d.type(Z, "object", "invalid arguments for elements"), "data" in Z && (ge = Z.data, d(
                Array.isArray(ge) || n(ge) || hn(ge),
                "invalid data for element buffer"
              )), "usage" in Z && (d.parameter(
                Z.usage,
                no,
                "invalid element buffer usage"
              ), me = no[Z.usage]), "primitive" in Z && (d.parameter(
                Z.primitive,
                Xn,
                "invalid element buffer primitive"
              ), De = Xn[Z.primitive]), "count" in Z && (d(
                typeof Z.count == "number" && Z.count >= 0,
                "invalid vertex count for elements"
              ), X = Z.count | 0), "type" in Z && (d.parameter(
                Z.type,
                B,
                "invalid buffer type"
              ), Se = B[Z.type]), "length" in Z ? H = Z.length | 0 : (H = X, Se === Ri || Se === mf ? H *= 2 : (Se === fi || Se === pf) && (H *= 4))), oe(
                te,
                ge,
                me,
                De,
                X,
                H,
                Se
              );
            }
            return xe;
          }
          return xe(ne), xe._reglType = "elements", xe._elements = te, xe.subdata = function(Z, ge) {
            return G.subdata(Z, ge), xe;
          }, xe.destroy = function() {
            ue(te);
          }, xe;
        }
        return {
          create: J,
          createStream: re,
          destroyStream: ae,
          getElements: function(ne) {
            return typeof ne == "function" && ne._elements instanceof K ? ne._elements : null;
          },
          clear: function() {
            Jt(W).forEach(ue);
          }
        };
      }
      var vf = new Float32Array(1), Ph = new Uint32Array(vf.buffer), kh = 5123;
      function gf(a) {
        for (var h = gt.allocType(kh, a.length), _ = 0; _ < a.length; ++_)
          if (isNaN(a[_]))
            h[_] = 65535;
          else if (a[_] === 1 / 0)
            h[_] = 31744;
          else if (a[_] === -1 / 0)
            h[_] = 64512;
          else {
            vf[0] = a[_];
            var M = Ph[0], W = M >>> 31 << 15, R = (M << 1 >>> 24) - 127, B = M >> 13 & 1023;
            if (R < -24)
              h[_] = W;
            else if (R < -14) {
              var K = -14 - R;
              h[_] = W + (B + 1024 >> K);
            } else R > 15 ? h[_] = W + 31744 : h[_] = W + (R + 15 << 10) + B;
          }
        return h;
      }
      function pt(a) {
        return Array.isArray(a) || n(a);
      }
      var yf = function(a) {
        return !(a & a - 1) && !!a;
      }, Ih = 34467, _n = 3553, Pa = 34067, ro = 34069, li = 6408, ka = 6406, oo = 6407, sr = 6409, ao = 6410, xf = 32854, Ia = 32855, bf = 36194, Lh = 32819, Dh = 32820, Fh = 33635, zh = 34042, La = 6402, so = 34041, Da = 35904, Fa = 35906, Mi = 36193, za = 33776, Ra = 33777, Ma = 33778, Oa = 33779, _f = 35986, Sf = 35987, Tf = 34798, wf = 35840, Af = 35841, Ef = 35842, Cf = 35843, Pf = 36196, Oi = 5121, Na = 5123, Ga = 5125, fr = 5126, Rh = 10242, Mh = 10243, Oh = 10497, Ba = 33071, Nh = 33648, Gh = 10240, Bh = 10241, Ua = 9728, Uh = 9729, Va = 9984, kf = 9985, If = 9986, $a = 9987, Vh = 33170, fo = 4352, $h = 4353, Hh = 4354, Wh = 34046, Xh = 3317, jh = 37440, qh = 37441, Yh = 37443, Lf = 37444, lr = 33984, Zh = [
        Va,
        If,
        kf,
        $a
      ], lo = [
        0,
        sr,
        ao,
        oo,
        li
      ], an = {};
      an[sr] = an[ka] = an[La] = 1, an[so] = an[ao] = 2, an[oo] = an[Da] = 3, an[li] = an[Fa] = 4;
      function Ni(a) {
        return "[object " + a + "]";
      }
      var Df = Ni("HTMLCanvasElement"), Ff = Ni("OffscreenCanvas"), zf = Ni("CanvasRenderingContext2D"), Rf = Ni("ImageBitmap"), Mf = Ni("HTMLImageElement"), Of = Ni("HTMLVideoElement"), Qh = Object.keys(Ta).concat([
        Df,
        Ff,
        zf,
        Rf,
        Mf,
        Of
      ]), Gi = [];
      Gi[Oi] = 1, Gi[fr] = 4, Gi[Mi] = 2, Gi[Na] = 2, Gi[Ga] = 4;
      var Nt = [];
      Nt[xf] = 2, Nt[Ia] = 2, Nt[bf] = 2, Nt[so] = 4, Nt[za] = 0.5, Nt[Ra] = 0.5, Nt[Ma] = 1, Nt[Oa] = 1, Nt[_f] = 0.5, Nt[Sf] = 1, Nt[Tf] = 1, Nt[wf] = 0.5, Nt[Af] = 0.25, Nt[Ef] = 0.5, Nt[Cf] = 0.25, Nt[Pf] = 0.5;
      function Nf(a) {
        return Array.isArray(a) && (a.length === 0 || typeof a[0] == "number");
      }
      function Gf(a) {
        if (!Array.isArray(a))
          return false;
        var h = a.length;
        return !(h === 0 || !pt(a[0]));
      }
      function ui(a) {
        return Object.prototype.toString.call(a);
      }
      function Bf(a) {
        return ui(a) === Df;
      }
      function Uf(a) {
        return ui(a) === Ff;
      }
      function Kh(a) {
        return ui(a) === zf;
      }
      function Jh(a) {
        return ui(a) === Rf;
      }
      function ed(a) {
        return ui(a) === Mf;
      }
      function td(a) {
        return ui(a) === Of;
      }
      function Ha(a) {
        if (!a)
          return false;
        var h = ui(a);
        return Qh.indexOf(h) >= 0 ? true : Nf(a) || Gf(a) || hn(a);
      }
      function Vf(a) {
        return Ta[Object.prototype.toString.call(a)] | 0;
      }
      function nd(a, h) {
        var _ = h.length;
        switch (a.type) {
          case Oi:
          case Na:
          case Ga:
          case fr:
            var M = gt.allocType(a.type, _);
            M.set(h), a.data = M;
            break;
          case Mi:
            a.data = gf(h);
            break;
          default:
            d.raise("unsupported texture type, must specify a typed array");
        }
      }
      function $f(a, h) {
        return gt.allocType(
          a.type === Mi ? fr : a.type,
          h
        );
      }
      function Hf(a, h) {
        a.type === Mi ? (a.data = gf(h), gt.freeType(h)) : a.data = h;
      }
      function id(a, h, _, M, W, R) {
        for (var B = a.width, K = a.height, Q = a.channels, re = B * K * Q, ae = $f(a, re), oe = 0, ue = 0; ue < K; ++ue)
          for (var J = 0; J < B; ++J)
            for (var ne = 0; ne < Q; ++ne)
              ae[oe++] = h[_ * J + M * ue + W * ne + R];
        Hf(a, ae);
      }
      function uo(a, h, _, M, W, R) {
        var B;
        if (typeof Nt[a] < "u" ? B = Nt[a] : B = an[a] * Gi[h], R && (B *= 6), W) {
          for (var K = 0, Q = _; Q >= 1; )
            K += B * Q * Q, Q /= 2;
          return K;
        } else
          return B * _ * M;
      }
      function rd(a, h, _, M, W, R, B) {
        var K = {
          "don't care": fo,
          "dont care": fo,
          nice: Hh,
          fast: $h
        }, Q = {
          repeat: Oh,
          clamp: Ba,
          mirror: Nh
        }, re = {
          nearest: Ua,
          linear: Uh
        }, ae = i({
          mipmap: $a,
          "nearest mipmap nearest": Va,
          "linear mipmap nearest": kf,
          "nearest mipmap linear": If,
          "linear mipmap linear": $a
        }, re), oe = {
          none: 0,
          browser: Lf
        }, ue = {
          uint8: Oi,
          rgba4: Lh,
          rgb565: Fh,
          "rgb5 a1": Dh
        }, J = {
          alpha: ka,
          luminance: sr,
          "luminance alpha": ao,
          rgb: oo,
          rgba: li,
          rgba4: xf,
          "rgb5 a1": Ia,
          rgb565: bf
        }, ne = {};
        h.ext_srgb && (J.srgb = Da, J.srgba = Fa), h.oes_texture_float && (ue.float32 = ue.float = fr), h.oes_texture_half_float && (ue.float16 = ue["half float"] = Mi), h.webgl_depth_texture && (i(J, {
          depth: La,
          "depth stencil": so
        }), i(ue, {
          uint16: Na,
          uint32: Ga,
          "depth stencil": zh
        })), h.webgl_compressed_texture_s3tc && i(ne, {
          "rgb s3tc dxt1": za,
          "rgba s3tc dxt1": Ra,
          "rgba s3tc dxt3": Ma,
          "rgba s3tc dxt5": Oa
        }), h.webgl_compressed_texture_atc && i(ne, {
          "rgb atc": _f,
          "rgba atc explicit alpha": Sf,
          "rgba atc interpolated alpha": Tf
        }), h.webgl_compressed_texture_pvrtc && i(ne, {
          "rgb pvrtc 4bppv1": wf,
          "rgb pvrtc 2bppv1": Af,
          "rgba pvrtc 4bppv1": Ef,
          "rgba pvrtc 2bppv1": Cf
        }), h.webgl_compressed_texture_etc1 && (ne["rgb etc1"] = Pf);
        var k = Array.prototype.slice.call(
          a.getParameter(Ih)
        );
        Object.keys(ne).forEach(function(x) {
          var O = ne[x];
          k.indexOf(O) >= 0 && (J[x] = O);
        });
        var G = Object.keys(J);
        _.textureFormats = G;
        var te = [];
        Object.keys(J).forEach(function(x) {
          var O = J[x];
          te[O] = x;
        });
        var xe = [];
        Object.keys(ue).forEach(function(x) {
          var O = ue[x];
          xe[O] = x;
        });
        var Z = [];
        Object.keys(re).forEach(function(x) {
          var O = re[x];
          Z[O] = x;
        });
        var ge = [];
        Object.keys(ae).forEach(function(x) {
          var O = ae[x];
          ge[O] = x;
        });
        var me = [];
        Object.keys(Q).forEach(function(x) {
          var O = Q[x];
          me[O] = x;
        });
        var De = G.reduce(function(x, O) {
          var z = J[O];
          return z === sr || z === ka || z === sr || z === ao || z === La || z === so || h.ext_srgb && (z === Da || z === Fa) ? x[z] = z : z === Ia || O.indexOf("rgba") >= 0 ? x[z] = li : x[z] = oo, x;
        }, {});
        function X() {
          this.internalformat = li, this.format = li, this.type = Oi, this.compressed = false, this.premultiplyAlpha = false, this.flipY = false, this.unpackAlignment = 1, this.colorSpace = Lf, this.width = 0, this.height = 0, this.channels = 0;
        }
        function H(x, O) {
          x.internalformat = O.internalformat, x.format = O.format, x.type = O.type, x.compressed = O.compressed, x.premultiplyAlpha = O.premultiplyAlpha, x.flipY = O.flipY, x.unpackAlignment = O.unpackAlignment, x.colorSpace = O.colorSpace, x.width = O.width, x.height = O.height, x.channels = O.channels;
        }
        function Se(x, O) {
          if (!(typeof O != "object" || !O)) {
            if ("premultiplyAlpha" in O && (d.type(
              O.premultiplyAlpha,
              "boolean",
              "invalid premultiplyAlpha"
            ), x.premultiplyAlpha = O.premultiplyAlpha), "flipY" in O && (d.type(
              O.flipY,
              "boolean",
              "invalid texture flip"
            ), x.flipY = O.flipY), "alignment" in O && (d.oneOf(
              O.alignment,
              [1, 2, 4, 8],
              "invalid texture unpack alignment"
            ), x.unpackAlignment = O.alignment), "colorSpace" in O && (d.parameter(
              O.colorSpace,
              oe,
              "invalid colorSpace"
            ), x.colorSpace = oe[O.colorSpace]), "type" in O) {
              var z = O.type;
              d(
                h.oes_texture_float || !(z === "float" || z === "float32"),
                "you must enable the OES_texture_float extension in order to use floating point textures."
              ), d(
                h.oes_texture_half_float || !(z === "half float" || z === "float16"),
                "you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."
              ), d(
                h.webgl_depth_texture || !(z === "uint16" || z === "uint32" || z === "depth stencil"),
                "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
              ), d.parameter(
                z,
                ue,
                "invalid texture type"
              ), x.type = ue[z];
            }
            var _e = x.width, Ke = x.height, p = x.channels, c = false;
            "shape" in O ? (d(
              Array.isArray(O.shape) && O.shape.length >= 2,
              "shape must be an array"
            ), _e = O.shape[0], Ke = O.shape[1], O.shape.length === 3 && (p = O.shape[2], d(p > 0 && p <= 4, "invalid number of channels"), c = true), d(_e >= 0 && _e <= _.maxTextureSize, "invalid width"), d(Ke >= 0 && Ke <= _.maxTextureSize, "invalid height")) : ("radius" in O && (_e = Ke = O.radius, d(_e >= 0 && _e <= _.maxTextureSize, "invalid radius")), "width" in O && (_e = O.width, d(_e >= 0 && _e <= _.maxTextureSize, "invalid width")), "height" in O && (Ke = O.height, d(Ke >= 0 && Ke <= _.maxTextureSize, "invalid height")), "channels" in O && (p = O.channels, d(p > 0 && p <= 4, "invalid number of channels"), c = true)), x.width = _e | 0, x.height = Ke | 0, x.channels = p | 0;
            var T = false;
            if ("format" in O) {
              var C = O.format;
              d(
                h.webgl_depth_texture || !(C === "depth" || C === "depth stencil"),
                "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
              ), d.parameter(
                C,
                J,
                "invalid texture format"
              );
              var I = x.internalformat = J[C];
              x.format = De[I], C in ue && ("type" in O || (x.type = ue[C])), C in ne && (x.compressed = true), T = true;
            }
            !c && T ? x.channels = an[x.format] : c && !T ? x.channels !== lo[x.format] && (x.format = x.internalformat = lo[x.channels]) : T && c && d(
              x.channels === an[x.format],
              "number of channels inconsistent with specified format"
            );
          }
        }
        function ce(x) {
          a.pixelStorei(jh, x.flipY), a.pixelStorei(qh, x.premultiplyAlpha), a.pixelStorei(Yh, x.colorSpace), a.pixelStorei(Xh, x.unpackAlignment);
        }
        function ee() {
          X.call(this), this.xOffset = 0, this.yOffset = 0, this.data = null, this.needsFree = false, this.element = null, this.needsCopy = false;
        }
        function he(x, O) {
          var z = null;
          if (Ha(O) ? z = O : O && (d.type(O, "object", "invalid pixel data type"), Se(x, O), "x" in O && (x.xOffset = O.x | 0), "y" in O && (x.yOffset = O.y | 0), Ha(O.data) && (z = O.data)), d(
            !x.compressed || z instanceof Uint8Array,
            "compressed texture data must be stored in a uint8array"
          ), O.copy) {
            d(!z, "can not specify copy and data field for the same texture");
            var _e = W.viewportWidth, Ke = W.viewportHeight;
            x.width = x.width || _e - x.xOffset, x.height = x.height || Ke - x.yOffset, x.needsCopy = true, d(
              x.xOffset >= 0 && x.xOffset < _e && x.yOffset >= 0 && x.yOffset < Ke && x.width > 0 && x.width <= _e && x.height > 0 && x.height <= Ke,
              "copy texture read out of bounds"
            );
          } else if (!z)
            x.width = x.width || 1, x.height = x.height || 1, x.channels = x.channels || 4;
          else if (n(z))
            x.channels = x.channels || 4, x.data = z, !("type" in O) && x.type === Oi && (x.type = Vf(z));
          else if (Nf(z))
            x.channels = x.channels || 4, nd(x, z), x.alignment = 1, x.needsFree = true;
          else if (hn(z)) {
            var p = z.data;
            !Array.isArray(p) && x.type === Oi && (x.type = Vf(p));
            var c = z.shape, T = z.stride, C, I, A, w, E, v;
            c.length === 3 ? (A = c[2], v = T[2]) : (d(c.length === 2, "invalid ndarray pixel data, must be 2 or 3D"), A = 1, v = 1), C = c[0], I = c[1], w = T[0], E = T[1], x.alignment = 1, x.width = C, x.height = I, x.channels = A, x.format = x.internalformat = lo[A], x.needsFree = true, id(x, p, w, E, v, z.offset);
          } else if (Bf(z) || Uf(z) || Kh(z))
            Bf(z) || Uf(z) ? x.element = z : x.element = z.canvas, x.width = x.element.width, x.height = x.element.height, x.channels = 4;
          else if (Jh(z))
            x.element = z, x.width = z.width, x.height = z.height, x.channels = 4;
          else if (ed(z))
            x.element = z, x.width = z.naturalWidth, x.height = z.naturalHeight, x.channels = 4;
          else if (td(z))
            x.element = z, x.width = z.videoWidth, x.height = z.videoHeight, x.channels = 4;
          else if (Gf(z)) {
            var b = x.width || z[0].length, g = x.height || z.length, F = x.channels;
            pt(z[0][0]) ? F = F || z[0][0].length : F = F || 1;
            for (var L = to.shape(z), $ = 1, j = 0; j < L.length; ++j)
              $ *= L[j];
            var le = $f(x, $);
            to.flatten(z, L, "", le), Hf(x, le), x.alignment = 1, x.width = b, x.height = g, x.channels = F, x.format = x.internalformat = lo[F], x.needsFree = true;
          }
          x.type === fr ? d(
            _.extensions.indexOf("oes_texture_float") >= 0,
            "oes_texture_float extension not enabled"
          ) : x.type === Mi && d(
            _.extensions.indexOf("oes_texture_half_float") >= 0,
            "oes_texture_half_float extension not enabled"
          );
        }
        function de(x, O, z) {
          var _e = x.element, Ke = x.data, p = x.internalformat, c = x.format, T = x.type, C = x.width, I = x.height;
          ce(x), _e ? a.texImage2D(O, z, c, c, T, _e) : x.compressed ? a.compressedTexImage2D(O, z, p, C, I, 0, Ke) : x.needsCopy ? (M(), a.copyTexImage2D(
            O,
            z,
            c,
            x.xOffset,
            x.yOffset,
            C,
            I,
            0
          )) : a.texImage2D(O, z, c, C, I, 0, c, T, Ke || null);
        }
        function He(x, O, z, _e, Ke) {
          var p = x.element, c = x.data, T = x.internalformat, C = x.format, I = x.type, A = x.width, w = x.height;
          ce(x), p ? a.texSubImage2D(
            O,
            Ke,
            z,
            _e,
            C,
            I,
            p
          ) : x.compressed ? a.compressedTexSubImage2D(
            O,
            Ke,
            z,
            _e,
            T,
            A,
            w,
            c
          ) : x.needsCopy ? (M(), a.copyTexSubImage2D(
            O,
            Ke,
            z,
            _e,
            x.xOffset,
            x.yOffset,
            A,
            w
          )) : a.texSubImage2D(
            O,
            Ke,
            z,
            _e,
            A,
            w,
            C,
            I,
            c
          );
        }
        var Ue = [];
        function pe() {
          return Ue.pop() || new ee();
        }
        function ye(x) {
          x.needsFree && gt.freeType(x.data), ee.call(x), Ue.push(x);
        }
        function Re() {
          X.call(this), this.genMipmaps = false, this.mipmapHint = fo, this.mipmask = 0, this.images = Array(16);
        }
        function We(x, O, z) {
          var _e = x.images[0] = pe();
          x.mipmask = 1, _e.width = x.width = O, _e.height = x.height = z, _e.channels = x.channels = 4;
        }
        function Je(x, O) {
          var z = null;
          if (Ha(O))
            z = x.images[0] = pe(), H(z, x), he(z, O), x.mipmask = 1;
          else if (Se(x, O), Array.isArray(O.mipmap))
            for (var _e = O.mipmap, Ke = 0; Ke < _e.length; ++Ke)
              z = x.images[Ke] = pe(), H(z, x), z.width >>= Ke, z.height >>= Ke, he(z, _e[Ke]), x.mipmask |= 1 << Ke;
          else
            z = x.images[0] = pe(), H(z, x), he(z, O), x.mipmask = 1;
          H(x, x.images[0]), x.compressed && (x.internalformat === za || x.internalformat === Ra || x.internalformat === Ma || x.internalformat === Oa) && d(
            x.width % 4 === 0 && x.height % 4 === 0,
            "for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4"
          );
        }
        function vt(x, O) {
          for (var z = x.images, _e = 0; _e < z.length; ++_e) {
            if (!z[_e])
              return;
            de(z[_e], O, _e);
          }
        }
        var yt = [];
        function tt() {
          var x = yt.pop() || new Re();
          X.call(x), x.mipmask = 0;
          for (var O = 0; O < 16; ++O)
            x.images[O] = null;
          return x;
        }
        function At(x) {
          for (var O = x.images, z = 0; z < O.length; ++z)
            O[z] && ye(O[z]), O[z] = null;
          yt.push(x);
        }
        function ht() {
          this.minFilter = Ua, this.magFilter = Ua, this.wrapS = Ba, this.wrapT = Ba, this.anisotropic = 1, this.genMipmaps = false, this.mipmapHint = fo;
        }
        function Tt(x, O) {
          if ("min" in O) {
            var z = O.min;
            d.parameter(z, ae), x.minFilter = ae[z], Zh.indexOf(x.minFilter) >= 0 && !("faces" in O) && (x.genMipmaps = true);
          }
          if ("mag" in O) {
            var _e = O.mag;
            d.parameter(_e, re), x.magFilter = re[_e];
          }
          var Ke = x.wrapS, p = x.wrapT;
          if ("wrap" in O) {
            var c = O.wrap;
            typeof c == "string" ? (d.parameter(c, Q), Ke = p = Q[c]) : Array.isArray(c) && (d.parameter(c[0], Q), d.parameter(c[1], Q), Ke = Q[c[0]], p = Q[c[1]]);
          } else {
            if ("wrapS" in O) {
              var T = O.wrapS;
              d.parameter(T, Q), Ke = Q[T];
            }
            if ("wrapT" in O) {
              var C = O.wrapT;
              d.parameter(C, Q), p = Q[C];
            }
          }
          if (x.wrapS = Ke, x.wrapT = p, "anisotropic" in O) {
            var I = O.anisotropic;
            d(
              typeof I == "number" && I >= 1 && I <= _.maxAnisotropic,
              "aniso samples must be between 1 and "
            ), x.anisotropic = O.anisotropic;
          }
          if ("mipmap" in O) {
            var A = false;
            switch (typeof O.mipmap) {
              case "string":
                d.parameter(
                  O.mipmap,
                  K,
                  "invalid mipmap hint"
                ), x.mipmapHint = K[O.mipmap], x.genMipmaps = true, A = true;
                break;
              case "boolean":
                A = x.genMipmaps = O.mipmap;
                break;
              case "object":
                d(Array.isArray(O.mipmap), "invalid mipmap type"), x.genMipmaps = false, A = true;
                break;
              default:
                d.raise("invalid mipmap type");
            }
            A && !("min" in O) && (x.minFilter = Va);
          }
        }
        function Et(x, O) {
          a.texParameteri(O, Bh, x.minFilter), a.texParameteri(O, Gh, x.magFilter), a.texParameteri(O, Rh, x.wrapS), a.texParameteri(O, Mh, x.wrapT), h.ext_texture_filter_anisotropic && a.texParameteri(O, Wh, x.anisotropic), x.genMipmaps && (a.hint(Vh, x.mipmapHint), a.generateMipmap(O));
        }
        var Ct = 0, Ft = {}, Gt = _.maxTextureUnits, xt = Array(Gt).map(function() {
          return null;
        });
        function Ye(x) {
          X.call(this), this.mipmask = 0, this.internalformat = li, this.id = Ct++, this.refCount = 1, this.target = x, this.texture = a.createTexture(), this.unit = -1, this.bindCount = 0, this.texInfo = new ht(), B.profile && (this.stats = { size: 0 });
        }
        function Bt(x) {
          a.activeTexture(lr), a.bindTexture(x.target, x.texture);
        }
        function at() {
          var x = xt[0];
          x ? a.bindTexture(x.target, x.texture) : a.bindTexture(_n, null);
        }
        function Fe(x) {
          var O = x.texture;
          d(O, "must not double destroy texture");
          var z = x.unit, _e = x.target;
          z >= 0 && (a.activeTexture(lr + z), a.bindTexture(_e, null), xt[z] = null), a.deleteTexture(O), x.texture = null, x.params = null, x.pixels = null, x.refCount = 0, delete Ft[x.id], R.textureCount--;
        }
        i(Ye.prototype, {
          bind: function() {
            var x = this;
            x.bindCount += 1;
            var O = x.unit;
            if (O < 0) {
              for (var z = 0; z < Gt; ++z) {
                var _e = xt[z];
                if (_e) {
                  if (_e.bindCount > 0)
                    continue;
                  _e.unit = -1;
                }
                xt[z] = x, O = z;
                break;
              }
              O >= Gt && d.raise("insufficient number of texture units"), B.profile && R.maxTextureUnits < O + 1 && (R.maxTextureUnits = O + 1), x.unit = O, a.activeTexture(lr + O), a.bindTexture(x.target, x.texture);
            }
            return O;
          },
          unbind: function() {
            this.bindCount -= 1;
          },
          decRef: function() {
            --this.refCount <= 0 && Fe(this);
          }
        });
        function et(x, O) {
          var z = new Ye(_n);
          Ft[z.id] = z, R.textureCount++;
          function _e(c, T) {
            var C = z.texInfo;
            ht.call(C);
            var I = tt();
            return typeof c == "number" ? typeof T == "number" ? We(I, c | 0, T | 0) : We(I, c | 0, c | 0) : c ? (d.type(c, "object", "invalid arguments to regl.texture"), Tt(C, c), Je(I, c)) : We(I, 1, 1), C.genMipmaps && (I.mipmask = (I.width << 1) - 1), z.mipmask = I.mipmask, H(z, I), d.texture2D(C, I, _), z.internalformat = I.internalformat, _e.width = I.width, _e.height = I.height, Bt(z), vt(I, _n), Et(C, _n), at(), At(I), B.profile && (z.stats.size = uo(
              z.internalformat,
              z.type,
              I.width,
              I.height,
              C.genMipmaps,
              false
            )), _e.format = te[z.internalformat], _e.type = xe[z.type], _e.mag = Z[C.magFilter], _e.min = ge[C.minFilter], _e.wrapS = me[C.wrapS], _e.wrapT = me[C.wrapT], _e;
          }
          function Ke(c, T, C, I) {
            d(!!c, "must specify image data");
            var A = T | 0, w = C | 0, E = I | 0, v = pe();
            return H(v, z), v.width = 0, v.height = 0, he(v, c), v.width = v.width || (z.width >> E) - A, v.height = v.height || (z.height >> E) - w, d(
              z.type === v.type && z.format === v.format && z.internalformat === v.internalformat,
              "incompatible format for texture.subimage"
            ), d(
              A >= 0 && w >= 0 && A + v.width <= z.width && w + v.height <= z.height,
              "texture.subimage write out of bounds"
            ), d(
              z.mipmask & 1 << E,
              "missing mipmap data"
            ), d(
              v.data || v.element || v.needsCopy,
              "missing image data"
            ), Bt(z), He(v, _n, A, w, E), at(), ye(v), _e;
          }
          function p(c, T) {
            var C = c | 0, I = T | 0 || C;
            if (C === z.width && I === z.height)
              return _e;
            _e.width = z.width = C, _e.height = z.height = I, Bt(z);
            for (var A = 0; z.mipmask >> A; ++A) {
              var w = C >> A, E = I >> A;
              if (!w || !E) break;
              a.texImage2D(
                _n,
                A,
                z.format,
                w,
                E,
                0,
                z.format,
                z.type,
                null
              );
            }
            return at(), B.profile && (z.stats.size = uo(
              z.internalformat,
              z.type,
              C,
              I,
              false,
              false
            )), _e;
          }
          return _e(x, O), _e.subimage = Ke, _e.resize = p, _e._reglType = "texture2d", _e._texture = z, B.profile && (_e.stats = z.stats), _e.destroy = function() {
            z.decRef();
          }, _e;
        }
        function it(x, O, z, _e, Ke, p) {
          var c = new Ye(Pa);
          Ft[c.id] = c, R.cubeCount++;
          var T = new Array(6);
          function C(w, E, v, b, g, F) {
            var L, $ = c.texInfo;
            for (ht.call($), L = 0; L < 6; ++L)
              T[L] = tt();
            if (typeof w == "number" || !w) {
              var j = w | 0 || 1;
              for (L = 0; L < 6; ++L)
                We(T[L], j, j);
            } else if (typeof w == "object")
              if (E)
                Je(T[0], w), Je(T[1], E), Je(T[2], v), Je(T[3], b), Je(T[4], g), Je(T[5], F);
              else if (Tt($, w), Se(c, w), "faces" in w) {
                var le = w.faces;
                for (d(
                  Array.isArray(le) && le.length === 6,
                  "cube faces must be a length 6 array"
                ), L = 0; L < 6; ++L)
                  d(
                    typeof le[L] == "object" && !!le[L],
                    "invalid input for cube map face"
                  ), H(T[L], c), Je(T[L], le[L]);
              } else
                for (L = 0; L < 6; ++L)
                  Je(T[L], w);
            else
              d.raise("invalid arguments to cube map");
            for (H(c, T[0]), d.optional(function() {
              _.npotTextureCube || d(yf(c.width) && yf(c.height), "your browser does not support non power or two texture dimensions");
            }), $.genMipmaps ? c.mipmask = (T[0].width << 1) - 1 : c.mipmask = T[0].mipmask, d.textureCube(c, $, T, _), c.internalformat = T[0].internalformat, C.width = T[0].width, C.height = T[0].height, Bt(c), L = 0; L < 6; ++L)
              vt(T[L], ro + L);
            for (Et($, Pa), at(), B.profile && (c.stats.size = uo(
              c.internalformat,
              c.type,
              C.width,
              C.height,
              $.genMipmaps,
              true
            )), C.format = te[c.internalformat], C.type = xe[c.type], C.mag = Z[$.magFilter], C.min = ge[$.minFilter], C.wrapS = me[$.wrapS], C.wrapT = me[$.wrapT], L = 0; L < 6; ++L)
              At(T[L]);
            return C;
          }
          function I(w, E, v, b, g) {
            d(!!E, "must specify image data"), d(typeof w == "number" && w === (w | 0) && w >= 0 && w < 6, "invalid face");
            var F = v | 0, L = b | 0, $ = g | 0, j = pe();
            return H(j, c), j.width = 0, j.height = 0, he(j, E), j.width = j.width || (c.width >> $) - F, j.height = j.height || (c.height >> $) - L, d(
              c.type === j.type && c.format === j.format && c.internalformat === j.internalformat,
              "incompatible format for texture.subimage"
            ), d(
              F >= 0 && L >= 0 && F + j.width <= c.width && L + j.height <= c.height,
              "texture.subimage write out of bounds"
            ), d(
              c.mipmask & 1 << $,
              "missing mipmap data"
            ), d(
              j.data || j.element || j.needsCopy,
              "missing image data"
            ), Bt(c), He(j, ro + w, F, L, $), at(), ye(j), C;
          }
          function A(w) {
            var E = w | 0;
            if (E !== c.width) {
              C.width = c.width = E, C.height = c.height = E, Bt(c);
              for (var v = 0; v < 6; ++v)
                for (var b = 0; c.mipmask >> b; ++b)
                  a.texImage2D(
                    ro + v,
                    b,
                    c.format,
                    E >> b,
                    E >> b,
                    0,
                    c.format,
                    c.type,
                    null
                  );
              return at(), B.profile && (c.stats.size = uo(
                c.internalformat,
                c.type,
                C.width,
                C.height,
                false,
                true
              )), C;
            }
          }
          return C(x, O, z, _e, Ke, p), C.subimage = I, C.resize = A, C._reglType = "textureCube", C._texture = c, B.profile && (C.stats = c.stats), C.destroy = function() {
            c.decRef();
          }, C;
        }
        function bt() {
          for (var x = 0; x < Gt; ++x)
            a.activeTexture(lr + x), a.bindTexture(_n, null), xt[x] = null;
          Jt(Ft).forEach(Fe), R.cubeCount = 0, R.textureCount = 0;
        }
        B.profile && (R.getTotalTextureSize = function() {
          var x = 0;
          return Object.keys(Ft).forEach(function(O) {
            x += Ft[O].stats.size;
          }), x;
        });
        function Tn() {
          for (var x = 0; x < Gt; ++x) {
            var O = xt[x];
            O && (O.bindCount = 0, O.unit = -1, xt[x] = null);
          }
          Jt(Ft).forEach(function(z) {
            z.texture = a.createTexture(), a.bindTexture(z.target, z.texture);
            for (var _e = 0; _e < 32; ++_e)
              if ((z.mipmask & 1 << _e) !== 0)
                if (z.target === _n)
                  a.texImage2D(
                    _n,
                    _e,
                    z.internalformat,
                    z.width >> _e,
                    z.height >> _e,
                    0,
                    z.internalformat,
                    z.type,
                    null
                  );
                else
                  for (var Ke = 0; Ke < 6; ++Ke)
                    a.texImage2D(
                      ro + Ke,
                      _e,
                      z.internalformat,
                      z.width >> _e,
                      z.height >> _e,
                      0,
                      z.internalformat,
                      z.type,
                      null
                    );
            Et(z.texInfo, z.target);
          });
        }
        function gi() {
          for (var x = 0; x < Gt; ++x) {
            var O = xt[x];
            O && (O.bindCount = 0, O.unit = -1, xt[x] = null), a.activeTexture(lr + x), a.bindTexture(_n, null), a.bindTexture(Pa, null);
          }
        }
        return {
          create2D: et,
          createCube: it,
          clear: bt,
          getTexture: function(x) {
            return null;
          },
          restore: Tn,
          refresh: gi
        };
      }
      var jn = 36161, co = 32854, Wf = 32855, Xf = 36194, jf = 33189, qf = 36168, Yf = 34041, Zf = 35907, Qf = 34836, Kf = 34842, Jf = 34843, dn = [];
      dn[co] = 2, dn[Wf] = 2, dn[Xf] = 2, dn[jf] = 2, dn[qf] = 1, dn[Yf] = 4, dn[Zf] = 4, dn[Qf] = 16, dn[Kf] = 8, dn[Jf] = 6;
      function el(a, h, _) {
        return dn[a] * h * _;
      }
      var od = function(a, h, _, M, W) {
        var R = {
          rgba4: co,
          rgb565: Xf,
          "rgb5 a1": Wf,
          depth: jf,
          stencil: qf,
          "depth stencil": Yf
        };
        h.ext_srgb && (R.srgba = Zf), h.ext_color_buffer_half_float && (R.rgba16f = Kf, R.rgb16f = Jf), h.webgl_color_buffer_float && (R.rgba32f = Qf);
        var B = [];
        Object.keys(R).forEach(function(J) {
          var ne = R[J];
          B[ne] = J;
        });
        var K = 0, Q = {};
        function re(J) {
          this.id = K++, this.refCount = 1, this.renderbuffer = J, this.format = co, this.width = 0, this.height = 0, W.profile && (this.stats = { size: 0 });
        }
        re.prototype.decRef = function() {
          --this.refCount <= 0 && ae(this);
        };
        function ae(J) {
          var ne = J.renderbuffer;
          d(ne, "must not double destroy renderbuffer"), a.bindRenderbuffer(jn, null), a.deleteRenderbuffer(ne), J.renderbuffer = null, J.refCount = 0, delete Q[J.id], M.renderbufferCount--;
        }
        function oe(J, ne) {
          var k = new re(a.createRenderbuffer());
          Q[k.id] = k, M.renderbufferCount++;
          function G(xe, Z) {
            var ge = 0, me = 0, De = co;
            if (typeof xe == "object" && xe) {
              var X = xe;
              if ("shape" in X) {
                var H = X.shape;
                d(
                  Array.isArray(H) && H.length >= 2,
                  "invalid renderbuffer shape"
                ), ge = H[0] | 0, me = H[1] | 0;
              } else
                "radius" in X && (ge = me = X.radius | 0), "width" in X && (ge = X.width | 0), "height" in X && (me = X.height | 0);
              "format" in X && (d.parameter(
                X.format,
                R,
                "invalid renderbuffer format"
              ), De = R[X.format]);
            } else typeof xe == "number" ? (ge = xe | 0, typeof Z == "number" ? me = Z | 0 : me = ge) : xe ? d.raise("invalid arguments to renderbuffer constructor") : ge = me = 1;
            if (d(
              ge > 0 && me > 0 && ge <= _.maxRenderbufferSize && me <= _.maxRenderbufferSize,
              "invalid renderbuffer size"
            ), !(ge === k.width && me === k.height && De === k.format))
              return G.width = k.width = ge, G.height = k.height = me, k.format = De, a.bindRenderbuffer(jn, k.renderbuffer), a.renderbufferStorage(jn, De, ge, me), d(
                a.getError() === 0,
                "invalid render buffer format"
              ), W.profile && (k.stats.size = el(k.format, k.width, k.height)), G.format = B[k.format], G;
          }
          function te(xe, Z) {
            var ge = xe | 0, me = Z | 0 || ge;
            return ge === k.width && me === k.height || (d(
              ge > 0 && me > 0 && ge <= _.maxRenderbufferSize && me <= _.maxRenderbufferSize,
              "invalid renderbuffer size"
            ), G.width = k.width = ge, G.height = k.height = me, a.bindRenderbuffer(jn, k.renderbuffer), a.renderbufferStorage(jn, k.format, ge, me), d(
              a.getError() === 0,
              "invalid render buffer format"
            ), W.profile && (k.stats.size = el(
              k.format,
              k.width,
              k.height
            ))), G;
          }
          return G(J, ne), G.resize = te, G._reglType = "renderbuffer", G._renderbuffer = k, W.profile && (G.stats = k.stats), G.destroy = function() {
            k.decRef();
          }, G;
        }
        W.profile && (M.getTotalRenderbufferSize = function() {
          var J = 0;
          return Object.keys(Q).forEach(function(ne) {
            J += Q[ne].stats.size;
          }), J;
        });
        function ue() {
          Jt(Q).forEach(function(J) {
            J.renderbuffer = a.createRenderbuffer(), a.bindRenderbuffer(jn, J.renderbuffer), a.renderbufferStorage(jn, J.format, J.width, J.height);
          }), a.bindRenderbuffer(jn, null);
        }
        return {
          create: oe,
          clear: function() {
            Jt(Q).forEach(ae);
          },
          restore: ue
        };
      }, Ln = 36160, Wa = 36161, ci = 3553, ho = 34069, tl = 36064, nl = 36096, il = 36128, rl = 33306, ol = 36053, ad = 36054, sd = 36055, fd = 36057, ld = 36061, ud = 36193, cd = 5121, hd = 5126, al = 6407, sl = 6408, dd = 6402, md = [
        al,
        sl
      ], Xa = [];
      Xa[sl] = 4, Xa[al] = 3;
      var mo = [];
      mo[cd] = 1, mo[hd] = 4, mo[ud] = 2;
      var pd = 32854, vd = 32855, gd = 36194, yd = 33189, xd = 36168, fl = 34041, bd = 35907, _d = 34836, Sd = 34842, Td = 34843, wd = [
        pd,
        vd,
        gd,
        bd,
        Sd,
        Td,
        _d
      ], Bi = {};
      Bi[ol] = "complete", Bi[ad] = "incomplete attachment", Bi[fd] = "incomplete dimensions", Bi[sd] = "incomplete, missing attachment", Bi[ld] = "unsupported";
      function Ad(a, h, _, M, W, R) {
        var B = {
          cur: null,
          next: null,
          dirty: false,
          setFBO: null
        }, K = ["rgba"], Q = ["rgba4", "rgb565", "rgb5 a1"];
        h.ext_srgb && Q.push("srgba"), h.ext_color_buffer_half_float && Q.push("rgba16f", "rgb16f"), h.webgl_color_buffer_float && Q.push("rgba32f");
        var re = ["uint8"];
        h.oes_texture_half_float && re.push("half float", "float16"), h.oes_texture_float && re.push("float", "float32");
        function ae(ee, he, de) {
          this.target = ee, this.texture = he, this.renderbuffer = de;
          var He = 0, Ue = 0;
          he ? (He = he.width, Ue = he.height) : de && (He = de.width, Ue = de.height), this.width = He, this.height = Ue;
        }
        function oe(ee) {
          ee && (ee.texture && ee.texture._texture.decRef(), ee.renderbuffer && ee.renderbuffer._renderbuffer.decRef());
        }
        function ue(ee, he, de) {
          if (ee)
            if (ee.texture) {
              var He = ee.texture._texture, Ue = Math.max(1, He.width), pe = Math.max(1, He.height);
              d(
                Ue === he && pe === de,
                "inconsistent width/height for supplied texture"
              ), He.refCount += 1;
            } else {
              var ye = ee.renderbuffer._renderbuffer;
              d(
                ye.width === he && ye.height === de,
                "inconsistent width/height for renderbuffer"
              ), ye.refCount += 1;
            }
        }
        function J(ee, he) {
          he && (he.texture ? a.framebufferTexture2D(
            Ln,
            ee,
            he.target,
            he.texture._texture.texture,
            0
          ) : a.framebufferRenderbuffer(
            Ln,
            ee,
            Wa,
            he.renderbuffer._renderbuffer.renderbuffer
          ));
        }
        function ne(ee) {
          var he = ci, de = null, He = null, Ue = ee;
          typeof ee == "object" && (Ue = ee.data, "target" in ee && (he = ee.target | 0)), d.type(Ue, "function", "invalid attachment data");
          var pe = Ue._reglType;
          return pe === "texture2d" ? (de = Ue, d(he === ci)) : pe === "textureCube" ? (de = Ue, d(
            he >= ho && he < ho + 6,
            "invalid cube map target"
          )) : pe === "renderbuffer" ? (He = Ue, he = Wa) : d.raise("invalid regl object for attachment"), new ae(he, de, He);
        }
        function k(ee, he, de, He, Ue) {
          if (de) {
            var pe = M.create2D({
              width: ee,
              height: he,
              format: He,
              type: Ue
            });
            return pe._texture.refCount = 0, new ae(ci, pe, null);
          } else {
            var ye = W.create({
              width: ee,
              height: he,
              format: He
            });
            return ye._renderbuffer.refCount = 0, new ae(Wa, null, ye);
          }
        }
        function G(ee) {
          return ee && (ee.texture || ee.renderbuffer);
        }
        function te(ee, he, de) {
          ee && (ee.texture ? ee.texture.resize(he, de) : ee.renderbuffer && ee.renderbuffer.resize(he, de), ee.width = he, ee.height = de);
        }
        var xe = 0, Z = {};
        function ge() {
          this.id = xe++, Z[this.id] = this, this.framebuffer = a.createFramebuffer(), this.width = 0, this.height = 0, this.colorAttachments = [], this.depthAttachment = null, this.stencilAttachment = null, this.depthStencilAttachment = null;
        }
        function me(ee) {
          ee.colorAttachments.forEach(oe), oe(ee.depthAttachment), oe(ee.stencilAttachment), oe(ee.depthStencilAttachment);
        }
        function De(ee) {
          var he = ee.framebuffer;
          d(he, "must not double destroy framebuffer"), a.deleteFramebuffer(he), ee.framebuffer = null, R.framebufferCount--, delete Z[ee.id];
        }
        function X(ee) {
          var he;
          a.bindFramebuffer(Ln, ee.framebuffer);
          var de = ee.colorAttachments;
          for (he = 0; he < de.length; ++he)
            J(tl + he, de[he]);
          for (he = de.length; he < _.maxColorAttachments; ++he)
            a.framebufferTexture2D(
              Ln,
              tl + he,
              ci,
              null,
              0
            );
          a.framebufferTexture2D(
            Ln,
            rl,
            ci,
            null,
            0
          ), a.framebufferTexture2D(
            Ln,
            nl,
            ci,
            null,
            0
          ), a.framebufferTexture2D(
            Ln,
            il,
            ci,
            null,
            0
          ), J(nl, ee.depthAttachment), J(il, ee.stencilAttachment), J(rl, ee.depthStencilAttachment);
          var He = a.checkFramebufferStatus(Ln);
          !a.isContextLost() && He !== ol && d.raise("framebuffer configuration not supported, status = " + Bi[He]), a.bindFramebuffer(Ln, B.next ? B.next.framebuffer : null), B.cur = B.next, a.getError();
        }
        function H(ee, he) {
          var de = new ge();
          R.framebufferCount++;
          function He(pe, ye) {
            var Re;
            d(
              B.next !== de,
              "can not update framebuffer which is currently in use"
            );
            var We = 0, Je = 0, vt = true, yt = true, tt = null, At = true, ht = "rgba", Tt = "uint8", Et = 1, Ct = null, Ft = null, Gt = null, xt = false;
            if (typeof pe == "number")
              We = pe | 0, Je = ye | 0 || We;
            else if (!pe)
              We = Je = 1;
            else {
              d.type(pe, "object", "invalid arguments for framebuffer");
              var Ye = pe;
              if ("shape" in Ye) {
                var Bt = Ye.shape;
                d(
                  Array.isArray(Bt) && Bt.length >= 2,
                  "invalid shape for framebuffer"
                ), We = Bt[0], Je = Bt[1];
              } else
                "radius" in Ye && (We = Je = Ye.radius), "width" in Ye && (We = Ye.width), "height" in Ye && (Je = Ye.height);
              ("color" in Ye || "colors" in Ye) && (tt = Ye.color || Ye.colors, Array.isArray(tt) && d(
                tt.length === 1 || h.webgl_draw_buffers,
                "multiple render targets not supported"
              )), tt || ("colorCount" in Ye && (Et = Ye.colorCount | 0, d(Et > 0, "invalid color buffer count")), "colorTexture" in Ye && (At = !!Ye.colorTexture, ht = "rgba4"), "colorType" in Ye && (Tt = Ye.colorType, At ? (d(
                h.oes_texture_float || !(Tt === "float" || Tt === "float32"),
                "you must enable OES_texture_float in order to use floating point framebuffer objects"
              ), d(
                h.oes_texture_half_float || !(Tt === "half float" || Tt === "float16"),
                "you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects"
              )) : Tt === "half float" || Tt === "float16" ? (d(
                h.ext_color_buffer_half_float,
                "you must enable EXT_color_buffer_half_float to use 16-bit render buffers"
              ), ht = "rgba16f") : (Tt === "float" || Tt === "float32") && (d(
                h.webgl_color_buffer_float,
                "you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"
              ), ht = "rgba32f"), d.oneOf(Tt, re, "invalid color type")), "colorFormat" in Ye && (ht = Ye.colorFormat, K.indexOf(ht) >= 0 ? At = true : Q.indexOf(ht) >= 0 ? At = false : d.optional(function() {
                At ? d.oneOf(
                  Ye.colorFormat,
                  K,
                  "invalid color format for texture"
                ) : d.oneOf(
                  Ye.colorFormat,
                  Q,
                  "invalid color format for renderbuffer"
                );
              }))), ("depthTexture" in Ye || "depthStencilTexture" in Ye) && (xt = !!(Ye.depthTexture || Ye.depthStencilTexture), d(
                !xt || h.webgl_depth_texture,
                "webgl_depth_texture extension not supported"
              )), "depth" in Ye && (typeof Ye.depth == "boolean" ? vt = Ye.depth : (Ct = Ye.depth, yt = false)), "stencil" in Ye && (typeof Ye.stencil == "boolean" ? yt = Ye.stencil : (Ft = Ye.stencil, vt = false)), "depthStencil" in Ye && (typeof Ye.depthStencil == "boolean" ? vt = yt = Ye.depthStencil : (Gt = Ye.depthStencil, vt = false, yt = false));
            }
            var at = null, Fe = null, et = null, it = null;
            if (Array.isArray(tt))
              at = tt.map(ne);
            else if (tt)
              at = [ne(tt)];
            else
              for (at = new Array(Et), Re = 0; Re < Et; ++Re)
                at[Re] = k(
                  We,
                  Je,
                  At,
                  ht,
                  Tt
                );
            d(
              h.webgl_draw_buffers || at.length <= 1,
              "you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."
            ), d(
              at.length <= _.maxColorAttachments,
              "too many color attachments, not supported"
            ), We = We || at[0].width, Je = Je || at[0].height, Ct ? Fe = ne(Ct) : vt && !yt && (Fe = k(
              We,
              Je,
              xt,
              "depth",
              "uint32"
            )), Ft ? et = ne(Ft) : yt && !vt && (et = k(
              We,
              Je,
              false,
              "stencil",
              "uint8"
            )), Gt ? it = ne(Gt) : !Ct && !Ft && yt && vt && (it = k(
              We,
              Je,
              xt,
              "depth stencil",
              "depth stencil"
            )), d(
              !!Ct + !!Ft + !!Gt <= 1,
              "invalid framebuffer configuration, can specify exactly one depth/stencil attachment"
            );
            var bt = null;
            for (Re = 0; Re < at.length; ++Re)
              if (ue(at[Re], We, Je), d(
                !at[Re] || at[Re].texture && md.indexOf(at[Re].texture._texture.format) >= 0 || at[Re].renderbuffer && wd.indexOf(at[Re].renderbuffer._renderbuffer.format) >= 0,
                "framebuffer color attachment " + Re + " is invalid"
              ), at[Re] && at[Re].texture) {
                var Tn = Xa[at[Re].texture._texture.format] * mo[at[Re].texture._texture.type];
                bt === null ? bt = Tn : d(
                  bt === Tn,
                  "all color attachments much have the same number of bits per pixel."
                );
              }
            return ue(Fe, We, Je), d(
              !Fe || Fe.texture && Fe.texture._texture.format === dd || Fe.renderbuffer && Fe.renderbuffer._renderbuffer.format === yd,
              "invalid depth attachment for framebuffer object"
            ), ue(et, We, Je), d(
              !et || et.renderbuffer && et.renderbuffer._renderbuffer.format === xd,
              "invalid stencil attachment for framebuffer object"
            ), ue(it, We, Je), d(
              !it || it.texture && it.texture._texture.format === fl || it.renderbuffer && it.renderbuffer._renderbuffer.format === fl,
              "invalid depth-stencil attachment for framebuffer object"
            ), me(de), de.width = We, de.height = Je, de.colorAttachments = at, de.depthAttachment = Fe, de.stencilAttachment = et, de.depthStencilAttachment = it, He.color = at.map(G), He.depth = G(Fe), He.stencil = G(et), He.depthStencil = G(it), He.width = de.width, He.height = de.height, X(de), He;
          }
          function Ue(pe, ye) {
            d(
              B.next !== de,
              "can not resize a framebuffer which is currently in use"
            );
            var Re = Math.max(pe | 0, 1), We = Math.max(ye | 0 || Re, 1);
            if (Re === de.width && We === de.height)
              return He;
            for (var Je = de.colorAttachments, vt = 0; vt < Je.length; ++vt)
              te(Je[vt], Re, We);
            return te(de.depthAttachment, Re, We), te(de.stencilAttachment, Re, We), te(de.depthStencilAttachment, Re, We), de.width = He.width = Re, de.height = He.height = We, X(de), He;
          }
          return He(ee, he), i(He, {
            resize: Ue,
            _reglType: "framebuffer",
            _framebuffer: de,
            destroy: function() {
              De(de), me(de);
            },
            use: function(pe) {
              B.setFBO({
                framebuffer: He
              }, pe);
            }
          });
        }
        function Se(ee) {
          var he = Array(6);
          function de(Ue) {
            var pe;
            d(
              he.indexOf(B.next) < 0,
              "can not update framebuffer which is currently in use"
            );
            var ye = {
              color: null
            }, Re = 0, We = null, Je = "rgba", vt = "uint8", yt = 1;
            if (typeof Ue == "number")
              Re = Ue | 0;
            else if (!Ue)
              Re = 1;
            else {
              d.type(Ue, "object", "invalid arguments for framebuffer");
              var tt = Ue;
              if ("shape" in tt) {
                var At = tt.shape;
                d(
                  Array.isArray(At) && At.length >= 2,
                  "invalid shape for framebuffer"
                ), d(
                  At[0] === At[1],
                  "cube framebuffer must be square"
                ), Re = At[0];
              } else
                "radius" in tt && (Re = tt.radius | 0), "width" in tt ? (Re = tt.width | 0, "height" in tt && d(tt.height === Re, "must be square")) : "height" in tt && (Re = tt.height | 0);
              ("color" in tt || "colors" in tt) && (We = tt.color || tt.colors, Array.isArray(We) && d(
                We.length === 1 || h.webgl_draw_buffers,
                "multiple render targets not supported"
              )), We || ("colorCount" in tt && (yt = tt.colorCount | 0, d(yt > 0, "invalid color buffer count")), "colorType" in tt && (d.oneOf(
                tt.colorType,
                re,
                "invalid color type"
              ), vt = tt.colorType), "colorFormat" in tt && (Je = tt.colorFormat, d.oneOf(
                tt.colorFormat,
                K,
                "invalid color format for texture"
              ))), "depth" in tt && (ye.depth = tt.depth), "stencil" in tt && (ye.stencil = tt.stencil), "depthStencil" in tt && (ye.depthStencil = tt.depthStencil);
            }
            var ht;
            if (We)
              if (Array.isArray(We))
                for (ht = [], pe = 0; pe < We.length; ++pe)
                  ht[pe] = We[pe];
              else
                ht = [We];
            else {
              ht = Array(yt);
              var Tt = {
                radius: Re,
                format: Je,
                type: vt
              };
              for (pe = 0; pe < yt; ++pe)
                ht[pe] = M.createCube(Tt);
            }
            for (ye.color = Array(ht.length), pe = 0; pe < ht.length; ++pe) {
              var Et = ht[pe];
              d(
                typeof Et == "function" && Et._reglType === "textureCube",
                "invalid cube map"
              ), Re = Re || Et.width, d(
                Et.width === Re && Et.height === Re,
                "invalid cube map shape"
              ), ye.color[pe] = {
                target: ho,
                data: ht[pe]
              };
            }
            for (pe = 0; pe < 6; ++pe) {
              for (var Ct = 0; Ct < ht.length; ++Ct)
                ye.color[Ct].target = ho + pe;
              pe > 0 && (ye.depth = he[0].depth, ye.stencil = he[0].stencil, ye.depthStencil = he[0].depthStencil), he[pe] ? he[pe](ye) : he[pe] = H(ye);
            }
            return i(de, {
              width: Re,
              height: Re,
              color: ht
            });
          }
          function He(Ue) {
            var pe, ye = Ue | 0;
            if (d(
              ye > 0 && ye <= _.maxCubeMapSize,
              "invalid radius for cube fbo"
            ), ye === de.width)
              return de;
            var Re = de.color;
            for (pe = 0; pe < Re.length; ++pe)
              Re[pe].resize(ye);
            for (pe = 0; pe < 6; ++pe)
              he[pe].resize(ye);
            return de.width = de.height = ye, de;
          }
          return de(ee), i(de, {
            faces: he,
            resize: He,
            _reglType: "framebufferCube",
            destroy: function() {
              he.forEach(function(Ue) {
                Ue.destroy();
              });
            }
          });
        }
        function ce() {
          B.cur = null, B.next = null, B.dirty = true, Jt(Z).forEach(function(ee) {
            ee.framebuffer = a.createFramebuffer(), X(ee);
          });
        }
        return i(B, {
          getFramebuffer: function(ee) {
            if (typeof ee == "function" && ee._reglType === "framebuffer") {
              var he = ee._framebuffer;
              if (he instanceof ge)
                return he;
            }
            return null;
          },
          create: H,
          createCube: Se,
          clear: function() {
            Jt(Z).forEach(De);
          },
          restore: ce
        });
      }
      var Ed = 5126, ll = 34962, po = 34963, ul = [
        "attributes",
        "elements",
        "offset",
        "count",
        "primitive",
        "instances"
      ];
      function ja() {
        this.state = 0, this.x = 0, this.y = 0, this.z = 0, this.w = 0, this.buffer = null, this.size = 0, this.normalized = false, this.type = Ed, this.offset = 0, this.stride = 0, this.divisor = 0;
      }
      function Cd(a, h, _, M, W, R, B) {
        for (var K = _.maxAttributes, Q = new Array(K), re = 0; re < K; ++re)
          Q[re] = new ja();
        var ae = 0, oe = {}, ue = {
          Record: ja,
          scope: {},
          state: Q,
          currentVAO: null,
          targetVAO: null,
          restore: ne() ? me : function() {
          },
          createVAO: De,
          getVAO: G,
          destroyBuffer: J,
          setVAO: ne() ? te : xe,
          clear: ne() ? Z : function() {
          }
        };
        function J(X) {
          for (var H = 0; H < Q.length; ++H) {
            var Se = Q[H];
            Se.buffer === X && (a.disableVertexAttribArray(H), Se.buffer = null);
          }
        }
        function ne() {
          return h.oes_vertex_array_object;
        }
        function k() {
          return h.angle_instanced_arrays;
        }
        function G(X) {
          return typeof X == "function" && X._vao ? X._vao : null;
        }
        function te(X) {
          if (X !== ue.currentVAO) {
            var H = ne();
            X ? H.bindVertexArrayOES(X.vao) : H.bindVertexArrayOES(null), ue.currentVAO = X;
          }
        }
        function xe(X) {
          if (X !== ue.currentVAO) {
            if (X)
              X.bindAttrs();
            else {
              for (var H = k(), Se = 0; Se < Q.length; ++Se) {
                var ce = Q[Se];
                ce.buffer ? (a.enableVertexAttribArray(Se), ce.buffer.bind(), a.vertexAttribPointer(Se, ce.size, ce.type, ce.normalized, ce.stride, ce.offfset), H && ce.divisor && H.vertexAttribDivisorANGLE(Se, ce.divisor)) : (a.disableVertexAttribArray(Se), a.vertexAttrib4f(Se, ce.x, ce.y, ce.z, ce.w));
              }
              B.elements ? a.bindBuffer(po, B.elements.buffer.buffer) : a.bindBuffer(po, null);
            }
            ue.currentVAO = X;
          }
        }
        function Z() {
          Jt(oe).forEach(function(X) {
            X.destroy();
          });
        }
        function ge() {
          this.id = ++ae, this.attributes = [], this.elements = null, this.ownsElements = false, this.count = 0, this.offset = 0, this.instances = -1, this.primitive = 4;
          var X = ne();
          X ? this.vao = X.createVertexArrayOES() : this.vao = null, oe[this.id] = this, this.buffers = [];
        }
        ge.prototype.bindAttrs = function() {
          for (var X = k(), H = this.attributes, Se = 0; Se < H.length; ++Se) {
            var ce = H[Se];
            ce.buffer ? (a.enableVertexAttribArray(Se), a.bindBuffer(ll, ce.buffer.buffer), a.vertexAttribPointer(Se, ce.size, ce.type, ce.normalized, ce.stride, ce.offset), X && ce.divisor && X.vertexAttribDivisorANGLE(Se, ce.divisor)) : (a.disableVertexAttribArray(Se), a.vertexAttrib4f(Se, ce.x, ce.y, ce.z, ce.w));
          }
          for (var ee = H.length; ee < K; ++ee)
            a.disableVertexAttribArray(ee);
          var he = R.getElements(this.elements);
          he ? a.bindBuffer(po, he.buffer.buffer) : a.bindBuffer(po, null);
        }, ge.prototype.refresh = function() {
          var X = ne();
          X && (X.bindVertexArrayOES(this.vao), this.bindAttrs(), ue.currentVAO = null, X.bindVertexArrayOES(null));
        }, ge.prototype.destroy = function() {
          if (this.vao) {
            var X = ne();
            this === ue.currentVAO && (ue.currentVAO = null, X.bindVertexArrayOES(null)), X.deleteVertexArrayOES(this.vao), this.vao = null;
          }
          this.ownsElements && (this.elements.destroy(), this.elements = null, this.ownsElements = false), oe[this.id] && (delete oe[this.id], M.vaoCount -= 1);
        };
        function me() {
          var X = ne();
          X && Jt(oe).forEach(function(H) {
            H.refresh();
          });
        }
        function De(X) {
          var H = new ge();
          M.vaoCount += 1;
          function Se(ce) {
            var ee;
            if (Array.isArray(ce))
              ee = ce, H.elements && H.ownsElements && H.elements.destroy(), H.elements = null, H.ownsElements = false, H.offset = 0, H.count = 0, H.instances = -1, H.primitive = 4;
            else {
              if (d(typeof ce == "object", "invalid arguments for create vao"), d("attributes" in ce, "must specify attributes for vao"), ce.elements) {
                var he = ce.elements;
                H.ownsElements ? typeof he == "function" && he._reglType === "elements" ? (H.elements.destroy(), H.ownsElements = false) : (H.elements(he), H.ownsElements = false) : R.getElements(ce.elements) ? (H.elements = ce.elements, H.ownsElements = false) : (H.elements = R.create(ce.elements), H.ownsElements = true);
              } else
                H.elements = null, H.ownsElements = false;
              ee = ce.attributes, H.offset = 0, H.count = -1, H.instances = -1, H.primitive = 4, H.elements && (H.count = H.elements._elements.vertCount, H.primitive = H.elements._elements.primType), "offset" in ce && (H.offset = ce.offset | 0), "count" in ce && (H.count = ce.count | 0), "instances" in ce && (H.instances = ce.instances | 0), "primitive" in ce && (d(ce.primitive in Xn, "bad primitive type: " + ce.primitive), H.primitive = Xn[ce.primitive]), d.optional(() => {
                for (var vt = Object.keys(ce), yt = 0; yt < vt.length; ++yt)
                  d(ul.indexOf(vt[yt]) >= 0, 'invalid option for vao: "' + vt[yt] + '" valid options are ' + ul);
              }), d(Array.isArray(ee), "attributes must be an array");
            }
            d(ee.length < K, "too many attributes"), d(ee.length > 0, "must specify at least one attribute");
            var de = {}, He = H.attributes;
            He.length = ee.length;
            for (var Ue = 0; Ue < ee.length; ++Ue) {
              var pe = ee[Ue], ye = He[Ue] = new ja(), Re = pe.data || pe;
              if (Array.isArray(Re) || n(Re) || hn(Re)) {
                var We;
                H.buffers[Ue] && (We = H.buffers[Ue], n(Re) && We._buffer.byteLength >= Re.byteLength ? We.subdata(Re) : (We.destroy(), H.buffers[Ue] = null)), H.buffers[Ue] || (We = H.buffers[Ue] = W.create(pe, ll, false, true)), ye.buffer = W.getBuffer(We), ye.size = ye.buffer.dimension | 0, ye.normalized = false, ye.type = ye.buffer.dtype, ye.offset = 0, ye.stride = 0, ye.divisor = 0, ye.state = 1, de[Ue] = 1;
              } else W.getBuffer(pe) ? (ye.buffer = W.getBuffer(pe), ye.size = ye.buffer.dimension | 0, ye.normalized = false, ye.type = ye.buffer.dtype, ye.offset = 0, ye.stride = 0, ye.divisor = 0, ye.state = 1) : W.getBuffer(pe.buffer) ? (ye.buffer = W.getBuffer(pe.buffer), ye.size = (+pe.size || ye.buffer.dimension) | 0, ye.normalized = !!pe.normalized || false, "type" in pe ? (d.parameter(pe.type, si, "invalid buffer type"), ye.type = si[pe.type]) : ye.type = ye.buffer.dtype, ye.offset = (pe.offset || 0) | 0, ye.stride = (pe.stride || 0) | 0, ye.divisor = (pe.divisor || 0) | 0, ye.state = 1, d(ye.size >= 1 && ye.size <= 4, "size must be between 1 and 4"), d(ye.offset >= 0, "invalid offset"), d(ye.stride >= 0 && ye.stride <= 255, "stride must be between 0 and 255"), d(ye.divisor >= 0, "divisor must be positive"), d(!ye.divisor || !!h.angle_instanced_arrays, "ANGLE_instanced_arrays must be enabled to use divisor")) : "x" in pe ? (d(Ue > 0, "first attribute must not be a constant"), ye.x = +pe.x || 0, ye.y = +pe.y || 0, ye.z = +pe.z || 0, ye.w = +pe.w || 0, ye.state = 2) : d(false, "invalid attribute spec for location " + Ue);
            }
            for (var Je = 0; Je < H.buffers.length; ++Je)
              !de[Je] && H.buffers[Je] && (H.buffers[Je].destroy(), H.buffers[Je] = null);
            return H.refresh(), Se;
          }
          return Se.destroy = function() {
            for (var ce = 0; ce < H.buffers.length; ++ce)
              H.buffers[ce] && H.buffers[ce].destroy();
            H.buffers.length = 0, H.ownsElements && (H.elements.destroy(), H.elements = null, H.ownsElements = false), H.destroy();
          }, Se._vao = H, Se._reglType = "vao", Se(X);
        }
        return ue;
      }
      var cl = 35632, Pd = 35633, kd = 35718, Id = 35721;
      function Ld(a, h, _, M) {
        var W = {}, R = {};
        function B(k, G, te, xe) {
          this.name = k, this.id = G, this.location = te, this.info = xe;
        }
        function K(k, G) {
          for (var te = 0; te < k.length; ++te)
            if (k[te].id === G.id) {
              k[te].location = G.location;
              return;
            }
          k.push(G);
        }
        function Q(k, G, te) {
          var xe = k === cl ? W : R, Z = xe[G];
          if (!Z) {
            var ge = h.str(G);
            Z = a.createShader(k), a.shaderSource(Z, ge), a.compileShader(Z), d.shaderError(a, Z, ge, k, te), xe[G] = Z;
          }
          return Z;
        }
        var re = {}, ae = [], oe = 0;
        function ue(k, G) {
          this.id = oe++, this.fragId = k, this.vertId = G, this.program = null, this.uniforms = [], this.attributes = [], this.refCount = 1, M.profile && (this.stats = {
            uniformsCount: 0,
            attributesCount: 0
          });
        }
        function J(k, G, te) {
          var xe, Z, ge = Q(cl, k.fragId), me = Q(Pd, k.vertId), De = k.program = a.createProgram();
          if (a.attachShader(De, ge), a.attachShader(De, me), te)
            for (xe = 0; xe < te.length; ++xe) {
              var X = te[xe];
              a.bindAttribLocation(De, X[0], X[1]);
            }
          a.linkProgram(De), d.linkError(
            a,
            De,
            h.str(k.fragId),
            h.str(k.vertId),
            G
          );
          var H = a.getProgramParameter(De, kd);
          M.profile && (k.stats.uniformsCount = H);
          var Se = k.uniforms;
          for (xe = 0; xe < H; ++xe)
            if (Z = a.getActiveUniform(De, xe), Z) {
              if (Z.size > 1)
                for (var ce = 0; ce < Z.size; ++ce) {
                  var ee = Z.name.replace("[0]", "[" + ce + "]");
                  K(Se, new B(
                    ee,
                    h.id(ee),
                    a.getUniformLocation(De, ee),
                    Z
                  ));
                }
              var he = Z.name;
              Z.size > 1 && (he = he.replace("[0]", "")), K(Se, new B(
                he,
                h.id(he),
                a.getUniformLocation(De, he),
                Z
              ));
            }
          var de = a.getProgramParameter(De, Id);
          M.profile && (k.stats.attributesCount = de);
          var He = k.attributes;
          for (xe = 0; xe < de; ++xe)
            Z = a.getActiveAttrib(De, xe), Z && K(He, new B(
              Z.name,
              h.id(Z.name),
              a.getAttribLocation(De, Z.name),
              Z
            ));
        }
        M.profile && (_.getMaxUniformsCount = function() {
          var k = 0;
          return ae.forEach(function(G) {
            G.stats.uniformsCount > k && (k = G.stats.uniformsCount);
          }), k;
        }, _.getMaxAttributesCount = function() {
          var k = 0;
          return ae.forEach(function(G) {
            G.stats.attributesCount > k && (k = G.stats.attributesCount);
          }), k;
        });
        function ne() {
          W = {}, R = {};
          for (var k = 0; k < ae.length; ++k)
            J(ae[k], null, ae[k].attributes.map(function(G) {
              return [G.location, G.name];
            }));
        }
        return {
          clear: function() {
            var k = a.deleteShader.bind(a);
            Jt(W).forEach(k), W = {}, Jt(R).forEach(k), R = {}, ae.forEach(function(G) {
              a.deleteProgram(G.program);
            }), ae.length = 0, re = {}, _.shaderCount = 0;
          },
          program: function(k, G, te, xe) {
            d.command(k >= 0, "missing vertex shader", te), d.command(G >= 0, "missing fragment shader", te);
            var Z = re[G];
            Z || (Z = re[G] = {});
            var ge = Z[k];
            if (ge && (ge.refCount++, !xe))
              return ge;
            var me = new ue(G, k);
            return _.shaderCount++, J(me, te, xe), ge || (Z[k] = me), ae.push(me), i(me, {
              destroy: function() {
                if (me.refCount--, me.refCount <= 0) {
                  a.deleteProgram(me.program);
                  var De = ae.indexOf(me);
                  ae.splice(De, 1), _.shaderCount--;
                }
                Z[me.vertId].refCount <= 0 && (a.deleteShader(R[me.vertId]), delete R[me.vertId], delete re[me.fragId][me.vertId]), Object.keys(re[me.fragId]).length || (a.deleteShader(W[me.fragId]), delete W[me.fragId], delete re[me.fragId]);
              }
            });
          },
          restore: ne,
          shader: Q,
          frag: -1,
          vert: -1
        };
      }
      var Dd = 6408, ur = 5121, Fd = 3333, vo = 5126;
      function zd(a, h, _, M, W, R, B) {
        function K(ae) {
          var oe;
          h.next === null ? (d(
            W.preserveDrawingBuffer,
            'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'
          ), oe = ur) : (d(
            h.next.colorAttachments[0].texture !== null,
            "You cannot read from a renderbuffer"
          ), oe = h.next.colorAttachments[0].texture._texture.type, d.optional(function() {
            R.oes_texture_float ? (d(
              oe === ur || oe === vo,
              "Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"
            ), oe === vo && d(B.readFloat, "Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float")) : d(
              oe === ur,
              "Reading from a framebuffer is only allowed for the type 'uint8'"
            );
          }));
          var ue = 0, J = 0, ne = M.framebufferWidth, k = M.framebufferHeight, G = null;
          n(ae) ? G = ae : ae && (d.type(ae, "object", "invalid arguments to regl.read()"), ue = ae.x | 0, J = ae.y | 0, d(
            ue >= 0 && ue < M.framebufferWidth,
            "invalid x offset for regl.read"
          ), d(
            J >= 0 && J < M.framebufferHeight,
            "invalid y offset for regl.read"
          ), ne = (ae.width || M.framebufferWidth - ue) | 0, k = (ae.height || M.framebufferHeight - J) | 0, G = ae.data || null), G && (oe === ur ? d(
            G instanceof Uint8Array,
            "buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'"
          ) : oe === vo && d(
            G instanceof Float32Array,
            "buffer must be 'Float32Array' when reading from a framebuffer of type 'float'"
          )), d(
            ne > 0 && ne + ue <= M.framebufferWidth,
            "invalid width for read pixels"
          ), d(
            k > 0 && k + J <= M.framebufferHeight,
            "invalid height for read pixels"
          ), _();
          var te = ne * k * 4;
          return G || (oe === ur ? G = new Uint8Array(te) : oe === vo && (G = G || new Float32Array(te))), d.isTypedArray(G, "data buffer for regl.read() must be a typedarray"), d(G.byteLength >= te, "data buffer for regl.read() too small"), a.pixelStorei(Fd, 4), a.readPixels(
            ue,
            J,
            ne,
            k,
            Dd,
            oe,
            G
          ), G;
        }
        function Q(ae) {
          var oe;
          return h.setFBO({
            framebuffer: ae.framebuffer
          }, function() {
            oe = K(ae);
          }), oe;
        }
        function re(ae) {
          return !ae || !("framebuffer" in ae) ? K(ae) : Q(ae);
        }
        return re;
      }
      function Ui(a) {
        return Array.prototype.slice.call(a);
      }
      function Vi(a) {
        return Ui(a).join("");
      }
      function Rd() {
        var a = 0, h = [], _ = [];
        function M(oe) {
          for (var ue = 0; ue < _.length; ++ue)
            if (_[ue] === oe)
              return h[ue];
          var J = "g" + a++;
          return h.push(J), _.push(oe), J;
        }
        function W() {
          var oe = [];
          function ue() {
            oe.push.apply(oe, Ui(arguments));
          }
          var J = [];
          function ne() {
            var k = "v" + a++;
            return J.push(k), arguments.length > 0 && (oe.push(k, "="), oe.push.apply(oe, Ui(arguments)), oe.push(";")), k;
          }
          return i(ue, {
            def: ne,
            toString: function() {
              return Vi([
                J.length > 0 ? "var " + J.join(",") + ";" : "",
                Vi(oe)
              ]);
            }
          });
        }
        function R() {
          var oe = W(), ue = W(), J = oe.toString, ne = ue.toString;
          function k(G, te) {
            ue(G, te, "=", oe.def(G, te), ";");
          }
          return i(function() {
            oe.apply(oe, Ui(arguments));
          }, {
            def: oe.def,
            entry: oe,
            exit: ue,
            save: k,
            set: function(G, te, xe) {
              k(G, te), oe(G, te, "=", xe, ";");
            },
            toString: function() {
              return J() + ne();
            }
          });
        }
        function B() {
          var oe = Vi(arguments), ue = R(), J = R(), ne = ue.toString, k = J.toString;
          return i(ue, {
            then: function() {
              return ue.apply(ue, Ui(arguments)), this;
            },
            else: function() {
              return J.apply(J, Ui(arguments)), this;
            },
            toString: function() {
              var G = k();
              return G && (G = "else{" + G + "}"), Vi([
                "if(",
                oe,
                "){",
                ne(),
                "}",
                G
              ]);
            }
          });
        }
        var K = W(), Q = {};
        function re(oe, ue) {
          var J = [];
          function ne() {
            var Z = "a" + J.length;
            return J.push(Z), Z;
          }
          ue = ue || 0;
          for (var k = 0; k < ue; ++k)
            ne();
          var G = R(), te = G.toString, xe = Q[oe] = i(G, {
            arg: ne,
            toString: function() {
              return Vi([
                "function(",
                J.join(),
                "){",
                te(),
                "}"
              ]);
            }
          });
          return xe;
        }
        function ae() {
          var oe = [
            '"use strict";',
            K,
            "return {"
          ];
          Object.keys(Q).forEach(function(ne) {
            oe.push('"', ne, '":', Q[ne].toString(), ",");
          }), oe.push("}");
          var ue = Vi(oe).replace(/;/g, `;
`).replace(/}/g, `}
`).replace(/{/g, `{
`), J = Function.apply(null, h.concat(ue));
          return J.apply(null, _);
        }
        return {
          global: K,
          link: M,
          block: W,
          proc: re,
          scope: R,
          cond: B,
          compile: ae
        };
      }
      var $i = "xyzw".split(""), hl = 5121, Hi = 1, qa = 2, Ya = 0, Za = 1, Qa = 2, Ka = 3, go = 4, dl = 5, ml = 6, pl = "dither", vl = "blend.enable", gl = "blend.color", Ja = "blend.equation", es = "blend.func", yl = "depth.enable", xl = "depth.func", bl = "depth.range", _l = "depth.mask", ts = "colorMask", Sl = "cull.enable", Tl = "cull.face", ns = "frontFace", is = "lineWidth", wl = "polygonOffset.enable", rs = "polygonOffset.offset", Al = "sample.alpha", El = "sample.enable", os = "sample.coverage", Cl = "stencil.enable", Pl = "stencil.mask", as = "stencil.func", ss = "stencil.opFront", cr = "stencil.opBack", kl = "scissor.enable", yo = "scissor.box", Dn = "viewport", hr = "profile", hi = "framebuffer", dr = "vert", mr = "frag", di = "elements", mi = "primitive", pi = "count", xo = "offset", bo = "instances", pr = "vao", fs = "Width", ls = "Height", Wi = hi + fs, Xi = hi + ls, Md = Dn + fs, Od = Dn + ls, Il = "drawingBuffer", Ll = Il + fs, Dl = Il + ls, Nd = [
        es,
        Ja,
        as,
        ss,
        cr,
        os,
        Dn,
        yo,
        rs
      ], ji = 34962, us = 34963, Gd = 35632, Bd = 35633, Fl = 3553, Ud = 34067, Vd = 2884, $d = 3042, Hd = 3024, Wd = 2960, Xd = 2929, jd = 3089, qd = 32823, Yd = 32926, Zd = 32928, cs = 5126, _o = 35664, So = 35665, To = 35666, hs = 5124, wo = 35667, Ao = 35668, Eo = 35669, ds = 35670, Co = 35671, Po = 35672, ko = 35673, vr = 35674, gr = 35675, yr = 35676, xr = 35678, br = 35680, ms = 4, _r = 1028, vi = 1029, zl = 2304, ps = 2305, Qd = 32775, Kd = 32776, Jd = 519, qn = 7680, Rl = 0, Ml = 1, Ol = 32774, em = 513, Nl = 36160, tm = 36064, Sn = {
        0: 0,
        1: 1,
        zero: 0,
        one: 1,
        "src color": 768,
        "one minus src color": 769,
        "src alpha": 770,
        "one minus src alpha": 771,
        "dst color": 774,
        "one minus dst color": 775,
        "dst alpha": 772,
        "one minus dst alpha": 773,
        "constant color": 32769,
        "one minus constant color": 32770,
        "constant alpha": 32771,
        "one minus constant alpha": 32772,
        "src alpha saturate": 776
      }, Gl = [
        "constant color, constant alpha",
        "one minus constant color, constant alpha",
        "constant color, one minus constant alpha",
        "one minus constant color, one minus constant alpha",
        "constant alpha, constant color",
        "constant alpha, one minus constant color",
        "one minus constant alpha, constant color",
        "one minus constant alpha, one minus constant color"
      ], qi = {
        never: 512,
        less: 513,
        "<": 513,
        equal: 514,
        "=": 514,
        "==": 514,
        "===": 514,
        lequal: 515,
        "<=": 515,
        greater: 516,
        ">": 516,
        notequal: 517,
        "!=": 517,
        "!==": 517,
        gequal: 518,
        ">=": 518,
        always: 519
      }, Yn = {
        0: 0,
        zero: 0,
        keep: 7680,
        replace: 7681,
        increment: 7682,
        decrement: 7683,
        "increment wrap": 34055,
        "decrement wrap": 34056,
        invert: 5386
      }, Bl = {
        frag: Gd,
        vert: Bd
      }, vs = {
        cw: zl,
        ccw: ps
      };
      function Io(a) {
        return Array.isArray(a) || n(a) || hn(a);
      }
      function Ul(a) {
        return a.sort(function(h, _) {
          return h === Dn ? -1 : _ === Dn ? 1 : h < _ ? -1 : 1;
        });
      }
      function Lt(a, h, _, M) {
        this.thisDep = a, this.contextDep = h, this.propDep = _, this.append = M;
      }
      function Zn(a) {
        return a && !(a.thisDep || a.contextDep || a.propDep);
      }
      function St(a) {
        return new Lt(false, false, false, a);
      }
      function Zt(a, h) {
        var _ = a.type;
        if (_ === Ya) {
          var M = a.data.length;
          return new Lt(
            true,
            M >= 1,
            M >= 2,
            h
          );
        } else if (_ === go) {
          var W = a.data;
          return new Lt(
            W.thisDep,
            W.contextDep,
            W.propDep,
            h
          );
        } else {
          if (_ === dl)
            return new Lt(
              false,
              false,
              false,
              h
            );
          if (_ === ml) {
            for (var R = false, B = false, K = false, Q = 0; Q < a.data.length; ++Q) {
              var re = a.data[Q];
              if (re.type === Za)
                K = true;
              else if (re.type === Qa)
                B = true;
              else if (re.type === Ka)
                R = true;
              else if (re.type === Ya) {
                R = true;
                var ae = re.data;
                ae >= 1 && (B = true), ae >= 2 && (K = true);
              } else re.type === go && (R = R || re.data.thisDep, B = B || re.data.contextDep, K = K || re.data.propDep);
            }
            return new Lt(
              R,
              B,
              K,
              h
            );
          } else
            return new Lt(
              _ === Ka,
              _ === Qa,
              _ === Za,
              h
            );
        }
      }
      var Vl = new Lt(false, false, false, function() {
      });
      function nm(a, h, _, M, W, R, B, K, Q, re, ae, oe, ue, J, ne) {
        var k = re.Record, G = {
          add: 32774,
          subtract: 32778,
          "reverse subtract": 32779
        };
        _.ext_blend_minmax && (G.min = Qd, G.max = Kd);
        var te = _.angle_instanced_arrays, xe = _.webgl_draw_buffers, Z = _.oes_vertex_array_object, ge = {
          dirty: true,
          profile: ne.profile
        }, me = {}, De = [], X = {}, H = {};
        function Se(p) {
          return p.replace(".", "_");
        }
        function ce(p, c, T) {
          var C = Se(p);
          De.push(p), me[C] = ge[C] = !!T, X[C] = c;
        }
        function ee(p, c, T) {
          var C = Se(p);
          De.push(p), Array.isArray(T) ? (ge[C] = T.slice(), me[C] = T.slice()) : ge[C] = me[C] = T, H[C] = c;
        }
        ce(pl, Hd), ce(vl, $d), ee(gl, "blendColor", [0, 0, 0, 0]), ee(
          Ja,
          "blendEquationSeparate",
          [Ol, Ol]
        ), ee(
          es,
          "blendFuncSeparate",
          [Ml, Rl, Ml, Rl]
        ), ce(yl, Xd, true), ee(xl, "depthFunc", em), ee(bl, "depthRange", [0, 1]), ee(_l, "depthMask", true), ee(ts, ts, [true, true, true, true]), ce(Sl, Vd), ee(Tl, "cullFace", vi), ee(ns, ns, ps), ee(is, is, 1), ce(wl, qd), ee(rs, "polygonOffset", [0, 0]), ce(Al, Yd), ce(El, Zd), ee(os, "sampleCoverage", [1, false]), ce(Cl, Wd), ee(Pl, "stencilMask", -1), ee(as, "stencilFunc", [Jd, 0, -1]), ee(
          ss,
          "stencilOpSeparate",
          [_r, qn, qn, qn]
        ), ee(
          cr,
          "stencilOpSeparate",
          [vi, qn, qn, qn]
        ), ce(kl, jd), ee(
          yo,
          "scissor",
          [0, 0, a.drawingBufferWidth, a.drawingBufferHeight]
        ), ee(
          Dn,
          Dn,
          [0, 0, a.drawingBufferWidth, a.drawingBufferHeight]
        );
        var he = {
          gl: a,
          context: ue,
          strings: h,
          next: me,
          current: ge,
          draw: oe,
          elements: R,
          buffer: W,
          shader: ae,
          attributes: re.state,
          vao: re,
          uniforms: Q,
          framebuffer: K,
          extensions: _,
          timer: J,
          isBufferArgs: Io
        }, de = {
          primTypes: Xn,
          compareFuncs: qi,
          blendFuncs: Sn,
          blendEquations: G,
          stencilOps: Yn,
          glTypes: si,
          orientationType: vs
        };
        d.optional(function() {
          he.isArrayLike = pt;
        }), xe && (de.backBuffer = [vi], de.drawBuffer = Wt(M.maxDrawbuffers, function(p) {
          return p === 0 ? [0] : Wt(p, function(c) {
            return tm + c;
          });
        }));
        var He = 0;
        function Ue() {
          var p = Rd(), c = p.link, T = p.global;
          p.id = He++, p.batchId = "0";
          var C = c(he), I = p.shared = {
            props: "a0"
          };
          Object.keys(he).forEach(function(b) {
            I[b] = T.def(C, ".", b);
          }), d.optional(function() {
            p.CHECK = c(d), p.commandStr = d.guessCommand(), p.command = c(p.commandStr), p.assert = function(b, g, F) {
              b(
                "if(!(",
                g,
                "))",
                this.CHECK,
                ".commandRaise(",
                c(F),
                ",",
                this.command,
                ");"
              );
            }, de.invalidBlendCombinations = Gl;
          });
          var A = p.next = {}, w = p.current = {};
          Object.keys(H).forEach(function(b) {
            Array.isArray(ge[b]) && (A[b] = T.def(I.next, ".", b), w[b] = T.def(I.current, ".", b));
          });
          var E = p.constants = {};
          Object.keys(de).forEach(function(b) {
            E[b] = T.def(JSON.stringify(de[b]));
          }), p.invoke = function(b, g) {
            switch (g.type) {
              case Ya:
                var F = [
                  "this",
                  I.context,
                  I.props,
                  p.batchId
                ];
                return b.def(
                  c(g.data),
                  ".call(",
                  F.slice(0, Math.max(g.data.length + 1, 4)),
                  ")"
                );
              case Za:
                return b.def(I.props, g.data);
              case Qa:
                return b.def(I.context, g.data);
              case Ka:
                return b.def("this", g.data);
              case go:
                return g.data.append(p, b), g.data.ref;
              case dl:
                return g.data.toString();
              case ml:
                return g.data.map(function(L) {
                  return p.invoke(b, L);
                });
            }
          }, p.attribCache = {};
          var v = {};
          return p.scopeAttrib = function(b) {
            var g = h.id(b);
            if (g in v)
              return v[g];
            var F = re.scope[g];
            F || (F = re.scope[g] = new k());
            var L = v[g] = c(F);
            return L;
          }, p;
        }
        function pe(p) {
          var c = p.static, T = p.dynamic, C;
          if (hr in c) {
            var I = !!c[hr];
            C = St(function(w, E) {
              return I;
            }), C.enable = I;
          } else if (hr in T) {
            var A = T[hr];
            C = Zt(A, function(w, E) {
              return w.invoke(E, A);
            });
          }
          return C;
        }
        function ye(p, c) {
          var T = p.static, C = p.dynamic;
          if (hi in T) {
            var I = T[hi];
            return I ? (I = K.getFramebuffer(I), d.command(I, "invalid framebuffer object"), St(function(w, E) {
              var v = w.link(I), b = w.shared;
              E.set(
                b.framebuffer,
                ".next",
                v
              );
              var g = b.context;
              return E.set(
                g,
                "." + Wi,
                v + ".width"
              ), E.set(
                g,
                "." + Xi,
                v + ".height"
              ), v;
            })) : St(function(w, E) {
              var v = w.shared;
              E.set(
                v.framebuffer,
                ".next",
                "null"
              );
              var b = v.context;
              return E.set(
                b,
                "." + Wi,
                b + "." + Ll
              ), E.set(
                b,
                "." + Xi,
                b + "." + Dl
              ), "null";
            });
          } else if (hi in C) {
            var A = C[hi];
            return Zt(A, function(w, E) {
              var v = w.invoke(E, A), b = w.shared, g = b.framebuffer, F = E.def(
                g,
                ".getFramebuffer(",
                v,
                ")"
              );
              d.optional(function() {
                w.assert(
                  E,
                  "!" + v + "||" + F,
                  "invalid framebuffer object"
                );
              }), E.set(
                g,
                ".next",
                F
              );
              var L = b.context;
              return E.set(
                L,
                "." + Wi,
                F + "?" + F + ".width:" + L + "." + Ll
              ), E.set(
                L,
                "." + Xi,
                F + "?" + F + ".height:" + L + "." + Dl
              ), F;
            });
          } else
            return null;
        }
        function Re(p, c, T) {
          var C = p.static, I = p.dynamic;
          function A(v) {
            if (v in C) {
              var b = C[v];
              d.commandType(b, "object", "invalid " + v, T.commandStr);
              var g = true, F = b.x | 0, L = b.y | 0, $, j;
              return "width" in b ? ($ = b.width | 0, d.command($ >= 0, "invalid " + v, T.commandStr)) : g = false, "height" in b ? (j = b.height | 0, d.command(j >= 0, "invalid " + v, T.commandStr)) : g = false, new Lt(
                !g && c && c.thisDep,
                !g && c && c.contextDep,
                !g && c && c.propDep,
                function(Ie, be) {
                  var Y = Ie.shared.context, U = $;
                  "width" in b || (U = be.def(Y, ".", Wi, "-", F));
                  var Ce = j;
                  return "height" in b || (Ce = be.def(Y, ".", Xi, "-", L)), [F, L, U, Ce];
                }
              );
            } else if (v in I) {
              var le = I[v], Ne = Zt(le, function(Ie, be) {
                var Y = Ie.invoke(be, le);
                d.optional(function() {
                  Ie.assert(
                    be,
                    Y + "&&typeof " + Y + '==="object"',
                    "invalid " + v
                  );
                });
                var U = Ie.shared.context, Ce = be.def(Y, ".x|0"), Ae = be.def(Y, ".y|0"), Me = be.def(
                  '"width" in ',
                  Y,
                  "?",
                  Y,
                  ".width|0:",
                  "(",
                  U,
                  ".",
                  Wi,
                  "-",
                  Ce,
                  ")"
                ), ft = be.def(
                  '"height" in ',
                  Y,
                  "?",
                  Y,
                  ".height|0:",
                  "(",
                  U,
                  ".",
                  Xi,
                  "-",
                  Ae,
                  ")"
                );
                return d.optional(function() {
                  Ie.assert(
                    be,
                    Me + ">=0&&" + ft + ">=0",
                    "invalid " + v
                  );
                }), [Ce, Ae, Me, ft];
              });
              return c && (Ne.thisDep = Ne.thisDep || c.thisDep, Ne.contextDep = Ne.contextDep || c.contextDep, Ne.propDep = Ne.propDep || c.propDep), Ne;
            } else return c ? new Lt(
              c.thisDep,
              c.contextDep,
              c.propDep,
              function(Ie, be) {
                var Y = Ie.shared.context;
                return [
                  0,
                  0,
                  be.def(Y, ".", Wi),
                  be.def(Y, ".", Xi)
                ];
              }
            ) : null;
          }
          var w = A(Dn);
          if (w) {
            var E = w;
            w = new Lt(
              w.thisDep,
              w.contextDep,
              w.propDep,
              function(v, b) {
                var g = E.append(v, b), F = v.shared.context;
                return b.set(
                  F,
                  "." + Md,
                  g[2]
                ), b.set(
                  F,
                  "." + Od,
                  g[3]
                ), g;
              }
            );
          }
          return {
            viewport: w,
            scissor_box: A(yo)
          };
        }
        function We(p, c) {
          var T = p.static, C = typeof T[mr] == "string" && typeof T[dr] == "string";
          if (C) {
            if (Object.keys(c.dynamic).length > 0)
              return null;
            var I = c.static, A = Object.keys(I);
            if (A.length > 0 && typeof I[A[0]] == "number") {
              for (var w = [], E = 0; E < A.length; ++E)
                d(typeof I[A[E]] == "number", "must specify all vertex attribute locations when using vaos"), w.push([I[A[E]] | 0, A[E]]);
              return w;
            }
          }
          return null;
        }
        function Je(p, c, T) {
          var C = p.static, I = p.dynamic;
          function A(g) {
            if (g in C) {
              var F = h.id(C[g]);
              d.optional(function() {
                ae.shader(Bl[g], F, d.guessCommand());
              });
              var L = St(function() {
                return F;
              });
              return L.id = F, L;
            } else if (g in I) {
              var $ = I[g];
              return Zt($, function(j, le) {
                var Ne = j.invoke(le, $), Ie = le.def(j.shared.strings, ".id(", Ne, ")");
                return d.optional(function() {
                  le(
                    j.shared.shader,
                    ".shader(",
                    Bl[g],
                    ",",
                    Ie,
                    ",",
                    j.command,
                    ");"
                  );
                }), Ie;
              });
            }
            return null;
          }
          var w = A(mr), E = A(dr), v = null, b;
          return Zn(w) && Zn(E) ? (v = ae.program(E.id, w.id, null, T), b = St(function(g, F) {
            return g.link(v);
          })) : b = new Lt(
            w && w.thisDep || E && E.thisDep,
            w && w.contextDep || E && E.contextDep,
            w && w.propDep || E && E.propDep,
            function(g, F) {
              var L = g.shared.shader, $;
              w ? $ = w.append(g, F) : $ = F.def(L, ".", mr);
              var j;
              E ? j = E.append(g, F) : j = F.def(L, ".", dr);
              var le = L + ".program(" + j + "," + $;
              return d.optional(function() {
                le += "," + g.command;
              }), F.def(le + ")");
            }
          ), {
            frag: w,
            vert: E,
            progVar: b,
            program: v
          };
        }
        function vt(p, c) {
          var T = p.static, C = p.dynamic, I = {}, A = false;
          function w() {
            if (pr in T) {
              var be = T[pr];
              return be !== null && re.getVAO(be) === null && (be = re.createVAO(be)), A = true, I.vao = be, St(function(U) {
                var Ce = re.getVAO(be);
                return Ce ? U.link(Ce) : "null";
              });
            } else if (pr in C) {
              A = true;
              var Y = C[pr];
              return Zt(Y, function(U, Ce) {
                var Ae = U.invoke(Ce, Y);
                return Ce.def(U.shared.vao + ".getVAO(" + Ae + ")");
              });
            }
            return null;
          }
          var E = w(), v = false;
          function b() {
            if (di in T) {
              var be = T[di];
              if (I.elements = be, Io(be)) {
                var Y = I.elements = R.create(be, true);
                be = R.getElements(Y), v = true;
              } else be && (be = R.getElements(be), v = true, d.command(be, "invalid elements", c.commandStr));
              var U = St(function(Ae, Me) {
                if (be) {
                  var ft = Ae.link(be);
                  return Ae.ELEMENTS = ft, ft;
                }
                return Ae.ELEMENTS = null, null;
              });
              return U.value = be, U;
            } else if (di in C) {
              v = true;
              var Ce = C[di];
              return Zt(Ce, function(Ae, Me) {
                var ft = Ae.shared, Ut = ft.isBufferArgs, yi = ft.elements, Fn = Ae.invoke(Me, Ce), wn = Me.def("null"), Qn = Me.def(Ut, "(", Fn, ")"), xi = Ae.cond(Qn).then(wn, "=", yi, ".createStream(", Fn, ");").else(wn, "=", yi, ".getElements(", Fn, ");");
                return d.optional(function() {
                  Ae.assert(
                    xi.else,
                    "!" + Fn + "||" + wn,
                    "invalid elements"
                  );
                }), Me.entry(xi), Me.exit(
                  Ae.cond(Qn).then(yi, ".destroyStream(", wn, ");")
                ), Ae.ELEMENTS = wn, wn;
              });
            } else if (A)
              return new Lt(
                E.thisDep,
                E.contextDep,
                E.propDep,
                function(Ae, Me) {
                  return Me.def(Ae.shared.vao + ".currentVAO?" + Ae.shared.elements + ".getElements(" + Ae.shared.vao + ".currentVAO.elements):null");
                }
              );
            return null;
          }
          var g = b();
          function F() {
            if (mi in T) {
              var be = T[mi];
              return I.primitive = be, d.commandParameter(be, Xn, "invalid primitve", c.commandStr), St(function(U, Ce) {
                return Xn[be];
              });
            } else if (mi in C) {
              var Y = C[mi];
              return Zt(Y, function(U, Ce) {
                var Ae = U.constants.primTypes, Me = U.invoke(Ce, Y);
                return d.optional(function() {
                  U.assert(
                    Ce,
                    Me + " in " + Ae,
                    "invalid primitive, must be one of " + Object.keys(Xn)
                  );
                }), Ce.def(Ae, "[", Me, "]");
              });
            } else {
              if (v)
                return Zn(g) ? g.value ? St(function(U, Ce) {
                  return Ce.def(U.ELEMENTS, ".primType");
                }) : St(function() {
                  return ms;
                }) : new Lt(
                  g.thisDep,
                  g.contextDep,
                  g.propDep,
                  function(U, Ce) {
                    var Ae = U.ELEMENTS;
                    return Ce.def(Ae, "?", Ae, ".primType:", ms);
                  }
                );
              if (A)
                return new Lt(
                  E.thisDep,
                  E.contextDep,
                  E.propDep,
                  function(U, Ce) {
                    return Ce.def(U.shared.vao + ".currentVAO?" + U.shared.vao + ".currentVAO.primitive:" + ms);
                  }
                );
            }
            return null;
          }
          function L(be, Y) {
            if (be in T) {
              var U = T[be] | 0;
              return Y ? I.offset = U : I.instances = U, d.command(!Y || U >= 0, "invalid " + be, c.commandStr), St(function(Ae, Me) {
                return Y && (Ae.OFFSET = U), U;
              });
            } else if (be in C) {
              var Ce = C[be];
              return Zt(Ce, function(Ae, Me) {
                var ft = Ae.invoke(Me, Ce);
                return Y && (Ae.OFFSET = ft, d.optional(function() {
                  Ae.assert(
                    Me,
                    ft + ">=0",
                    "invalid " + be
                  );
                })), ft;
              });
            } else if (Y) {
              if (v)
                return St(function(Ae, Me) {
                  return Ae.OFFSET = 0, 0;
                });
              if (A)
                return new Lt(
                  E.thisDep,
                  E.contextDep,
                  E.propDep,
                  function(Ae, Me) {
                    return Me.def(Ae.shared.vao + ".currentVAO?" + Ae.shared.vao + ".currentVAO.offset:0");
                  }
                );
            } else if (A)
              return new Lt(
                E.thisDep,
                E.contextDep,
                E.propDep,
                function(Ae, Me) {
                  return Me.def(Ae.shared.vao + ".currentVAO?" + Ae.shared.vao + ".currentVAO.instances:-1");
                }
              );
            return null;
          }
          var $ = L(xo, true);
          function j() {
            if (pi in T) {
              var be = T[pi] | 0;
              return I.count = be, d.command(
                typeof be == "number" && be >= 0,
                "invalid vertex count",
                c.commandStr
              ), St(function() {
                return be;
              });
            } else if (pi in C) {
              var Y = C[pi];
              return Zt(Y, function(Me, ft) {
                var Ut = Me.invoke(ft, Y);
                return d.optional(function() {
                  Me.assert(
                    ft,
                    "typeof " + Ut + '==="number"&&' + Ut + ">=0&&" + Ut + "===(" + Ut + "|0)",
                    "invalid vertex count"
                  );
                }), Ut;
              });
            } else if (v)
              if (Zn(g)) {
                if (g)
                  return $ ? new Lt(
                    $.thisDep,
                    $.contextDep,
                    $.propDep,
                    function(Me, ft) {
                      var Ut = ft.def(
                        Me.ELEMENTS,
                        ".vertCount-",
                        Me.OFFSET
                      );
                      return d.optional(function() {
                        Me.assert(
                          ft,
                          Ut + ">=0",
                          "invalid vertex offset/element buffer too small"
                        );
                      }), Ut;
                    }
                  ) : St(function(Me, ft) {
                    return ft.def(Me.ELEMENTS, ".vertCount");
                  });
                var U = St(function() {
                  return -1;
                });
                return d.optional(function() {
                  U.MISSING = true;
                }), U;
              } else {
                var Ce = new Lt(
                  g.thisDep || $.thisDep,
                  g.contextDep || $.contextDep,
                  g.propDep || $.propDep,
                  function(Me, ft) {
                    var Ut = Me.ELEMENTS;
                    return Me.OFFSET ? ft.def(
                      Ut,
                      "?",
                      Ut,
                      ".vertCount-",
                      Me.OFFSET,
                      ":-1"
                    ) : ft.def(Ut, "?", Ut, ".vertCount:-1");
                  }
                );
                return d.optional(function() {
                  Ce.DYNAMIC = true;
                }), Ce;
              }
            else if (A) {
              var Ae = new Lt(
                E.thisDep,
                E.contextDep,
                E.propDep,
                function(Me, ft) {
                  return ft.def(Me.shared.vao, ".currentVAO?", Me.shared.vao, ".currentVAO.count:-1");
                }
              );
              return Ae;
            }
            return null;
          }
          var le = F(), Ne = j(), Ie = L(bo, false);
          return {
            elements: g,
            primitive: le,
            count: Ne,
            instances: Ie,
            offset: $,
            vao: E,
            vaoActive: A,
            elementsActive: v,
            // static draw props
            static: I
          };
        }
        function yt(p, c) {
          var T = p.static, C = p.dynamic, I = {};
          return De.forEach(function(A) {
            var w = Se(A);
            function E(v, b) {
              if (A in T) {
                var g = v(T[A]);
                I[w] = St(function() {
                  return g;
                });
              } else if (A in C) {
                var F = C[A];
                I[w] = Zt(F, function(L, $) {
                  return b(L, $, L.invoke($, F));
                });
              }
            }
            switch (A) {
              case Sl:
              case vl:
              case pl:
              case Cl:
              case yl:
              case kl:
              case wl:
              case Al:
              case El:
              case _l:
                return E(
                  function(v) {
                    return d.commandType(v, "boolean", A, c.commandStr), v;
                  },
                  function(v, b, g) {
                    return d.optional(function() {
                      v.assert(
                        b,
                        "typeof " + g + '==="boolean"',
                        "invalid flag " + A,
                        v.commandStr
                      );
                    }), g;
                  }
                );
              case xl:
                return E(
                  function(v) {
                    return d.commandParameter(v, qi, "invalid " + A, c.commandStr), qi[v];
                  },
                  function(v, b, g) {
                    var F = v.constants.compareFuncs;
                    return d.optional(function() {
                      v.assert(
                        b,
                        g + " in " + F,
                        "invalid " + A + ", must be one of " + Object.keys(qi)
                      );
                    }), b.def(F, "[", g, "]");
                  }
                );
              case bl:
                return E(
                  function(v) {
                    return d.command(
                      pt(v) && v.length === 2 && typeof v[0] == "number" && typeof v[1] == "number" && v[0] <= v[1],
                      "depth range is 2d array",
                      c.commandStr
                    ), v;
                  },
                  function(v, b, g) {
                    d.optional(function() {
                      v.assert(
                        b,
                        v.shared.isArrayLike + "(" + g + ")&&" + g + ".length===2&&typeof " + g + '[0]==="number"&&typeof ' + g + '[1]==="number"&&' + g + "[0]<=" + g + "[1]",
                        "depth range must be a 2d array"
                      );
                    });
                    var F = b.def("+", g, "[0]"), L = b.def("+", g, "[1]");
                    return [F, L];
                  }
                );
              case es:
                return E(
                  function(v) {
                    d.commandType(v, "object", "blend.func", c.commandStr);
                    var b = "srcRGB" in v ? v.srcRGB : v.src, g = "srcAlpha" in v ? v.srcAlpha : v.src, F = "dstRGB" in v ? v.dstRGB : v.dst, L = "dstAlpha" in v ? v.dstAlpha : v.dst;
                    return d.commandParameter(b, Sn, w + ".srcRGB", c.commandStr), d.commandParameter(g, Sn, w + ".srcAlpha", c.commandStr), d.commandParameter(F, Sn, w + ".dstRGB", c.commandStr), d.commandParameter(L, Sn, w + ".dstAlpha", c.commandStr), d.command(
                      Gl.indexOf(b + ", " + F) === -1,
                      "unallowed blending combination (srcRGB, dstRGB) = (" + b + ", " + F + ")",
                      c.commandStr
                    ), [
                      Sn[b],
                      Sn[F],
                      Sn[g],
                      Sn[L]
                    ];
                  },
                  function(v, b, g) {
                    var F = v.constants.blendFuncs;
                    d.optional(function() {
                      v.assert(
                        b,
                        g + "&&typeof " + g + '==="object"',
                        "invalid blend func, must be an object"
                      );
                    });
                    function L(Y, U) {
                      var Ce = b.def(
                        '"',
                        Y,
                        U,
                        '" in ',
                        g,
                        "?",
                        g,
                        ".",
                        Y,
                        U,
                        ":",
                        g,
                        ".",
                        Y
                      );
                      return d.optional(function() {
                        v.assert(
                          b,
                          Ce + " in " + F,
                          "invalid " + A + "." + Y + U + ", must be one of " + Object.keys(Sn)
                        );
                      }), Ce;
                    }
                    var $ = L("src", "RGB"), j = L("dst", "RGB");
                    d.optional(function() {
                      var Y = v.constants.invalidBlendCombinations;
                      v.assert(
                        b,
                        Y + ".indexOf(" + $ + '+", "+' + j + ") === -1 ",
                        "unallowed blending combination for (srcRGB, dstRGB)"
                      );
                    });
                    var le = b.def(F, "[", $, "]"), Ne = b.def(F, "[", L("src", "Alpha"), "]"), Ie = b.def(F, "[", j, "]"), be = b.def(F, "[", L("dst", "Alpha"), "]");
                    return [le, Ie, Ne, be];
                  }
                );
              case Ja:
                return E(
                  function(v) {
                    if (typeof v == "string")
                      return d.commandParameter(v, G, "invalid " + A, c.commandStr), [
                        G[v],
                        G[v]
                      ];
                    if (typeof v == "object")
                      return d.commandParameter(
                        v.rgb,
                        G,
                        A + ".rgb",
                        c.commandStr
                      ), d.commandParameter(
                        v.alpha,
                        G,
                        A + ".alpha",
                        c.commandStr
                      ), [
                        G[v.rgb],
                        G[v.alpha]
                      ];
                    d.commandRaise("invalid blend.equation", c.commandStr);
                  },
                  function(v, b, g) {
                    var F = v.constants.blendEquations, L = b.def(), $ = b.def(), j = v.cond("typeof ", g, '==="string"');
                    return d.optional(function() {
                      function le(Ne, Ie, be) {
                        v.assert(
                          Ne,
                          be + " in " + F,
                          "invalid " + Ie + ", must be one of " + Object.keys(G)
                        );
                      }
                      le(j.then, A, g), v.assert(
                        j.else,
                        g + "&&typeof " + g + '==="object"',
                        "invalid " + A
                      ), le(j.else, A + ".rgb", g + ".rgb"), le(j.else, A + ".alpha", g + ".alpha");
                    }), j.then(
                      L,
                      "=",
                      $,
                      "=",
                      F,
                      "[",
                      g,
                      "];"
                    ), j.else(
                      L,
                      "=",
                      F,
                      "[",
                      g,
                      ".rgb];",
                      $,
                      "=",
                      F,
                      "[",
                      g,
                      ".alpha];"
                    ), b(j), [L, $];
                  }
                );
              case gl:
                return E(
                  function(v) {
                    return d.command(
                      pt(v) && v.length === 4,
                      "blend.color must be a 4d array",
                      c.commandStr
                    ), Wt(4, function(b) {
                      return +v[b];
                    });
                  },
                  function(v, b, g) {
                    return d.optional(function() {
                      v.assert(
                        b,
                        v.shared.isArrayLike + "(" + g + ")&&" + g + ".length===4",
                        "blend.color must be a 4d array"
                      );
                    }), Wt(4, function(F) {
                      return b.def("+", g, "[", F, "]");
                    });
                  }
                );
              case Pl:
                return E(
                  function(v) {
                    return d.commandType(v, "number", w, c.commandStr), v | 0;
                  },
                  function(v, b, g) {
                    return d.optional(function() {
                      v.assert(
                        b,
                        "typeof " + g + '==="number"',
                        "invalid stencil.mask"
                      );
                    }), b.def(g, "|0");
                  }
                );
              case as:
                return E(
                  function(v) {
                    d.commandType(v, "object", w, c.commandStr);
                    var b = v.cmp || "keep", g = v.ref || 0, F = "mask" in v ? v.mask : -1;
                    return d.commandParameter(b, qi, A + ".cmp", c.commandStr), d.commandType(g, "number", A + ".ref", c.commandStr), d.commandType(F, "number", A + ".mask", c.commandStr), [
                      qi[b],
                      g,
                      F
                    ];
                  },
                  function(v, b, g) {
                    var F = v.constants.compareFuncs;
                    d.optional(function() {
                      function le() {
                        v.assert(
                          b,
                          Array.prototype.join.call(arguments, ""),
                          "invalid stencil.func"
                        );
                      }
                      le(g + "&&typeof ", g, '==="object"'), le(
                        '!("cmp" in ',
                        g,
                        ")||(",
                        g,
                        ".cmp in ",
                        F,
                        ")"
                      );
                    });
                    var L = b.def(
                      '"cmp" in ',
                      g,
                      "?",
                      F,
                      "[",
                      g,
                      ".cmp]",
                      ":",
                      qn
                    ), $ = b.def(g, ".ref|0"), j = b.def(
                      '"mask" in ',
                      g,
                      "?",
                      g,
                      ".mask|0:-1"
                    );
                    return [L, $, j];
                  }
                );
              case ss:
              case cr:
                return E(
                  function(v) {
                    d.commandType(v, "object", w, c.commandStr);
                    var b = v.fail || "keep", g = v.zfail || "keep", F = v.zpass || "keep";
                    return d.commandParameter(b, Yn, A + ".fail", c.commandStr), d.commandParameter(g, Yn, A + ".zfail", c.commandStr), d.commandParameter(F, Yn, A + ".zpass", c.commandStr), [
                      A === cr ? vi : _r,
                      Yn[b],
                      Yn[g],
                      Yn[F]
                    ];
                  },
                  function(v, b, g) {
                    var F = v.constants.stencilOps;
                    d.optional(function() {
                      v.assert(
                        b,
                        g + "&&typeof " + g + '==="object"',
                        "invalid " + A
                      );
                    });
                    function L($) {
                      return d.optional(function() {
                        v.assert(
                          b,
                          '!("' + $ + '" in ' + g + ")||(" + g + "." + $ + " in " + F + ")",
                          "invalid " + A + "." + $ + ", must be one of " + Object.keys(Yn)
                        );
                      }), b.def(
                        '"',
                        $,
                        '" in ',
                        g,
                        "?",
                        F,
                        "[",
                        g,
                        ".",
                        $,
                        "]:",
                        qn
                      );
                    }
                    return [
                      A === cr ? vi : _r,
                      L("fail"),
                      L("zfail"),
                      L("zpass")
                    ];
                  }
                );
              case rs:
                return E(
                  function(v) {
                    d.commandType(v, "object", w, c.commandStr);
                    var b = v.factor | 0, g = v.units | 0;
                    return d.commandType(b, "number", w + ".factor", c.commandStr), d.commandType(g, "number", w + ".units", c.commandStr), [b, g];
                  },
                  function(v, b, g) {
                    d.optional(function() {
                      v.assert(
                        b,
                        g + "&&typeof " + g + '==="object"',
                        "invalid " + A
                      );
                    });
                    var F = b.def(g, ".factor|0"), L = b.def(g, ".units|0");
                    return [F, L];
                  }
                );
              case Tl:
                return E(
                  function(v) {
                    var b = 0;
                    return v === "front" ? b = _r : v === "back" && (b = vi), d.command(!!b, w, c.commandStr), b;
                  },
                  function(v, b, g) {
                    return d.optional(function() {
                      v.assert(
                        b,
                        g + '==="front"||' + g + '==="back"',
                        "invalid cull.face"
                      );
                    }), b.def(g, '==="front"?', _r, ":", vi);
                  }
                );
              case is:
                return E(
                  function(v) {
                    return d.command(
                      typeof v == "number" && v >= M.lineWidthDims[0] && v <= M.lineWidthDims[1],
                      "invalid line width, must be a positive number between " + M.lineWidthDims[0] + " and " + M.lineWidthDims[1],
                      c.commandStr
                    ), v;
                  },
                  function(v, b, g) {
                    return d.optional(function() {
                      v.assert(
                        b,
                        "typeof " + g + '==="number"&&' + g + ">=" + M.lineWidthDims[0] + "&&" + g + "<=" + M.lineWidthDims[1],
                        "invalid line width"
                      );
                    }), g;
                  }
                );
              case ns:
                return E(
                  function(v) {
                    return d.commandParameter(v, vs, w, c.commandStr), vs[v];
                  },
                  function(v, b, g) {
                    return d.optional(function() {
                      v.assert(
                        b,
                        g + '==="cw"||' + g + '==="ccw"',
                        "invalid frontFace, must be one of cw,ccw"
                      );
                    }), b.def(g + '==="cw"?' + zl + ":" + ps);
                  }
                );
              case ts:
                return E(
                  function(v) {
                    return d.command(
                      pt(v) && v.length === 4,
                      "color.mask must be length 4 array",
                      c.commandStr
                    ), v.map(function(b) {
                      return !!b;
                    });
                  },
                  function(v, b, g) {
                    return d.optional(function() {
                      v.assert(
                        b,
                        v.shared.isArrayLike + "(" + g + ")&&" + g + ".length===4",
                        "invalid color.mask"
                      );
                    }), Wt(4, function(F) {
                      return "!!" + g + "[" + F + "]";
                    });
                  }
                );
              case os:
                return E(
                  function(v) {
                    d.command(typeof v == "object" && v, w, c.commandStr);
                    var b = "value" in v ? v.value : 1, g = !!v.invert;
                    return d.command(
                      typeof b == "number" && b >= 0 && b <= 1,
                      "sample.coverage.value must be a number between 0 and 1",
                      c.commandStr
                    ), [b, g];
                  },
                  function(v, b, g) {
                    d.optional(function() {
                      v.assert(
                        b,
                        g + "&&typeof " + g + '==="object"',
                        "invalid sample.coverage"
                      );
                    });
                    var F = b.def(
                      '"value" in ',
                      g,
                      "?+",
                      g,
                      ".value:1"
                    ), L = b.def("!!", g, ".invert");
                    return [F, L];
                  }
                );
            }
          }), I;
        }
        function tt(p, c) {
          var T = p.static, C = p.dynamic, I = {};
          return Object.keys(T).forEach(function(A) {
            var w = T[A], E;
            if (typeof w == "number" || typeof w == "boolean")
              E = St(function() {
                return w;
              });
            else if (typeof w == "function") {
              var v = w._reglType;
              v === "texture2d" || v === "textureCube" ? E = St(function(b) {
                return b.link(w);
              }) : v === "framebuffer" || v === "framebufferCube" ? (d.command(
                w.color.length > 0,
                'missing color attachment for framebuffer sent to uniform "' + A + '"',
                c.commandStr
              ), E = St(function(b) {
                return b.link(w.color[0]);
              })) : d.commandRaise('invalid data for uniform "' + A + '"', c.commandStr);
            } else pt(w) ? E = St(function(b) {
              var g = b.global.def(
                "[",
                Wt(w.length, function(F) {
                  return d.command(
                    typeof w[F] == "number" || typeof w[F] == "boolean",
                    "invalid uniform " + A,
                    b.commandStr
                  ), w[F];
                }),
                "]"
              );
              return g;
            }) : d.commandRaise('invalid or missing data for uniform "' + A + '"', c.commandStr);
            E.value = w, I[A] = E;
          }), Object.keys(C).forEach(function(A) {
            var w = C[A];
            I[A] = Zt(w, function(E, v) {
              return E.invoke(v, w);
            });
          }), I;
        }
        function At(p, c) {
          var T = p.static, C = p.dynamic, I = {};
          return Object.keys(T).forEach(function(A) {
            var w = T[A], E = h.id(A), v = new k();
            if (Io(w))
              v.state = Hi, v.buffer = W.getBuffer(
                W.create(w, ji, false, true)
              ), v.type = 0;
            else {
              var b = W.getBuffer(w);
              if (b)
                v.state = Hi, v.buffer = b, v.type = 0;
              else if (d.command(
                typeof w == "object" && w,
                "invalid data for attribute " + A,
                c.commandStr
              ), "constant" in w) {
                var g = w.constant;
                v.buffer = "null", v.state = qa, typeof g == "number" ? v.x = g : (d.command(
                  pt(g) && g.length > 0 && g.length <= 4,
                  "invalid constant for attribute " + A,
                  c.commandStr
                ), $i.forEach(function(Ie, be) {
                  be < g.length && (v[Ie] = g[be]);
                }));
              } else {
                Io(w.buffer) ? b = W.getBuffer(
                  W.create(w.buffer, ji, false, true)
                ) : b = W.getBuffer(w.buffer), d.command(!!b, 'missing buffer for attribute "' + A + '"', c.commandStr);
                var F = w.offset | 0;
                d.command(
                  F >= 0,
                  'invalid offset for attribute "' + A + '"',
                  c.commandStr
                );
                var L = w.stride | 0;
                d.command(
                  L >= 0 && L < 256,
                  'invalid stride for attribute "' + A + '", must be integer betweeen [0, 255]',
                  c.commandStr
                );
                var $ = w.size | 0;
                d.command(
                  !("size" in w) || $ > 0 && $ <= 4,
                  'invalid size for attribute "' + A + '", must be 1,2,3,4',
                  c.commandStr
                );
                var j = !!w.normalized, le = 0;
                "type" in w && (d.commandParameter(
                  w.type,
                  si,
                  "invalid type for attribute " + A,
                  c.commandStr
                ), le = si[w.type]);
                var Ne = w.divisor | 0;
                d.optional(function() {
                  "divisor" in w && (d.command(
                    Ne === 0 || te,
                    'cannot specify divisor for attribute "' + A + '", instancing not supported',
                    c.commandStr
                  ), d.command(
                    Ne >= 0,
                    'invalid divisor for attribute "' + A + '"',
                    c.commandStr
                  ));
                  var Ie = c.commandStr, be = [
                    "buffer",
                    "offset",
                    "divisor",
                    "normalized",
                    "type",
                    "size",
                    "stride"
                  ];
                  Object.keys(w).forEach(function(Y) {
                    d.command(
                      be.indexOf(Y) >= 0,
                      'unknown parameter "' + Y + '" for attribute pointer "' + A + '" (valid parameters are ' + be + ")",
                      Ie
                    );
                  });
                }), v.buffer = b, v.state = Hi, v.size = $, v.normalized = j, v.type = le || b.dtype, v.offset = F, v.stride = L, v.divisor = Ne;
              }
            }
            I[A] = St(function(Ie, be) {
              var Y = Ie.attribCache;
              if (E in Y)
                return Y[E];
              var U = {
                isStream: false
              };
              return Object.keys(v).forEach(function(Ce) {
                U[Ce] = v[Ce];
              }), v.buffer && (U.buffer = Ie.link(v.buffer), U.type = U.type || U.buffer + ".dtype"), Y[E] = U, U;
            });
          }), Object.keys(C).forEach(function(A) {
            var w = C[A];
            function E(v, b) {
              var g = v.invoke(b, w), F = v.shared, L = v.constants, $ = F.isBufferArgs, j = F.buffer;
              d.optional(function() {
                v.assert(
                  b,
                  g + "&&(typeof " + g + '==="object"||typeof ' + g + '==="function")&&(' + $ + "(" + g + ")||" + j + ".getBuffer(" + g + ")||" + j + ".getBuffer(" + g + ".buffer)||" + $ + "(" + g + '.buffer)||("constant" in ' + g + "&&(typeof " + g + '.constant==="number"||' + F.isArrayLike + "(" + g + ".constant))))",
                  'invalid dynamic attribute "' + A + '"'
                );
              });
              var le = {
                isStream: b.def(false)
              }, Ne = new k();
              Ne.state = Hi, Object.keys(Ne).forEach(function(U) {
                le[U] = b.def("" + Ne[U]);
              });
              var Ie = le.buffer, be = le.type;
              b(
                "if(",
                $,
                "(",
                g,
                ")){",
                le.isStream,
                "=true;",
                Ie,
                "=",
                j,
                ".createStream(",
                ji,
                ",",
                g,
                ");",
                be,
                "=",
                Ie,
                ".dtype;",
                "}else{",
                Ie,
                "=",
                j,
                ".getBuffer(",
                g,
                ");",
                "if(",
                Ie,
                "){",
                be,
                "=",
                Ie,
                ".dtype;",
                '}else if("constant" in ',
                g,
                "){",
                le.state,
                "=",
                qa,
                ";",
                "if(typeof " + g + '.constant === "number"){',
                le[$i[0]],
                "=",
                g,
                ".constant;",
                $i.slice(1).map(function(U) {
                  return le[U];
                }).join("="),
                "=0;",
                "}else{",
                $i.map(function(U, Ce) {
                  return le[U] + "=" + g + ".constant.length>" + Ce + "?" + g + ".constant[" + Ce + "]:0;";
                }).join(""),
                "}}else{",
                "if(",
                $,
                "(",
                g,
                ".buffer)){",
                Ie,
                "=",
                j,
                ".createStream(",
                ji,
                ",",
                g,
                ".buffer);",
                "}else{",
                Ie,
                "=",
                j,
                ".getBuffer(",
                g,
                ".buffer);",
                "}",
                be,
                '="type" in ',
                g,
                "?",
                L.glTypes,
                "[",
                g,
                ".type]:",
                Ie,
                ".dtype;",
                le.normalized,
                "=!!",
                g,
                ".normalized;"
              );
              function Y(U) {
                b(le[U], "=", g, ".", U, "|0;");
              }
              return Y("size"), Y("offset"), Y("stride"), Y("divisor"), b("}}"), b.exit(
                "if(",
                le.isStream,
                "){",
                j,
                ".destroyStream(",
                Ie,
                ");",
                "}"
              ), le;
            }
            I[A] = Zt(w, E);
          }), I;
        }
        function ht(p) {
          var c = p.static, T = p.dynamic, C = {};
          return Object.keys(c).forEach(function(I) {
            var A = c[I];
            C[I] = St(function(w, E) {
              return typeof A == "number" || typeof A == "boolean" ? "" + A : w.link(A);
            });
          }), Object.keys(T).forEach(function(I) {
            var A = T[I];
            C[I] = Zt(A, function(w, E) {
              return w.invoke(E, A);
            });
          }), C;
        }
        function Tt(p, c, T, C, I) {
          var A = p.static, w = p.dynamic;
          d.optional(function() {
            var Y = [
              hi,
              dr,
              mr,
              di,
              mi,
              xo,
              pi,
              bo,
              hr,
              pr
            ].concat(De);
            function U(Ce) {
              Object.keys(Ce).forEach(function(Ae) {
                d.command(
                  Y.indexOf(Ae) >= 0,
                  'unknown parameter "' + Ae + '"',
                  I.commandStr
                );
              });
            }
            U(A), U(w);
          });
          var E = We(p, c), v = ye(p), b = Re(p, v, I), g = vt(p, I), F = yt(p, I), L = Je(p, I, E);
          function $(Y) {
            var U = b[Y];
            U && (F[Y] = U);
          }
          $(Dn), $(Se(yo));
          var j = Object.keys(F).length > 0, le = {
            framebuffer: v,
            draw: g,
            shader: L,
            state: F,
            dirty: j,
            scopeVAO: null,
            drawVAO: null,
            useVAO: false,
            attributes: {}
          };
          if (le.profile = pe(p), le.uniforms = tt(T, I), le.drawVAO = le.scopeVAO = g.vao, !le.drawVAO && L.program && !E && _.angle_instanced_arrays && g.static.elements) {
            var Ne = true, Ie = L.program.attributes.map(function(Y) {
              var U = c.static[Y];
              return Ne = Ne && !!U, U;
            });
            if (Ne && Ie.length > 0) {
              var be = re.getVAO(re.createVAO({
                attributes: Ie,
                elements: g.static.elements
              }));
              le.drawVAO = new Lt(null, null, null, function(Y, U) {
                return Y.link(be);
              }), le.useVAO = true;
            }
          }
          return E ? le.useVAO = true : le.attributes = At(c, I), le.context = ht(C), le;
        }
        function Et(p, c, T) {
          var C = p.shared, I = C.context, A = p.scope();
          Object.keys(T).forEach(function(w) {
            c.save(I, "." + w);
            var E = T[w], v = E.append(p, c);
            Array.isArray(v) ? A(I, ".", w, "=[", v.join(), "];") : A(I, ".", w, "=", v, ";");
          }), c(A);
        }
        function Ct(p, c, T, C) {
          var I = p.shared, A = I.gl, w = I.framebuffer, E;
          xe && (E = c.def(I.extensions, ".webgl_draw_buffers"));
          var v = p.constants, b = v.drawBuffer, g = v.backBuffer, F;
          T ? F = T.append(p, c) : F = c.def(w, ".next"), C || c("if(", F, "!==", w, ".cur){"), c(
            "if(",
            F,
            "){",
            A,
            ".bindFramebuffer(",
            Nl,
            ",",
            F,
            ".framebuffer);"
          ), xe && c(
            E,
            ".drawBuffersWEBGL(",
            b,
            "[",
            F,
            ".colorAttachments.length]);"
          ), c(
            "}else{",
            A,
            ".bindFramebuffer(",
            Nl,
            ",null);"
          ), xe && c(E, ".drawBuffersWEBGL(", g, ");"), c(
            "}",
            w,
            ".cur=",
            F,
            ";"
          ), C || c("}");
        }
        function Ft(p, c, T) {
          var C = p.shared, I = C.gl, A = p.current, w = p.next, E = C.current, v = C.next, b = p.cond(E, ".dirty");
          De.forEach(function(g) {
            var F = Se(g);
            if (!(F in T.state)) {
              var L, $;
              if (F in w) {
                L = w[F], $ = A[F];
                var j = Wt(ge[F].length, function(Ne) {
                  return b.def(L, "[", Ne, "]");
                });
                b(p.cond(j.map(function(Ne, Ie) {
                  return Ne + "!==" + $ + "[" + Ie + "]";
                }).join("||")).then(
                  I,
                  ".",
                  H[F],
                  "(",
                  j,
                  ");",
                  j.map(function(Ne, Ie) {
                    return $ + "[" + Ie + "]=" + Ne;
                  }).join(";"),
                  ";"
                ));
              } else {
                L = b.def(v, ".", F);
                var le = p.cond(L, "!==", E, ".", F);
                b(le), F in X ? le(
                  p.cond(L).then(I, ".enable(", X[F], ");").else(I, ".disable(", X[F], ");"),
                  E,
                  ".",
                  F,
                  "=",
                  L,
                  ";"
                ) : le(
                  I,
                  ".",
                  H[F],
                  "(",
                  L,
                  ");",
                  E,
                  ".",
                  F,
                  "=",
                  L,
                  ";"
                );
              }
            }
          }), Object.keys(T.state).length === 0 && b(E, ".dirty=false;"), c(b);
        }
        function Gt(p, c, T, C) {
          var I = p.shared, A = p.current, w = I.current, E = I.gl;
          Ul(Object.keys(T)).forEach(function(v) {
            var b = T[v];
            if (!(C && !C(b))) {
              var g = b.append(p, c);
              if (X[v]) {
                var F = X[v];
                Zn(b) ? g ? c(E, ".enable(", F, ");") : c(E, ".disable(", F, ");") : c(p.cond(g).then(E, ".enable(", F, ");").else(E, ".disable(", F, ");")), c(w, ".", v, "=", g, ";");
              } else if (pt(g)) {
                var L = A[v];
                c(
                  E,
                  ".",
                  H[v],
                  "(",
                  g,
                  ");",
                  g.map(function($, j) {
                    return L + "[" + j + "]=" + $;
                  }).join(";"),
                  ";"
                );
              } else
                c(
                  E,
                  ".",
                  H[v],
                  "(",
                  g,
                  ");",
                  w,
                  ".",
                  v,
                  "=",
                  g,
                  ";"
                );
            }
          });
        }
        function xt(p, c) {
          te && (p.instancing = c.def(
            p.shared.extensions,
            ".angle_instanced_arrays"
          ));
        }
        function Ye(p, c, T, C, I) {
          var A = p.shared, w = p.stats, E = A.current, v = A.timer, b = T.profile;
          function g() {
            return typeof performance > "u" ? "Date.now()" : "performance.now()";
          }
          var F, L;
          function $(Y) {
            F = c.def(), Y(F, "=", g(), ";"), typeof I == "string" ? Y(w, ".count+=", I, ";") : Y(w, ".count++;"), J && (C ? (L = c.def(), Y(L, "=", v, ".getNumPendingQueries();")) : Y(v, ".beginQuery(", w, ");"));
          }
          function j(Y) {
            Y(w, ".cpuTime+=", g(), "-", F, ";"), J && (C ? Y(
              v,
              ".pushScopeStats(",
              L,
              ",",
              v,
              ".getNumPendingQueries(),",
              w,
              ");"
            ) : Y(v, ".endQuery();"));
          }
          function le(Y) {
            var U = c.def(E, ".profile");
            c(E, ".profile=", Y, ";"), c.exit(E, ".profile=", U, ";");
          }
          var Ne;
          if (b) {
            if (Zn(b)) {
              b.enable ? ($(c), j(c.exit), le("true")) : le("false");
              return;
            }
            Ne = b.append(p, c), le(Ne);
          } else
            Ne = c.def(E, ".profile");
          var Ie = p.block();
          $(Ie), c("if(", Ne, "){", Ie, "}");
          var be = p.block();
          j(be), c.exit("if(", Ne, "){", be, "}");
        }
        function Bt(p, c, T, C, I) {
          var A = p.shared;
          function w(v) {
            switch (v) {
              case _o:
              case wo:
              case Co:
                return 2;
              case So:
              case Ao:
              case Po:
                return 3;
              case To:
              case Eo:
              case ko:
                return 4;
              default:
                return 1;
            }
          }
          function E(v, b, g) {
            var F = A.gl, L = c.def(v, ".location"), $ = c.def(A.attributes, "[", L, "]"), j = g.state, le = g.buffer, Ne = [
              g.x,
              g.y,
              g.z,
              g.w
            ], Ie = [
              "buffer",
              "normalized",
              "offset",
              "stride"
            ];
            function be() {
              c(
                "if(!",
                $,
                ".buffer){",
                F,
                ".enableVertexAttribArray(",
                L,
                ");}"
              );
              var U = g.type, Ce;
              if (g.size ? Ce = c.def(g.size, "||", b) : Ce = b, c(
                "if(",
                $,
                ".type!==",
                U,
                "||",
                $,
                ".size!==",
                Ce,
                "||",
                Ie.map(function(Me) {
                  return $ + "." + Me + "!==" + g[Me];
                }).join("||"),
                "){",
                F,
                ".bindBuffer(",
                ji,
                ",",
                le,
                ".buffer);",
                F,
                ".vertexAttribPointer(",
                [
                  L,
                  Ce,
                  U,
                  g.normalized,
                  g.stride,
                  g.offset
                ],
                ");",
                $,
                ".type=",
                U,
                ";",
                $,
                ".size=",
                Ce,
                ";",
                Ie.map(function(Me) {
                  return $ + "." + Me + "=" + g[Me] + ";";
                }).join(""),
                "}"
              ), te) {
                var Ae = g.divisor;
                c(
                  "if(",
                  $,
                  ".divisor!==",
                  Ae,
                  "){",
                  p.instancing,
                  ".vertexAttribDivisorANGLE(",
                  [L, Ae],
                  ");",
                  $,
                  ".divisor=",
                  Ae,
                  ";}"
                );
              }
            }
            function Y() {
              c(
                "if(",
                $,
                ".buffer){",
                F,
                ".disableVertexAttribArray(",
                L,
                ");",
                $,
                ".buffer=null;",
                "}if(",
                $i.map(function(U, Ce) {
                  return $ + "." + U + "!==" + Ne[Ce];
                }).join("||"),
                "){",
                F,
                ".vertexAttrib4f(",
                L,
                ",",
                Ne,
                ");",
                $i.map(function(U, Ce) {
                  return $ + "." + U + "=" + Ne[Ce] + ";";
                }).join(""),
                "}"
              );
            }
            j === Hi ? be() : j === qa ? Y() : (c("if(", j, "===", Hi, "){"), be(), c("}else{"), Y(), c("}"));
          }
          C.forEach(function(v) {
            var b = v.name, g = T.attributes[b], F;
            if (g) {
              if (!I(g))
                return;
              F = g.append(p, c);
            } else {
              if (!I(Vl))
                return;
              var L = p.scopeAttrib(b);
              d.optional(function() {
                p.assert(
                  c,
                  L + ".state",
                  "missing attribute " + b
                );
              }), F = {}, Object.keys(new k()).forEach(function($) {
                F[$] = c.def(L, ".", $);
              });
            }
            E(
              p.link(v),
              w(v.info.type),
              F
            );
          });
        }
        function at(p, c, T, C, I, A) {
          for (var w = p.shared, E = w.gl, v = {}, b, g = 0; g < C.length; ++g) {
            var F = C[g], L = F.name, $ = F.info.type, j = F.info.size, le = T.uniforms[L];
            if (j > 1) {
              if (!le)
                continue;
              var Ne = L.replace("[0]", "");
              if (v[Ne])
                continue;
              v[Ne] = 1;
            }
            var Ie = p.link(F), be = Ie + ".location", Y;
            if (le) {
              if (!I(le))
                continue;
              if (Zn(le)) {
                var U = le.value;
                if (d.command(
                  U !== null && typeof U < "u",
                  'missing uniform "' + L + '"',
                  p.commandStr
                ), $ === xr || $ === br) {
                  d.command(
                    typeof U == "function" && ($ === xr && (U._reglType === "texture2d" || U._reglType === "framebuffer") || $ === br && (U._reglType === "textureCube" || U._reglType === "framebufferCube")),
                    "invalid texture for uniform " + L,
                    p.commandStr
                  );
                  var Ce = p.link(U._texture || U.color[0]._texture);
                  c(E, ".uniform1i(", be, ",", Ce + ".bind());"), c.exit(Ce, ".unbind();");
                } else if ($ === vr || $ === gr || $ === yr) {
                  d.optional(function() {
                    d.command(
                      pt(U),
                      "invalid matrix for uniform " + L,
                      p.commandStr
                    ), d.command(
                      $ === vr && U.length === 4 || $ === gr && U.length === 9 || $ === yr && U.length === 16,
                      "invalid length for matrix uniform " + L,
                      p.commandStr
                    );
                  });
                  var Ae = p.global.def("new Float32Array([" + Array.prototype.slice.call(U) + "])"), Me = 2;
                  $ === gr ? Me = 3 : $ === yr && (Me = 4), c(
                    E,
                    ".uniformMatrix",
                    Me,
                    "fv(",
                    be,
                    ",false,",
                    Ae,
                    ");"
                  );
                } else {
                  switch ($) {
                    case cs:
                      j === 1 ? d.commandType(U, "number", "uniform " + L, p.commandStr) : d.command(
                        pt(U) && U.length === j,
                        "uniform " + L,
                        p.commandStr
                      ), b = "1f";
                      break;
                    case _o:
                      d.command(
                        pt(U) && U.length && U.length % 2 === 0 && U.length <= j * 2,
                        "uniform " + L,
                        p.commandStr
                      ), b = "2f";
                      break;
                    case So:
                      d.command(
                        pt(U) && U.length && U.length % 3 === 0 && U.length <= j * 3,
                        "uniform " + L,
                        p.commandStr
                      ), b = "3f";
                      break;
                    case To:
                      d.command(
                        pt(U) && U.length && U.length % 4 === 0 && U.length <= j * 4,
                        "uniform " + L,
                        p.commandStr
                      ), b = "4f";
                      break;
                    case ds:
                      j === 1 ? d.commandType(U, "boolean", "uniform " + L, p.commandStr) : d.command(
                        pt(U) && U.length === j,
                        "uniform " + L,
                        p.commandStr
                      ), b = "1i";
                      break;
                    case hs:
                      j === 1 ? d.commandType(U, "number", "uniform " + L, p.commandStr) : d.command(
                        pt(U) && U.length === j,
                        "uniform " + L,
                        p.commandStr
                      ), b = "1i";
                      break;
                    case Co:
                      d.command(
                        pt(U) && U.length && U.length % 2 === 0 && U.length <= j * 2,
                        "uniform " + L,
                        p.commandStr
                      ), b = "2i";
                      break;
                    case wo:
                      d.command(
                        pt(U) && U.length && U.length % 2 === 0 && U.length <= j * 2,
                        "uniform " + L,
                        p.commandStr
                      ), b = "2i";
                      break;
                    case Po:
                      d.command(
                        pt(U) && U.length && U.length % 3 === 0 && U.length <= j * 3,
                        "uniform " + L,
                        p.commandStr
                      ), b = "3i";
                      break;
                    case Ao:
                      d.command(
                        pt(U) && U.length && U.length % 3 === 0 && U.length <= j * 3,
                        "uniform " + L,
                        p.commandStr
                      ), b = "3i";
                      break;
                    case ko:
                      d.command(
                        pt(U) && U.length && U.length % 4 === 0 && U.length <= j * 4,
                        "uniform " + L,
                        p.commandStr
                      ), b = "4i";
                      break;
                    case Eo:
                      d.command(
                        pt(U) && U.length && U.length % 4 === 0 && U.length <= j * 4,
                        "uniform " + L,
                        p.commandStr
                      ), b = "4i";
                      break;
                  }
                  j > 1 ? (b += "v", U = p.global.def("[" + Array.prototype.slice.call(U) + "]")) : U = pt(U) ? Array.prototype.slice.call(U) : U, c(
                    E,
                    ".uniform",
                    b,
                    "(",
                    be,
                    ",",
                    U,
                    ");"
                  );
                }
                continue;
              } else
                Y = le.append(p, c);
            } else {
              if (!I(Vl))
                continue;
              Y = c.def(w.uniforms, "[", h.id(L), "]");
            }
            $ === xr ? (d(!Array.isArray(Y), "must specify a scalar prop for textures"), c(
              "if(",
              Y,
              "&&",
              Y,
              '._reglType==="framebuffer"){',
              Y,
              "=",
              Y,
              ".color[0];",
              "}"
            )) : $ === br && (d(!Array.isArray(Y), "must specify a scalar prop for cube maps"), c(
              "if(",
              Y,
              "&&",
              Y,
              '._reglType==="framebufferCube"){',
              Y,
              "=",
              Y,
              ".color[0];",
              "}"
            )), d.optional(function() {
              function en(Qt, Lo) {
                p.assert(
                  c,
                  Qt,
                  'bad data or missing for uniform "' + L + '".  ' + Lo
                );
              }
              function bi(Qt, Lo) {
                Lo === 1 && d(!Array.isArray(Y), "must not specify an array type for uniform"), en(
                  "Array.isArray(" + Y + ") && typeof " + Y + '[0]===" ' + Qt + '" || typeof ' + Y + '==="' + Qt + '"',
                  "invalid type, expected " + Qt
                );
              }
              function sn(Qt, Lo, Do) {
                Array.isArray(Y) ? d(Y.length && Y.length % Qt === 0 && Y.length <= Qt * Do, "must have length of " + (Do === 1 ? "" : "n * ") + Qt) : en(
                  w.isArrayLike + "(" + Y + ")&&" + Y + ".length && " + Y + ".length % " + Qt + " === 0 && " + Y + ".length<=" + Qt * Do,
                  "invalid vector, should have length of " + (Do === 1 ? "" : "n * ") + Qt,
                  p.commandStr
                );
              }
              function Yl(Qt) {
                d(!Array.isArray(Y), "must not specify a value type"), en(
                  "typeof " + Y + '==="function"&&' + Y + '._reglType==="texture' + (Qt === Fl ? "2d" : "Cube") + '"',
                  "invalid texture type",
                  p.commandStr
                );
              }
              switch ($) {
                case hs:
                  bi("number", j);
                  break;
                case wo:
                  sn(2, "number", j);
                  break;
                case Ao:
                  sn(3, "number", j);
                  break;
                case Eo:
                  sn(4, "number", j);
                  break;
                case cs:
                  bi("number", j);
                  break;
                case _o:
                  sn(2, "number", j);
                  break;
                case So:
                  sn(3, "number", j);
                  break;
                case To:
                  sn(4, "number", j);
                  break;
                case ds:
                  bi("boolean", j);
                  break;
                case Co:
                  sn(2, "boolean", j);
                  break;
                case Po:
                  sn(3, "boolean", j);
                  break;
                case ko:
                  sn(4, "boolean", j);
                  break;
                case vr:
                  sn(4, "number", j);
                  break;
                case gr:
                  sn(9, "number", j);
                  break;
                case yr:
                  sn(16, "number", j);
                  break;
                case xr:
                  Yl(Fl);
                  break;
                case br:
                  Yl(Ud);
                  break;
              }
            });
            var ft = 1;
            switch ($) {
              case xr:
              case br:
                var Ut = c.def(Y, "._texture");
                c(E, ".uniform1i(", be, ",", Ut, ".bind());"), c.exit(Ut, ".unbind();");
                continue;
              case hs:
              case ds:
                b = "1i";
                break;
              case wo:
              case Co:
                b = "2i", ft = 2;
                break;
              case Ao:
              case Po:
                b = "3i", ft = 3;
                break;
              case Eo:
              case ko:
                b = "4i", ft = 4;
                break;
              case cs:
                b = "1f";
                break;
              case _o:
                b = "2f", ft = 2;
                break;
              case So:
                b = "3f", ft = 3;
                break;
              case To:
                b = "4f", ft = 4;
                break;
              case vr:
                b = "Matrix2fv";
                break;
              case gr:
                b = "Matrix3fv";
                break;
              case yr:
                b = "Matrix4fv";
                break;
            }
            if (b.indexOf("Matrix") === -1 && j > 1 && (b += "v", ft = 1), b.charAt(0) === "M") {
              c(E, ".uniform", b, "(", be, ",");
              var yi = Math.pow($ - vr + 2, 2), Fn = p.global.def("new Float32Array(", yi, ")");
              Array.isArray(Y) ? c(
                "false,(",
                Wt(yi, function(en) {
                  return Fn + "[" + en + "]=" + Y[en];
                }),
                ",",
                Fn,
                ")"
              ) : c(
                "false,(Array.isArray(",
                Y,
                ")||",
                Y,
                " instanceof Float32Array)?",
                Y,
                ":(",
                Wt(yi, function(en) {
                  return Fn + "[" + en + "]=" + Y + "[" + en + "]";
                }),
                ",",
                Fn,
                ")"
              ), c(");");
            } else if (ft > 1) {
              for (var wn = [], Qn = [], xi = 0; xi < ft; ++xi)
                Array.isArray(Y) ? Qn.push(Y[xi]) : Qn.push(c.def(Y + "[" + xi + "]")), A && wn.push(c.def());
              A && c("if(!", p.batchId, "||", wn.map(function(en, bi) {
                return en + "!==" + Qn[bi];
              }).join("||"), "){", wn.map(function(en, bi) {
                return en + "=" + Qn[bi] + ";";
              }).join("")), c(E, ".uniform", b, "(", be, ",", Qn.join(","), ");"), A && c("}");
            } else {
              if (d(!Array.isArray(Y), "uniform value must not be an array"), A) {
                var ql = c.def();
                c(
                  "if(!",
                  p.batchId,
                  "||",
                  ql,
                  "!==",
                  Y,
                  "){",
                  ql,
                  "=",
                  Y,
                  ";"
                );
              }
              c(E, ".uniform", b, "(", be, ",", Y, ");"), A && c("}");
            }
          }
        }
        function Fe(p, c, T, C) {
          var I = p.shared, A = I.gl, w = I.draw, E = C.draw;
          function v() {
            var Ce = E.elements, Ae, Me = c;
            return Ce ? ((Ce.contextDep && C.contextDynamic || Ce.propDep) && (Me = T), Ae = Ce.append(p, Me), E.elementsActive && Me(
              "if(" + Ae + ")" + A + ".bindBuffer(" + us + "," + Ae + ".buffer.buffer);"
            )) : (Ae = Me.def(), Me(
              Ae,
              "=",
              w,
              ".",
              di,
              ";",
              "if(",
              Ae,
              "){",
              A,
              ".bindBuffer(",
              us,
              ",",
              Ae,
              ".buffer.buffer);}",
              "else if(",
              I.vao,
              ".currentVAO){",
              Ae,
              "=",
              p.shared.elements + ".getElements(" + I.vao,
              ".currentVAO.elements);",
              Z ? "" : "if(" + Ae + ")" + A + ".bindBuffer(" + us + "," + Ae + ".buffer.buffer);",
              "}"
            )), Ae;
          }
          function b() {
            var Ce = E.count, Ae, Me = c;
            return Ce ? ((Ce.contextDep && C.contextDynamic || Ce.propDep) && (Me = T), Ae = Ce.append(p, Me), d.optional(function() {
              Ce.MISSING && p.assert(c, "false", "missing vertex count"), Ce.DYNAMIC && p.assert(Me, Ae + ">=0", "missing vertex count");
            })) : (Ae = Me.def(w, ".", pi), d.optional(function() {
              p.assert(Me, Ae + ">=0", "missing vertex count");
            })), Ae;
          }
          var g = v();
          function F(Ce) {
            var Ae = E[Ce];
            return Ae ? Ae.contextDep && C.contextDynamic || Ae.propDep ? Ae.append(p, T) : Ae.append(p, c) : c.def(w, ".", Ce);
          }
          var L = F(mi), $ = F(xo), j = b();
          if (typeof j == "number") {
            if (j === 0)
              return;
          } else
            T("if(", j, "){"), T.exit("}");
          var le, Ne;
          te && (le = F(bo), Ne = p.instancing);
          var Ie = g + ".type", be = E.elements && Zn(E.elements) && !E.vaoActive;
          function Y() {
            function Ce() {
              T(Ne, ".drawElementsInstancedANGLE(", [
                L,
                j,
                Ie,
                $ + "<<((" + Ie + "-" + hl + ")>>1)",
                le
              ], ");");
            }
            function Ae() {
              T(
                Ne,
                ".drawArraysInstancedANGLE(",
                [L, $, j, le],
                ");"
              );
            }
            g && g !== "null" ? be ? Ce() : (T("if(", g, "){"), Ce(), T("}else{"), Ae(), T("}")) : Ae();
          }
          function U() {
            function Ce() {
              T(A + ".drawElements(" + [
                L,
                j,
                Ie,
                $ + "<<((" + Ie + "-" + hl + ")>>1)"
              ] + ");");
            }
            function Ae() {
              T(A + ".drawArrays(" + [L, $, j] + ");");
            }
            g && g !== "null" ? be ? Ce() : (T("if(", g, "){"), Ce(), T("}else{"), Ae(), T("}")) : Ae();
          }
          te && (typeof le != "number" || le >= 0) ? typeof le == "string" ? (T("if(", le, ">0){"), Y(), T("}else if(", le, "<0){"), U(), T("}")) : Y() : U();
        }
        function et(p, c, T, C, I) {
          var A = Ue(), w = A.proc("body", I);
          return d.optional(function() {
            A.commandStr = c.commandStr, A.command = A.link(c.commandStr);
          }), te && (A.instancing = w.def(
            A.shared.extensions,
            ".angle_instanced_arrays"
          )), p(A, w, T, C), A.compile().body;
        }
        function it(p, c, T, C) {
          xt(p, c), T.useVAO ? T.drawVAO ? c(p.shared.vao, ".setVAO(", T.drawVAO.append(p, c), ");") : c(p.shared.vao, ".setVAO(", p.shared.vao, ".targetVAO);") : (c(p.shared.vao, ".setVAO(null);"), Bt(p, c, T, C.attributes, function() {
            return true;
          })), at(p, c, T, C.uniforms, function() {
            return true;
          }, false), Fe(p, c, c, T);
        }
        function bt(p, c) {
          var T = p.proc("draw", 1);
          xt(p, T), Et(p, T, c.context), Ct(p, T, c.framebuffer), Ft(p, T, c), Gt(p, T, c.state), Ye(p, T, c, false, true);
          var C = c.shader.progVar.append(p, T);
          if (T(p.shared.gl, ".useProgram(", C, ".program);"), c.shader.program)
            it(p, T, c, c.shader.program);
          else {
            T(p.shared.vao, ".setVAO(null);");
            var I = p.global.def("{}"), A = T.def(C, ".id"), w = T.def(I, "[", A, "]");
            T(
              p.cond(w).then(w, ".call(this,a0);").else(
                w,
                "=",
                I,
                "[",
                A,
                "]=",
                p.link(function(E) {
                  return et(it, p, c, E, 1);
                }),
                "(",
                C,
                ");",
                w,
                ".call(this,a0);"
              )
            );
          }
          Object.keys(c.state).length > 0 && T(p.shared.current, ".dirty=true;"), p.shared.vao && T(p.shared.vao, ".setVAO(null);");
        }
        function Tn(p, c, T, C) {
          p.batchId = "a1", xt(p, c);
          function I() {
            return true;
          }
          Bt(p, c, T, C.attributes, I), at(p, c, T, C.uniforms, I, false), Fe(p, c, c, T);
        }
        function gi(p, c, T, C) {
          xt(p, c);
          var I = T.contextDep, A = c.def(), w = "a0", E = "a1", v = c.def();
          p.shared.props = v, p.batchId = A;
          var b = p.scope(), g = p.scope();
          c(
            b.entry,
            "for(",
            A,
            "=0;",
            A,
            "<",
            E,
            ";++",
            A,
            "){",
            v,
            "=",
            w,
            "[",
            A,
            "];",
            g,
            "}",
            b.exit
          );
          function F(Ie) {
            return Ie.contextDep && I || Ie.propDep;
          }
          function L(Ie) {
            return !F(Ie);
          }
          if (T.needsContext && Et(p, g, T.context), T.needsFramebuffer && Ct(p, g, T.framebuffer), Gt(p, g, T.state, F), T.profile && F(T.profile) && Ye(p, g, T, false, true), C)
            T.useVAO ? T.drawVAO ? F(T.drawVAO) ? g(p.shared.vao, ".setVAO(", T.drawVAO.append(p, g), ");") : b(p.shared.vao, ".setVAO(", T.drawVAO.append(p, b), ");") : b(p.shared.vao, ".setVAO(", p.shared.vao, ".targetVAO);") : (b(p.shared.vao, ".setVAO(null);"), Bt(p, b, T, C.attributes, L), Bt(p, g, T, C.attributes, F)), at(p, b, T, C.uniforms, L, false), at(p, g, T, C.uniforms, F, true), Fe(p, b, g, T);
          else {
            var $ = p.global.def("{}"), j = T.shader.progVar.append(p, g), le = g.def(j, ".id"), Ne = g.def($, "[", le, "]");
            g(
              p.shared.gl,
              ".useProgram(",
              j,
              ".program);",
              "if(!",
              Ne,
              "){",
              Ne,
              "=",
              $,
              "[",
              le,
              "]=",
              p.link(function(Ie) {
                return et(
                  Tn,
                  p,
                  T,
                  Ie,
                  2
                );
              }),
              "(",
              j,
              ");}",
              Ne,
              ".call(this,a0[",
              A,
              "],",
              A,
              ");"
            );
          }
        }
        function x(p, c) {
          var T = p.proc("batch", 2);
          p.batchId = "0", xt(p, T);
          var C = false, I = true;
          Object.keys(c.context).forEach(function($) {
            C = C || c.context[$].propDep;
          }), C || (Et(p, T, c.context), I = false);
          var A = c.framebuffer, w = false;
          A ? (A.propDep ? C = w = true : A.contextDep && C && (w = true), w || Ct(p, T, A)) : Ct(p, T, null), c.state.viewport && c.state.viewport.propDep && (C = true);
          function E($) {
            return $.contextDep && C || $.propDep;
          }
          Ft(p, T, c), Gt(p, T, c.state, function($) {
            return !E($);
          }), (!c.profile || !E(c.profile)) && Ye(p, T, c, false, "a1"), c.contextDep = C, c.needsContext = I, c.needsFramebuffer = w;
          var v = c.shader.progVar;
          if (v.contextDep && C || v.propDep)
            gi(
              p,
              T,
              c,
              null
            );
          else {
            var b = v.append(p, T);
            if (T(p.shared.gl, ".useProgram(", b, ".program);"), c.shader.program)
              gi(
                p,
                T,
                c,
                c.shader.program
              );
            else {
              T(p.shared.vao, ".setVAO(null);");
              var g = p.global.def("{}"), F = T.def(b, ".id"), L = T.def(g, "[", F, "]");
              T(
                p.cond(L).then(L, ".call(this,a0,a1);").else(
                  L,
                  "=",
                  g,
                  "[",
                  F,
                  "]=",
                  p.link(function($) {
                    return et(gi, p, c, $, 2);
                  }),
                  "(",
                  b,
                  ");",
                  L,
                  ".call(this,a0,a1);"
                )
              );
            }
          }
          Object.keys(c.state).length > 0 && T(p.shared.current, ".dirty=true;"), p.shared.vao && T(p.shared.vao, ".setVAO(null);");
        }
        function O(p, c) {
          var T = p.proc("scope", 3);
          p.batchId = "a2";
          var C = p.shared, I = C.current;
          Et(p, T, c.context), c.framebuffer && c.framebuffer.append(p, T), Ul(Object.keys(c.state)).forEach(function(w) {
            var E = c.state[w], v = E.append(p, T);
            pt(v) ? v.forEach(function(b, g) {
              T.set(p.next[w], "[" + g + "]", b);
            }) : T.set(C.next, "." + w, v);
          }), Ye(p, T, c, true, true), [di, xo, pi, bo, mi].forEach(
            function(w) {
              var E = c.draw[w];
              E && T.set(C.draw, "." + w, "" + E.append(p, T));
            }
          ), Object.keys(c.uniforms).forEach(function(w) {
            var E = c.uniforms[w].append(p, T);
            Array.isArray(E) && (E = "[" + E.join() + "]"), T.set(
              C.uniforms,
              "[" + h.id(w) + "]",
              E
            );
          }), Object.keys(c.attributes).forEach(function(w) {
            var E = c.attributes[w].append(p, T), v = p.scopeAttrib(w);
            Object.keys(new k()).forEach(function(b) {
              T.set(v, "." + b, E[b]);
            });
          }), c.scopeVAO && T.set(C.vao, ".targetVAO", c.scopeVAO.append(p, T));
          function A(w) {
            var E = c.shader[w];
            E && T.set(C.shader, "." + w, E.append(p, T));
          }
          A(dr), A(mr), Object.keys(c.state).length > 0 && (T(I, ".dirty=true;"), T.exit(I, ".dirty=true;")), T("a1(", p.shared.context, ",a0,", p.batchId, ");");
        }
        function z(p) {
          if (!(typeof p != "object" || pt(p))) {
            for (var c = Object.keys(p), T = 0; T < c.length; ++T)
              if (kt.isDynamic(p[c[T]]))
                return true;
            return false;
          }
        }
        function _e(p, c, T) {
          var C = c.static[T];
          if (!C || !z(C))
            return;
          var I = p.global, A = Object.keys(C), w = false, E = false, v = false, b = p.global.def("{}");
          A.forEach(function(F) {
            var L = C[F];
            if (kt.isDynamic(L)) {
              typeof L == "function" && (L = C[F] = kt.unbox(L));
              var $ = Zt(L, null);
              w = w || $.thisDep, v = v || $.propDep, E = E || $.contextDep;
            } else {
              switch (I(b, ".", F, "="), typeof L) {
                case "number":
                  I(L);
                  break;
                case "string":
                  I('"', L, '"');
                  break;
                case "object":
                  Array.isArray(L) && I("[", L.join(), "]");
                  break;
                default:
                  I(p.link(L));
                  break;
              }
              I(";");
            }
          });
          function g(F, L) {
            A.forEach(function($) {
              var j = C[$];
              if (kt.isDynamic(j)) {
                var le = F.invoke(L, j);
                L(b, ".", $, "=", le, ";");
              }
            });
          }
          c.dynamic[T] = new kt.DynamicVariable(go, {
            thisDep: w,
            contextDep: E,
            propDep: v,
            ref: b,
            append: g
          }), delete c.static[T];
        }
        function Ke(p, c, T, C, I) {
          var A = Ue();
          A.stats = A.link(I), Object.keys(c.static).forEach(function(E) {
            _e(A, c, E);
          }), Nd.forEach(function(E) {
            _e(A, p, E);
          });
          var w = Tt(p, c, T, C, A);
          return bt(A, w), O(A, w), x(A, w), i(A.compile(), {
            destroy: function() {
              w.shader.program.destroy();
            }
          });
        }
        return {
          next: me,
          current: ge,
          procs: (function() {
            var p = Ue(), c = p.proc("poll"), T = p.proc("refresh"), C = p.block();
            c(C), T(C);
            var I = p.shared, A = I.gl, w = I.next, E = I.current;
            C(E, ".dirty=false;"), Ct(p, c), Ct(p, T, null, true);
            var v;
            te && (v = p.link(te)), _.oes_vertex_array_object && T(p.link(_.oes_vertex_array_object), ".bindVertexArrayOES(null);");
            for (var b = 0; b < M.maxAttributes; ++b) {
              var g = T.def(I.attributes, "[", b, "]"), F = p.cond(g, ".buffer");
              F.then(
                A,
                ".enableVertexAttribArray(",
                b,
                ");",
                A,
                ".bindBuffer(",
                ji,
                ",",
                g,
                ".buffer.buffer);",
                A,
                ".vertexAttribPointer(",
                b,
                ",",
                g,
                ".size,",
                g,
                ".type,",
                g,
                ".normalized,",
                g,
                ".stride,",
                g,
                ".offset);"
              ).else(
                A,
                ".disableVertexAttribArray(",
                b,
                ");",
                A,
                ".vertexAttrib4f(",
                b,
                ",",
                g,
                ".x,",
                g,
                ".y,",
                g,
                ".z,",
                g,
                ".w);",
                g,
                ".buffer=null;"
              ), T(F), te && T(
                v,
                ".vertexAttribDivisorANGLE(",
                b,
                ",",
                g,
                ".divisor);"
              );
            }
            return T(
              p.shared.vao,
              ".currentVAO=null;",
              p.shared.vao,
              ".setVAO(",
              p.shared.vao,
              ".targetVAO);"
            ), Object.keys(X).forEach(function(L) {
              var $ = X[L], j = C.def(w, ".", L), le = p.block();
              le(
                "if(",
                j,
                "){",
                A,
                ".enable(",
                $,
                ")}else{",
                A,
                ".disable(",
                $,
                ")}",
                E,
                ".",
                L,
                "=",
                j,
                ";"
              ), T(le), c(
                "if(",
                j,
                "!==",
                E,
                ".",
                L,
                "){",
                le,
                "}"
              );
            }), Object.keys(H).forEach(function(L) {
              var $ = H[L], j = ge[L], le, Ne, Ie = p.block();
              if (Ie(A, ".", $, "("), pt(j)) {
                var be = j.length;
                le = p.global.def(w, ".", L), Ne = p.global.def(E, ".", L), Ie(
                  Wt(be, function(Y) {
                    return le + "[" + Y + "]";
                  }),
                  ");",
                  Wt(be, function(Y) {
                    return Ne + "[" + Y + "]=" + le + "[" + Y + "];";
                  }).join("")
                ), c(
                  "if(",
                  Wt(be, function(Y) {
                    return le + "[" + Y + "]!==" + Ne + "[" + Y + "]";
                  }).join("||"),
                  "){",
                  Ie,
                  "}"
                );
              } else
                le = C.def(w, ".", L), Ne = C.def(E, ".", L), Ie(
                  le,
                  ");",
                  E,
                  ".",
                  L,
                  "=",
                  le,
                  ";"
                ), c(
                  "if(",
                  le,
                  "!==",
                  Ne,
                  "){",
                  Ie,
                  "}"
                );
              T(Ie);
            }), p.compile();
          })(),
          compile: Ke
        };
      }
      function im() {
        return {
          vaoCount: 0,
          bufferCount: 0,
          elementsCount: 0,
          framebufferCount: 0,
          shaderCount: 0,
          textureCount: 0,
          cubeCount: 0,
          renderbufferCount: 0,
          maxTextureUnits: 0
        };
      }
      var rm = 34918, om = 34919, $l = 35007, am = function(a, h) {
        if (!h.ext_disjoint_timer_query)
          return null;
        var _ = [];
        function M() {
          return _.pop() || h.ext_disjoint_timer_query.createQueryEXT();
        }
        function W(te) {
          _.push(te);
        }
        var R = [];
        function B(te) {
          var xe = M();
          h.ext_disjoint_timer_query.beginQueryEXT($l, xe), R.push(xe), J(R.length - 1, R.length, te);
        }
        function K() {
          h.ext_disjoint_timer_query.endQueryEXT($l);
        }
        function Q() {
          this.startQueryIndex = -1, this.endQueryIndex = -1, this.sum = 0, this.stats = null;
        }
        var re = [];
        function ae() {
          return re.pop() || new Q();
        }
        function oe(te) {
          re.push(te);
        }
        var ue = [];
        function J(te, xe, Z) {
          var ge = ae();
          ge.startQueryIndex = te, ge.endQueryIndex = xe, ge.sum = 0, ge.stats = Z, ue.push(ge);
        }
        var ne = [], k = [];
        function G() {
          var te, xe, Z = R.length;
          if (Z !== 0) {
            k.length = Math.max(k.length, Z + 1), ne.length = Math.max(ne.length, Z + 1), ne[0] = 0, k[0] = 0;
            var ge = 0;
            for (te = 0, xe = 0; xe < R.length; ++xe) {
              var me = R[xe];
              h.ext_disjoint_timer_query.getQueryObjectEXT(me, om) ? (ge += h.ext_disjoint_timer_query.getQueryObjectEXT(me, rm), W(me)) : R[te++] = me, ne[xe + 1] = ge, k[xe + 1] = te;
            }
            for (R.length = te, te = 0, xe = 0; xe < ue.length; ++xe) {
              var De = ue[xe], X = De.startQueryIndex, H = De.endQueryIndex;
              De.sum += ne[H] - ne[X];
              var Se = k[X], ce = k[H];
              ce === Se ? (De.stats.gpuTime += De.sum / 1e6, oe(De)) : (De.startQueryIndex = Se, De.endQueryIndex = ce, ue[te++] = De);
            }
            ue.length = te;
          }
        }
        return {
          beginQuery: B,
          endQuery: K,
          pushScopeStats: J,
          update: G,
          getNumPendingQueries: function() {
            return R.length;
          },
          clear: function() {
            _.push.apply(_, R);
            for (var te = 0; te < _.length; te++)
              h.ext_disjoint_timer_query.deleteQueryEXT(_[te]);
            R.length = 0, _.length = 0;
          },
          restore: function() {
            R.length = 0, _.length = 0;
          }
        };
      }, sm = 16384, fm = 256, lm = 1024, um = 34962, Hl = "webglcontextlost", Wl = "webglcontextrestored", Xl = 1, cm = 2, hm = 3;
      function jl(a, h) {
        for (var _ = 0; _ < a.length; ++_)
          if (a[_] === h)
            return _;
        return -1;
      }
      function dm(a) {
        var h = It(a);
        if (!h)
          return null;
        var _ = h.gl, M = _.getContextAttributes(), W = _.isContextLost(), R = $n(_, h);
        if (!R)
          return null;
        var B = ga(), K = im(), Q = R.extensions, re = am(_, Q), ae = Ii(), oe = _.drawingBufferWidth, ue = _.drawingBufferHeight, J = {
          tick: 0,
          time: 0,
          viewportWidth: oe,
          viewportHeight: ue,
          framebufferWidth: oe,
          framebufferHeight: ue,
          drawingBufferWidth: oe,
          drawingBufferHeight: ue,
          pixelRatio: h.pixelRatio
        }, ne = {}, k = {
          elements: null,
          primitive: 4,
          // GL_TRIANGLES
          count: -1,
          offset: 0,
          instances: -1
        }, G = Jc(_, Q), te = ph(
          _,
          K,
          h,
          ge
        ), xe = Ch(_, Q, te, K), Z = Cd(
          _,
          Q,
          G,
          K,
          te,
          xe,
          k
        );
        function ge(Fe) {
          return Z.destroyBuffer(Fe);
        }
        var me = Ld(_, B, K, h), De = rd(
          _,
          Q,
          G,
          function() {
            Se.procs.poll();
          },
          J,
          K,
          h
        ), X = od(_, Q, G, K, h), H = Ad(
          _,
          Q,
          G,
          De,
          X,
          K
        ), Se = nm(
          _,
          B,
          Q,
          G,
          te,
          xe,
          De,
          H,
          ne,
          Z,
          me,
          k,
          J,
          re,
          h
        ), ce = zd(
          _,
          H,
          Se.procs.poll,
          J,
          M,
          Q,
          G
        ), ee = Se.next, he = _.canvas, de = [], He = [], Ue = [], pe = [h.onDestroy], ye = null;
        function Re() {
          if (de.length === 0) {
            re && re.update(), ye = null;
            return;
          }
          ye = ri.next(Re), Gt();
          for (var Fe = de.length - 1; Fe >= 0; --Fe) {
            var et = de[Fe];
            et && et(J, null, 0);
          }
          _.flush(), re && re.update();
        }
        function We() {
          !ye && de.length > 0 && (ye = ri.next(Re));
        }
        function Je() {
          ye && (ri.cancel(Re), ye = null);
        }
        function vt(Fe) {
          Fe.preventDefault(), W = true, Je(), He.forEach(function(et) {
            et();
          });
        }
        function yt(Fe) {
          _.getError(), W = false, R.restore(), me.restore(), te.restore(), De.restore(), X.restore(), H.restore(), Z.restore(), re && re.restore(), Se.procs.refresh(), We(), Ue.forEach(function(et) {
            et();
          });
        }
        he && (he.addEventListener(Hl, vt, false), he.addEventListener(Wl, yt, false));
        function tt() {
          de.length = 0, Je(), he && (he.removeEventListener(Hl, vt), he.removeEventListener(Wl, yt)), me.clear(), H.clear(), X.clear(), Z.clear(), De.clear(), xe.clear(), te.clear(), re && re.clear(), pe.forEach(function(Fe) {
            Fe();
          });
        }
        function At(Fe) {
          d(!!Fe, "invalid args to regl({...})"), d.type(Fe, "object", "invalid args to regl({...})");
          function et(I) {
            var A = i({}, I);
            delete A.uniforms, delete A.attributes, delete A.context, delete A.vao, "stencil" in A && A.stencil.op && (A.stencil.opBack = A.stencil.opFront = A.stencil.op, delete A.stencil.op);
            function w(E) {
              if (E in A) {
                var v = A[E];
                delete A[E], Object.keys(v).forEach(function(b) {
                  A[E + "." + b] = v[b];
                });
              }
            }
            return w("blend"), w("depth"), w("cull"), w("stencil"), w("polygonOffset"), w("scissor"), w("sample"), "vao" in I && (A.vao = I.vao), A;
          }
          function it(I, A) {
            var w = {}, E = {};
            return Object.keys(I).forEach(function(v) {
              var b = I[v];
              if (kt.isDynamic(b)) {
                E[v] = kt.unbox(b, v);
                return;
              } else if (A && Array.isArray(b)) {
                for (var g = 0; g < b.length; ++g)
                  if (kt.isDynamic(b[g])) {
                    E[v] = kt.unbox(b, v);
                    return;
                  }
              }
              w[v] = b;
            }), {
              dynamic: E,
              static: w
            };
          }
          var bt = it(Fe.context || {}, true), Tn = it(Fe.uniforms || {}, true), gi = it(Fe.attributes || {}, false), x = it(et(Fe), false), O = {
            gpuTime: 0,
            cpuTime: 0,
            count: 0
          }, z = Se.compile(x, gi, Tn, bt, O), _e = z.draw, Ke = z.batch, p = z.scope, c = [];
          function T(I) {
            for (; c.length < I; )
              c.push(null);
            return c;
          }
          function C(I, A) {
            var w;
            if (W && d.raise("context lost"), typeof I == "function")
              return p.call(this, null, I, 0);
            if (typeof A == "function")
              if (typeof I == "number")
                for (w = 0; w < I; ++w)
                  p.call(this, null, A, w);
              else if (Array.isArray(I))
                for (w = 0; w < I.length; ++w)
                  p.call(this, I[w], A, w);
              else
                return p.call(this, I, A, 0);
            else if (typeof I == "number") {
              if (I > 0)
                return Ke.call(this, T(I | 0), I | 0);
            } else if (Array.isArray(I)) {
              if (I.length)
                return Ke.call(this, I, I.length);
            } else
              return _e.call(this, I);
          }
          return i(C, {
            stats: O,
            destroy: function() {
              z.destroy();
            }
          });
        }
        var ht = H.setFBO = At({
          framebuffer: kt.define.call(null, Xl, "framebuffer")
        });
        function Tt(Fe, et) {
          var it = 0;
          Se.procs.poll();
          var bt = et.color;
          bt && (_.clearColor(+bt[0] || 0, +bt[1] || 0, +bt[2] || 0, +bt[3] || 0), it |= sm), "depth" in et && (_.clearDepth(+et.depth), it |= fm), "stencil" in et && (_.clearStencil(et.stencil | 0), it |= lm), d(!!it, "called regl.clear with no buffer specified"), _.clear(it);
        }
        function Et(Fe) {
          if (d(
            typeof Fe == "object" && Fe,
            "regl.clear() takes an object as input"
          ), "framebuffer" in Fe)
            if (Fe.framebuffer && Fe.framebuffer_reglType === "framebufferCube")
              for (var et = 0; et < 6; ++et)
                ht(i({
                  framebuffer: Fe.framebuffer.faces[et]
                }, Fe), Tt);
            else
              ht(Fe, Tt);
          else
            Tt(null, Fe);
        }
        function Ct(Fe) {
          d.type(Fe, "function", "regl.frame() callback must be a function"), de.push(Fe);
          function et() {
            var it = jl(de, Fe);
            d(it >= 0, "cannot cancel a frame twice");
            function bt() {
              var Tn = jl(de, bt);
              de[Tn] = de[de.length - 1], de.length -= 1, de.length <= 0 && Je();
            }
            de[it] = bt;
          }
          return We(), {
            cancel: et
          };
        }
        function Ft() {
          var Fe = ee.viewport, et = ee.scissor_box;
          Fe[0] = Fe[1] = et[0] = et[1] = 0, J.viewportWidth = J.framebufferWidth = J.drawingBufferWidth = Fe[2] = et[2] = _.drawingBufferWidth, J.viewportHeight = J.framebufferHeight = J.drawingBufferHeight = Fe[3] = et[3] = _.drawingBufferHeight;
        }
        function Gt() {
          J.tick += 1, J.time = Ye(), Ft(), Se.procs.poll();
        }
        function xt() {
          De.refresh(), Ft(), Se.procs.refresh(), re && re.update();
        }
        function Ye() {
          return (Ii() - ae) / 1e3;
        }
        xt();
        function Bt(Fe, et) {
          d.type(et, "function", "listener callback must be a function");
          var it;
          switch (Fe) {
            case "frame":
              return Ct(et);
            case "lost":
              it = He;
              break;
            case "restore":
              it = Ue;
              break;
            case "destroy":
              it = pe;
              break;
            default:
              d.raise("invalid event, must be one of frame,lost,restore,destroy");
          }
          return it.push(et), {
            cancel: function() {
              for (var bt = 0; bt < it.length; ++bt)
                if (it[bt] === et) {
                  it[bt] = it[it.length - 1], it.pop();
                  return;
                }
            }
          };
        }
        var at = i(At, {
          // Clear current FBO
          clear: Et,
          // Short cuts for dynamic variables
          prop: kt.define.bind(null, Xl),
          context: kt.define.bind(null, cm),
          this: kt.define.bind(null, hm),
          // executes an empty draw command
          draw: At({}),
          // Resources
          buffer: function(Fe) {
            return te.create(Fe, um, false, false);
          },
          elements: function(Fe) {
            return xe.create(Fe, false);
          },
          texture: De.create2D,
          cube: De.createCube,
          renderbuffer: X.create,
          framebuffer: H.create,
          framebufferCube: H.createCube,
          vao: Z.createVAO,
          // Expose context attributes
          attributes: M,
          // Frame rendering
          frame: Ct,
          on: Bt,
          // System limits
          limits: G,
          hasExtension: function(Fe) {
            return G.extensions.indexOf(Fe.toLowerCase()) >= 0;
          },
          // Read pixels
          read: ce,
          // Destroy regl and all associated resources
          destroy: tt,
          // Direct GL state manipulation
          _gl: _,
          _refresh: xt,
          poll: function() {
            Gt(), re && re.update();
          },
          // Current time
          now: Ye,
          // regl Statistics Information
          stats: K
        });
        return h.onDone(null, at), at;
      }
      return dm;
    });
  })(Wo)), Wo.exports;
}
var Hv = $v();
var Wv = nf(Hv);
var Xv = "#b3b3b3";
var jv = void 0;
var Rs = void 0;
var qv = 1;
var Yv = 4;
var Zv = "#666666";
var Qv = 0.1;
var Kv = 1;
var Jv = 1;
var yc = "#222222";
var Ge = {
  enableSimulation: true,
  spaceSize: 8192,
  pointSizeScale: 1,
  linkWidthScale: 1,
  linkArrowsSizeScale: 1,
  renderLinks: true,
  curvedLinks: false,
  curvedLinkSegments: 19,
  curvedLinkWeight: 0.8,
  curvedLinkControlPointDistance: 0.5,
  linkArrows: false,
  linkVisibilityDistanceRange: [50, 150],
  linkVisibilityMinTransparency: 0.25,
  hoveredPointCursor: "auto",
  hoveredLinkCursor: "auto",
  renderHoveredPointRing: false,
  hoveredPointRingColor: "white",
  hoveredLinkColor: void 0,
  hoveredLinkWidthIncrease: 5,
  focusedPointRingColor: "white",
  focusedPointIndex: void 0,
  useClassicQuadtree: false,
  simulation: {
    decay: 5e3,
    gravity: 0.25,
    center: 0,
    repulsion: 1,
    repulsionTheta: 1.15,
    repulsionQuadtreeLevels: 12,
    linkSpring: 1,
    linkDistance: 10,
    linkDistRandomVariationRange: [1, 1.2],
    repulsionFromMouse: 2,
    friction: 0.85,
    cluster: 0.1
  },
  showFPSMonitor: false,
  pixelRatio: 2,
  scalePointsOnZoom: false,
  scaleLinksOnZoom: false,
  enableZoom: true,
  enableSimulationDuringZoom: false,
  enableDrag: false,
  fitViewOnInit: true,
  fitViewDelay: 250,
  fitViewPadding: 0.1,
  fitViewDuration: 250,
  pointSamplingDistance: 150,
  attribution: "",
  rescalePositions: void 0,
  enableRightClickRepulsion: false
};
var eg = 0.7;
var tg = 0.95;
var ng = 3;
var {
  entries: xc,
  setPrototypeOf: du,
  isFrozen: ig,
  getPrototypeOf: rg,
  getOwnPropertyDescriptor: og
} = Object;
var {
  freeze: jt,
  seal: ln,
  create: bc
} = Object;
var {
  apply: Ms,
  construct: Os
} = typeof Reflect < "u" && Reflect;
jt || (jt = function(e) {
  return e;
});
ln || (ln = function(e) {
  return e;
});
Ms || (Ms = function(e, n, i) {
  return e.apply(n, i);
});
Os || (Os = function(e, n) {
  return new e(...n);
});
var Mo = qt(Array.prototype.forEach);
var ag = qt(Array.prototype.lastIndexOf);
var mu = qt(Array.prototype.pop);
var Tr = qt(Array.prototype.push);
var sg = qt(Array.prototype.splice);
var Xo = qt(String.prototype.toLowerCase);
var xs = qt(String.prototype.toString);
var pu = qt(String.prototype.match);
var wr = qt(String.prototype.replace);
var fg = qt(String.prototype.indexOf);
var lg = qt(String.prototype.trim);
var mn = qt(Object.prototype.hasOwnProperty);
var Xt = qt(RegExp.prototype.test);
var Ar = ug(TypeError);
function qt(t3) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)
      i[r - 1] = arguments[r];
    return Ms(t3, e, i);
  };
}
function ug(t3) {
  return function() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++)
      n[i] = arguments[i];
    return Os(t3, n);
  };
}
function ot(t3, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Xo;
  du && du(t3, null);
  let i = e.length;
  for (; i--; ) {
    let r = e[i];
    if (typeof r == "string") {
      const o = n(r);
      o !== r && (ig(e) || (e[i] = o), r = o);
    }
    t3[r] = true;
  }
  return t3;
}
function cg(t3) {
  for (let e = 0; e < t3.length; e++)
    mn(t3, e) || (t3[e] = null);
  return t3;
}
function Rn(t3) {
  const e = bc(null);
  for (const [n, i] of xc(t3))
    mn(t3, n) && (Array.isArray(i) ? e[n] = cg(i) : i && typeof i == "object" && i.constructor === Object ? e[n] = Rn(i) : e[n] = i);
  return e;
}
function Er(t3, e) {
  for (; t3 !== null; ) {
    const i = og(t3, e);
    if (i) {
      if (i.get)
        return qt(i.get);
      if (typeof i.value == "function")
        return qt(i.value);
    }
    t3 = rg(t3);
  }
  function n() {
    return null;
  }
  return n;
}
var vu = jt(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var bs = jt(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var _s = jt(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var hg = jt(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var Ss = jt(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var dg = jt(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var gu = jt(["#text"]);
var yu = jt(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var Ts = jt(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var xu = jt(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var Oo = jt(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var mg = ln(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var pg = ln(/<%[\w\W]*|[\w\W]*%>/gm);
var vg = ln(/\$\{[\w\W]*/gm);
var gg = ln(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var yg = ln(/^aria-[\-\w]+$/);
var _c = ln(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var xg = ln(/^(?:\w+script|data):/i);
var bg = ln(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var Sc = ln(/^html$/i);
var _g = ln(/^[a-z][.\w]*(-[.\w]+)+$/i);
var bu = Object.freeze({
  __proto__: null,
  ARIA_ATTR: yg,
  ATTR_WHITESPACE: bg,
  CUSTOM_ELEMENT: _g,
  DATA_ATTR: gg,
  DOCTYPE_NAME: Sc,
  ERB_EXPR: pg,
  IS_ALLOWED_URI: _c,
  IS_SCRIPT_OR_DATA: xg,
  MUSTACHE_EXPR: mg,
  TMPLIT_EXPR: vg
});
var Cr = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
};
var Sg = function() {
  return typeof window > "u" ? null : window;
};
var Tg = function(e, n) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let i = null;
  const r = "data-tt-policy-suffix";
  n && n.hasAttribute(r) && (i = n.getAttribute(r));
  const o = "dompurify" + (i ? "#" + i : "");
  try {
    return e.createPolicy(o, {
      createHTML(s) {
        return s;
      },
      createScriptURL(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + o + " could not be created."), null;
  }
};
var _u = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function Tc() {
  let t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Sg();
  const e = ($e) => Tc($e);
  if (e.version = "3.2.6", e.removed = [], !t3 || !t3.document || t3.document.nodeType !== Cr.document || !t3.Element)
    return e.isSupported = false, e;
  let {
    document: n
  } = t3;
  const i = n, r = i.currentScript, {
    DocumentFragment: o,
    HTMLTemplateElement: s,
    Node: f,
    Element: l,
    NodeFilter: u,
    NamedNodeMap: m = t3.NamedNodeMap || t3.MozNamedAttrMap,
    HTMLFormElement: y,
    DOMParser: S,
    trustedTypes: D
  } = t3, q = l.prototype, Te = Er(q, "cloneNode"), we = Er(q, "remove"), fe = Er(q, "nextSibling"), Oe = Er(q, "childNodes"), Ve = Er(q, "parentNode");
  if (typeof s == "function") {
    const $e = n.createElement("template");
    $e.content && $e.content.ownerDocument && (n = $e.content.ownerDocument);
  }
  let V, se = "";
  const {
    implementation: Le,
    createNodeIterator: Be,
    createDocumentFragment: Xe,
    getElementsByTagName: nt
  } = n, {
    importNode: lt
  } = i;
  let Ee = _u();
  e.isSupported = typeof xc == "function" && typeof Ve == "function" && Le && Le.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: ut,
    ERB_EXPR: rt,
    TMPLIT_EXPR: N,
    DATA_ATTR: Pe,
    ARIA_ATTR: ie,
    IS_SCRIPT_OR_DATA: ke,
    ATTR_WHITESPACE: qe,
    CUSTOM_ELEMENT: je
  } = bu;
  let {
    IS_ALLOWED_URI: Qe
  } = bu, Ze = null;
  const dt = ot({}, [...vu, ...bs, ..._s, ...Ss, ...gu]);
  let ct = null;
  const _t = ot({}, [...yu, ...Ts, ...xu, ...Oo]);
  let st = Object.seal(bc(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  })), Vt = null, $t = null, Yt = true, Pn = true, Nr = false, Gr = true, kn = false, ei = true, xn = false, Ei = false, Ci = false, Bn = false, Rt = false, ti = false, ni = true, Br = false;
  const va = "user-content-";
  let d = true, ii = false, Un = {}, Vn = null;
  const Ur = ot({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let bn = null;
  const er = ot({}, ["audio", "video", "img", "source", "image", "track"]);
  let In = null;
  const tr = ot({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Pi = "http://www.w3.org/1998/Math/MathML", ki = "http://www.w3.org/2000/svg", rn = "http://www.w3.org/1999/xhtml";
  let kt = rn, ri = false, Ii = null;
  const ga = ot({}, [Pi, ki, rn], xs);
  let Li = ot({}, ["mi", "mo", "mn", "ms", "mtext"]), Di = ot({}, ["annotation-xml"]);
  const ya = ot({}, ["title", "style", "font", "a", "script"]);
  let oi = null;
  const Vr = ["application/xhtml+xml", "text/html"], $r = "text/html";
  let It = null, $n = null;
  const Wt = n.createElement("form"), Hr = function(P) {
    return P instanceof RegExp || P instanceof Function;
  }, nr = function() {
    let P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!($n && $n === P)) {
      if ((!P || typeof P != "object") && (P = {}), P = Rn(P), oi = // eslint-disable-next-line unicorn/prefer-includes
      Vr.indexOf(P.PARSER_MEDIA_TYPE) === -1 ? $r : P.PARSER_MEDIA_TYPE, It = oi === "application/xhtml+xml" ? xs : Xo, Ze = mn(P, "ALLOWED_TAGS") ? ot({}, P.ALLOWED_TAGS, It) : dt, ct = mn(P, "ALLOWED_ATTR") ? ot({}, P.ALLOWED_ATTR, It) : _t, Ii = mn(P, "ALLOWED_NAMESPACES") ? ot({}, P.ALLOWED_NAMESPACES, xs) : ga, In = mn(P, "ADD_URI_SAFE_ATTR") ? ot(Rn(tr), P.ADD_URI_SAFE_ATTR, It) : tr, bn = mn(P, "ADD_DATA_URI_TAGS") ? ot(Rn(er), P.ADD_DATA_URI_TAGS, It) : er, Vn = mn(P, "FORBID_CONTENTS") ? ot({}, P.FORBID_CONTENTS, It) : Ur, Vt = mn(P, "FORBID_TAGS") ? ot({}, P.FORBID_TAGS, It) : Rn({}), $t = mn(P, "FORBID_ATTR") ? ot({}, P.FORBID_ATTR, It) : Rn({}), Un = mn(P, "USE_PROFILES") ? P.USE_PROFILES : false, Yt = P.ALLOW_ARIA_ATTR !== false, Pn = P.ALLOW_DATA_ATTR !== false, Nr = P.ALLOW_UNKNOWN_PROTOCOLS || false, Gr = P.ALLOW_SELF_CLOSE_IN_ATTR !== false, kn = P.SAFE_FOR_TEMPLATES || false, ei = P.SAFE_FOR_XML !== false, xn = P.WHOLE_DOCUMENT || false, Bn = P.RETURN_DOM || false, Rt = P.RETURN_DOM_FRAGMENT || false, ti = P.RETURN_TRUSTED_TYPE || false, Ci = P.FORCE_BODY || false, ni = P.SANITIZE_DOM !== false, Br = P.SANITIZE_NAMED_PROPS || false, d = P.KEEP_CONTENT !== false, ii = P.IN_PLACE || false, Qe = P.ALLOWED_URI_REGEXP || _c, kt = P.NAMESPACE || rn, Li = P.MATHML_TEXT_INTEGRATION_POINTS || Li, Di = P.HTML_INTEGRATION_POINTS || Di, st = P.CUSTOM_ELEMENT_HANDLING || {}, P.CUSTOM_ELEMENT_HANDLING && Hr(P.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (st.tagNameCheck = P.CUSTOM_ELEMENT_HANDLING.tagNameCheck), P.CUSTOM_ELEMENT_HANDLING && Hr(P.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (st.attributeNameCheck = P.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), P.CUSTOM_ELEMENT_HANDLING && typeof P.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (st.allowCustomizedBuiltInElements = P.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), kn && (Pn = false), Rt && (Bn = true), Un && (Ze = ot({}, gu), ct = [], Un.html === true && (ot(Ze, vu), ot(ct, yu)), Un.svg === true && (ot(Ze, bs), ot(ct, Ts), ot(ct, Oo)), Un.svgFilters === true && (ot(Ze, _s), ot(ct, Ts), ot(ct, Oo)), Un.mathMl === true && (ot(Ze, Ss), ot(ct, xu), ot(ct, Oo))), P.ADD_TAGS && (Ze === dt && (Ze = Rn(Ze)), ot(Ze, P.ADD_TAGS, It)), P.ADD_ATTR && (ct === _t && (ct = Rn(ct)), ot(ct, P.ADD_ATTR, It)), P.ADD_URI_SAFE_ATTR && ot(In, P.ADD_URI_SAFE_ATTR, It), P.FORBID_CONTENTS && (Vn === Ur && (Vn = Rn(Vn)), ot(Vn, P.FORBID_CONTENTS, It)), d && (Ze["#text"] = true), xn && ot(Ze, ["html", "head", "body"]), Ze.table && (ot(Ze, ["tbody"]), delete Vt.tbody), P.TRUSTED_TYPES_POLICY) {
        if (typeof P.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Ar('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof P.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Ar('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        V = P.TRUSTED_TYPES_POLICY, se = V.createHTML("");
      } else
        V === void 0 && (V = Tg(D, r)), V !== null && typeof se == "string" && (se = V.createHTML(""));
      jt && jt(P), $n = P;
    }
  }, Wr = ot({}, [...bs, ..._s, ...hg]), Xr = ot({}, [...Ss, ...dg]), xa = function(P) {
    let ve = Ve(P);
    (!ve || !ve.tagName) && (ve = {
      namespaceURI: kt,
      tagName: "template"
    });
    const ze = Xo(P.tagName), mt = Xo(ve.tagName);
    return Ii[P.namespaceURI] ? P.namespaceURI === ki ? ve.namespaceURI === rn ? ze === "svg" : ve.namespaceURI === Pi ? ze === "svg" && (mt === "annotation-xml" || Li[mt]) : !!Wr[ze] : P.namespaceURI === Pi ? ve.namespaceURI === rn ? ze === "math" : ve.namespaceURI === ki ? ze === "math" && Di[mt] : !!Xr[ze] : P.namespaceURI === rn ? ve.namespaceURI === ki && !Di[mt] || ve.namespaceURI === Pi && !Li[mt] ? false : !Xr[ze] && (ya[ze] || !Wr[ze]) : !!(oi === "application/xhtml+xml" && Ii[P.namespaceURI]) : false;
  }, on = function(P) {
    Tr(e.removed, {
      element: P
    });
    try {
      Ve(P).removeChild(P);
    } catch {
      we(P);
    }
  }, Hn = function(P, ve) {
    try {
      Tr(e.removed, {
        attribute: ve.getAttributeNode(P),
        from: ve
      });
    } catch {
      Tr(e.removed, {
        attribute: null,
        from: ve
      });
    }
    if (ve.removeAttribute(P), P === "is")
      if (Bn || Rt)
        try {
          on(ve);
        } catch {
        }
      else
        try {
          ve.setAttribute(P, "");
        } catch {
        }
  }, jr = function(P) {
    let ve = null, ze = null;
    if (Ci)
      P = "<remove></remove>" + P;
    else {
      const wt = pu(P, /^[\r\n\t ]+/);
      ze = wt && wt[0];
    }
    oi === "application/xhtml+xml" && kt === rn && (P = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + P + "</body></html>");
    const mt = V ? V.createHTML(P) : P;
    if (kt === rn)
      try {
        ve = new S().parseFromString(mt, oi);
      } catch {
      }
    if (!ve || !ve.documentElement) {
      ve = Le.createDocument(kt, "template", null);
      try {
        ve.documentElement.innerHTML = ri ? se : mt;
      } catch {
      }
    }
    const Mt = ve.body || ve.documentElement;
    return P && ze && Mt.insertBefore(n.createTextNode(ze), Mt.childNodes[0] || null), kt === rn ? nt.call(ve, xn ? "html" : "body")[0] : xn ? ve.documentElement : Mt;
  }, ir = function(P) {
    return Be.call(
      P.ownerDocument || P,
      P,
      // eslint-disable-next-line no-bitwise
      u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT | u.SHOW_PROCESSING_INSTRUCTION | u.SHOW_CDATA_SECTION,
      null
    );
  }, Fi = function(P) {
    return P instanceof y && (typeof P.nodeName != "string" || typeof P.textContent != "string" || typeof P.removeChild != "function" || !(P.attributes instanceof m) || typeof P.removeAttribute != "function" || typeof P.setAttribute != "function" || typeof P.namespaceURI != "string" || typeof P.insertBefore != "function" || typeof P.hasChildNodes != "function");
  }, gt = function(P) {
    return typeof f == "function" && P instanceof f;
  };
  function un($e, P, ve) {
    Mo($e, (ze) => {
      ze.call(e, P, ve, $n);
    });
  }
  const qr = function(P) {
    let ve = null;
    if (un(Ee.beforeSanitizeElements, P, null), Fi(P))
      return on(P), true;
    const ze = It(P.nodeName);
    if (un(Ee.uponSanitizeElement, P, {
      tagName: ze,
      allowedTags: Ze
    }), ei && P.hasChildNodes() && !gt(P.firstElementChild) && Xt(/<[/\w!]/g, P.innerHTML) && Xt(/<[/\w!]/g, P.textContent) || P.nodeType === Cr.progressingInstruction || ei && P.nodeType === Cr.comment && Xt(/<[/\w]/g, P.data))
      return on(P), true;
    if (!Ze[ze] || Vt[ze]) {
      if (!Vt[ze] && Zr(ze) && (st.tagNameCheck instanceof RegExp && Xt(st.tagNameCheck, ze) || st.tagNameCheck instanceof Function && st.tagNameCheck(ze)))
        return false;
      if (d && !Vn[ze]) {
        const mt = Ve(P) || P.parentNode, Mt = Oe(P) || P.childNodes;
        if (Mt && mt) {
          const wt = Mt.length;
          for (let Ht = wt - 1; Ht >= 0; --Ht) {
            const cn = Te(Mt[Ht], true);
            cn.__removalCount = (P.__removalCount || 0) + 1, mt.insertBefore(cn, fe(P));
          }
        }
      }
      return on(P), true;
    }
    return P instanceof l && !xa(P) || (ze === "noscript" || ze === "noembed" || ze === "noframes") && Xt(/<\/no(script|embed|frames)/i, P.innerHTML) ? (on(P), true) : (kn && P.nodeType === Cr.text && (ve = P.textContent, Mo([ut, rt, N], (mt) => {
      ve = wr(ve, mt, " ");
    }), P.textContent !== ve && (Tr(e.removed, {
      element: P.cloneNode()
    }), P.textContent = ve)), un(Ee.afterSanitizeElements, P, null), false);
  }, Yr = function(P, ve, ze) {
    if (ni && (ve === "id" || ve === "name") && (ze in n || ze in Wt))
      return false;
    if (!(Pn && !$t[ve] && Xt(Pe, ve))) {
      if (!(Yt && Xt(ie, ve))) {
        if (!ct[ve] || $t[ve]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Zr(P) && (st.tagNameCheck instanceof RegExp && Xt(st.tagNameCheck, P) || st.tagNameCheck instanceof Function && st.tagNameCheck(P)) && (st.attributeNameCheck instanceof RegExp && Xt(st.attributeNameCheck, ve) || st.attributeNameCheck instanceof Function && st.attributeNameCheck(ve)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            ve === "is" && st.allowCustomizedBuiltInElements && (st.tagNameCheck instanceof RegExp && Xt(st.tagNameCheck, ze) || st.tagNameCheck instanceof Function && st.tagNameCheck(ze)))
          ) return false;
        } else if (!In[ve]) {
          if (!Xt(Qe, wr(ze, qe, ""))) {
            if (!((ve === "src" || ve === "xlink:href" || ve === "href") && P !== "script" && fg(ze, "data:") === 0 && bn[P])) {
              if (!(Nr && !Xt(ke, wr(ze, qe, "")))) {
                if (ze)
                  return false;
              }
            }
          }
        }
      }
    }
    return true;
  }, Zr = function(P) {
    return P !== "annotation-xml" && pu(P, je);
  }, Qr = function(P) {
    un(Ee.beforeSanitizeAttributes, P, null);
    const {
      attributes: ve
    } = P;
    if (!ve || Fi(P))
      return;
    const ze = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ct,
      forceKeepAttr: void 0
    };
    let mt = ve.length;
    for (; mt--; ) {
      const Mt = ve[mt], {
        name: wt,
        namespaceURI: Ht,
        value: cn
      } = Mt, ai = It(wt), rr = cn;
      let Ot = wt === "value" ? rr : lg(rr);
      if (ze.attrName = ai, ze.attrValue = Ot, ze.keepAttr = true, ze.forceKeepAttr = void 0, un(Ee.uponSanitizeAttribute, P, ze), Ot = ze.attrValue, Br && (ai === "id" || ai === "name") && (Hn(wt, P), Ot = va + Ot), ei && Xt(/((--!?|])>)|<\/(style|title)/i, Ot)) {
        Hn(wt, P);
        continue;
      }
      if (ze.forceKeepAttr)
        continue;
      if (!ze.keepAttr) {
        Hn(wt, P);
        continue;
      }
      if (!Gr && Xt(/\/>/i, Ot)) {
        Hn(wt, P);
        continue;
      }
      kn && Mo([ut, rt, N], (Jr) => {
        Ot = wr(Ot, Jr, " ");
      });
      const Kr = It(P.nodeName);
      if (!Yr(Kr, ai, Ot)) {
        Hn(wt, P);
        continue;
      }
      if (V && typeof D == "object" && typeof D.getAttributeType == "function" && !Ht)
        switch (D.getAttributeType(Kr, ai)) {
          case "TrustedHTML": {
            Ot = V.createHTML(Ot);
            break;
          }
          case "TrustedScriptURL": {
            Ot = V.createScriptURL(Ot);
            break;
          }
        }
      if (Ot !== rr)
        try {
          Ht ? P.setAttributeNS(Ht, wt, Ot) : P.setAttribute(wt, Ot), Fi(P) ? on(P) : mu(e.removed);
        } catch {
          Hn(wt, P);
        }
    }
    un(Ee.afterSanitizeAttributes, P, null);
  }, ba = function $e(P) {
    let ve = null;
    const ze = ir(P);
    for (un(Ee.beforeSanitizeShadowDOM, P, null); ve = ze.nextNode(); )
      un(Ee.uponSanitizeShadowNode, ve, null), qr(ve), Qr(ve), ve.content instanceof o && $e(ve.content);
    un(Ee.afterSanitizeShadowDOM, P, null);
  };
  return e.sanitize = function($e) {
    let P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ve = null, ze = null, mt = null, Mt = null;
    if (ri = !$e, ri && ($e = "<!-->"), typeof $e != "string" && !gt($e))
      if (typeof $e.toString == "function") {
        if ($e = $e.toString(), typeof $e != "string")
          throw Ar("dirty is not a string, aborting");
      } else
        throw Ar("toString is not a function");
    if (!e.isSupported)
      return $e;
    if (Ei || nr(P), e.removed = [], typeof $e == "string" && (ii = false), ii) {
      if ($e.nodeName) {
        const cn = It($e.nodeName);
        if (!Ze[cn] || Vt[cn])
          throw Ar("root node is forbidden and cannot be sanitized in-place");
      }
    } else if ($e instanceof f)
      ve = jr("<!---->"), ze = ve.ownerDocument.importNode($e, true), ze.nodeType === Cr.element && ze.nodeName === "BODY" || ze.nodeName === "HTML" ? ve = ze : ve.appendChild(ze);
    else {
      if (!Bn && !kn && !xn && // eslint-disable-next-line unicorn/prefer-includes
      $e.indexOf("<") === -1)
        return V && ti ? V.createHTML($e) : $e;
      if (ve = jr($e), !ve)
        return Bn ? null : ti ? se : "";
    }
    ve && Ci && on(ve.firstChild);
    const wt = ir(ii ? $e : ve);
    for (; mt = wt.nextNode(); )
      qr(mt), Qr(mt), mt.content instanceof o && ba(mt.content);
    if (ii)
      return $e;
    if (Bn) {
      if (Rt)
        for (Mt = Xe.call(ve.ownerDocument); ve.firstChild; )
          Mt.appendChild(ve.firstChild);
      else
        Mt = ve;
      return (ct.shadowroot || ct.shadowrootmode) && (Mt = lt.call(i, Mt, true)), Mt;
    }
    let Ht = xn ? ve.outerHTML : ve.innerHTML;
    return xn && Ze["!doctype"] && ve.ownerDocument && ve.ownerDocument.doctype && ve.ownerDocument.doctype.name && Xt(Sc, ve.ownerDocument.doctype.name) && (Ht = "<!DOCTYPE " + ve.ownerDocument.doctype.name + `>
` + Ht), kn && Mo([ut, rt, N], (cn) => {
      Ht = wr(Ht, cn, " ");
    }), V && ti ? V.createHTML(Ht) : Ht;
  }, e.setConfig = function() {
    let $e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    nr($e), Ei = true;
  }, e.clearConfig = function() {
    $n = null, Ei = false;
  }, e.isValidAttribute = function($e, P, ve) {
    $n || nr({});
    const ze = It($e), mt = It(P);
    return Yr(ze, mt, ve);
  }, e.addHook = function($e, P) {
    typeof P == "function" && Tr(Ee[$e], P);
  }, e.removeHook = function($e, P) {
    if (P !== void 0) {
      const ve = ag(Ee[$e], P);
      return ve === -1 ? void 0 : sg(Ee[$e], ve, 1)[0];
    }
    return mu(Ee[$e]);
  }, e.removeHooks = function($e) {
    Ee[$e] = [];
  }, e.removeAllHooks = function() {
    Ee = _u();
  }, e;
}
var wg = Tc();
var Ag = (t3) => typeof t3 == "function";
var wc = (t3) => Array.isArray(t3);
var Eg = (t3) => t3 instanceof Object;
var Cg = (t3) => t3 instanceof Object ? t3.constructor.name !== "Function" && t3.constructor.name !== "Object" : false;
var Su = (t3) => Eg(t3) && !wc(t3) && !Ag(t3) && !Cg(t3);
function Kn(t3) {
  let e;
  if (wc(t3))
    e = t3;
  else {
    const n = Jn(t3), i = n == null ? void 0 : n.rgb();
    e = [(i == null ? void 0 : i.r) || 0, (i == null ? void 0 : i.g) || 0, (i == null ? void 0 : i.b) || 0, (n == null ? void 0 : n.opacity) ?? 1];
  }
  return [
    e[0] / 255,
    e[1] / 255,
    e[2] / 255,
    e[3]
  ];
}
function Pg(t3, e, n) {
  return 0.2126 * t3 + 0.7152 * e + 0.0722 * n;
}
function tn(t3, e) {
  let n = new Float32Array();
  return t3({ framebuffer: e })(() => {
    n = t3.read();
  }), n;
}
function kg(t3, e, n) {
  return Math.min(Math.max(t3, e), n);
}
function fn(t3) {
  return t3 != null && !Number.isNaN(t3);
}
function Ig(t3, e) {
  return wg.sanitize(t3, {
    // Default configuration: allow common safe HTML elements and attributes
    ALLOWED_TAGS: ["a", "b", "i", "em", "strong", "span", "div", "p", "br"],
    ALLOWED_ATTR: ["href", "target", "class", "id", "style"],
    ALLOW_DATA_ATTR: false,
    ...e
  });
}
var Lg = class {
  constructor() {
    this.enableSimulation = Ge.enableSimulation, this.backgroundColor = yc, this.spaceSize = Ge.spaceSize, this.pointColor = Xv, this.pointGreyoutOpacity = jv, this.pointGreyoutColor = Rs, this.pointSize = Yv, this.pointOpacity = qv, this.pointSizeScale = Ge.pointSizeScale, this.hoveredPointCursor = Ge.hoveredPointCursor, this.hoveredLinkCursor = Ge.hoveredLinkCursor, this.renderHoveredPointRing = Ge.renderHoveredPointRing, this.hoveredPointRingColor = Ge.hoveredPointRingColor, this.focusedPointRingColor = Ge.focusedPointRingColor, this.focusedPointIndex = Ge.focusedPointIndex, this.linkColor = Zv, this.linkOpacity = Kv, this.linkGreyoutOpacity = Qv, this.linkWidth = Jv, this.linkWidthScale = Ge.linkWidthScale, this.hoveredLinkColor = Ge.hoveredLinkColor, this.hoveredLinkWidthIncrease = Ge.hoveredLinkWidthIncrease, this.renderLinks = Ge.renderLinks, this.curvedLinks = Ge.curvedLinks, this.curvedLinkSegments = Ge.curvedLinkSegments, this.curvedLinkWeight = Ge.curvedLinkWeight, this.curvedLinkControlPointDistance = Ge.curvedLinkControlPointDistance, this.linkArrows = Ge.linkArrows, this.linkArrowsSizeScale = Ge.linkArrowsSizeScale, this.scaleLinksOnZoom = Ge.scaleLinksOnZoom, this.linkVisibilityDistanceRange = Ge.linkVisibilityDistanceRange, this.linkVisibilityMinTransparency = Ge.linkVisibilityMinTransparency, this.useClassicQuadtree = Ge.useClassicQuadtree, this.simulationDecay = Ge.simulation.decay, this.simulationGravity = Ge.simulation.gravity, this.simulationCenter = Ge.simulation.center, this.simulationRepulsion = Ge.simulation.repulsion, this.simulationRepulsionTheta = Ge.simulation.repulsionTheta, this.simulationRepulsionQuadtreeLevels = Ge.simulation.repulsionQuadtreeLevels, this.simulationLinkSpring = Ge.simulation.linkSpring, this.simulationLinkDistance = Ge.simulation.linkDistance, this.simulationLinkDistRandomVariationRange = Ge.simulation.linkDistRandomVariationRange, this.simulationRepulsionFromMouse = Ge.simulation.repulsionFromMouse, this.enableRightClickRepulsion = Ge.enableRightClickRepulsion, this.simulationFriction = Ge.simulation.friction, this.simulationCluster = Ge.simulation.cluster, this.onSimulationStart = void 0, this.onSimulationTick = void 0, this.onSimulationEnd = void 0, this.onSimulationPause = void 0, this.onSimulationRestart = void 0, this.onSimulationUnpause = void 0, this.onClick = void 0, this.onPointClick = void 0, this.onLinkClick = void 0, this.onBackgroundClick = void 0, this.onMouseMove = void 0, this.onPointMouseOver = void 0, this.onPointMouseOut = void 0, this.onLinkMouseOver = void 0, this.onLinkMouseOut = void 0, this.onZoomStart = void 0, this.onZoom = void 0, this.onZoomEnd = void 0, this.onDragStart = void 0, this.onDrag = void 0, this.onDragEnd = void 0, this.showFPSMonitor = Ge.showFPSMonitor, this.pixelRatio = Ge.pixelRatio, this.scalePointsOnZoom = Ge.scalePointsOnZoom, this.initialZoomLevel = void 0, this.enableZoom = Ge.enableZoom, this.enableSimulationDuringZoom = Ge.enableSimulationDuringZoom, this.enableDrag = Ge.enableDrag, this.fitViewOnInit = Ge.fitViewOnInit, this.fitViewDelay = Ge.fitViewDelay, this.fitViewPadding = Ge.fitViewPadding, this.fitViewDuration = Ge.fitViewDuration, this.fitViewByPointsInRect = void 0, this.fitViewByPointIndices = void 0, this.randomSeed = void 0, this.pointSamplingDistance = Ge.pointSamplingDistance, this.attribution = Ge.attribution, this.rescalePositions = Ge.rescalePositions;
  }
  init(e) {
    Object.keys(e).forEach((n) => {
      this.deepMergeConfig(this.getConfig(), e, n);
    });
  }
  deepMergeConfig(e, n, i) {
    Su(e[i]) && Su(n[i]) ? Object.keys(n[i]).forEach((r) => {
      this.deepMergeConfig(e[i], n[i], r);
    }) : e[i] = n[i];
  }
  getConfig() {
    return this;
  }
};
var Gn = class {
  constructor(e, n, i, r, o) {
    this._debugRandomNumber = Math.floor(Math.random() * 1e3), this.reglInstance = e, this.config = n, this.store = i, this.data = r, o && (this.points = o);
  }
};
var Dg = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var Fg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float pointsTextureSize;

attribute vec2 pointIndices;

varying vec4 rgba;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, pointIndices / pointsTextureSize);
  rgba = vec4(pointPosition.xy, 1.0, 0.0);

  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
  gl_PointSize = 1.0;
}`;
var zg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D centermassTexture;
uniform float centerForce;
uniform float alpha;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 velocity = vec4(0.0);
  vec4 centermassValues = texture2D(centermassTexture, vec2(0.0));
  vec2 centermassPosition = centermassValues.xy / centermassValues.b;
  vec2 distVector = centermassPosition - pointPosition.xy;
  float dist = sqrt(dot(distVector, distVector));
  if (dist > 0.0) {
    float angle = atan(distVector.y, distVector.x);
    float addV = alpha * centerForce * dist * 0.01;
    velocity.rg += addV * vec2(cos(angle), sin(angle));
  }

  gl_FragColor = velocity;
}`;
function Pt(t3) {
  return {
    buffer: t3.buffer(new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])),
    size: 2
  };
}
function Ti(t3) {
  const e = new Float32Array(t3 * t3 * 2);
  for (let n = 0; n < t3; n++)
    for (let i = 0; i < t3; i++) {
      const r = n * t3 * 2 + i * 2;
      e[r + 0] = i, e[r + 1] = n;
    }
  return e;
}
var Ai = `#ifdef GL_ES
precision highp float;
#endif

void main() {
  gl_FragColor = vec4(0.0);
}`;
var Dt = `#ifdef GL_ES
precision highp float;
#endif

attribute vec2 vertexCoord; 
varying vec2 textureCoords; 

void main() {
    
    textureCoords = (vertexCoord + 1.0) / 2.0;
    gl_Position = vec4(vertexCoord, 0, 1);
}`;
var Rg = class extends Gn {
  create() {
    const { reglInstance: e, store: n } = this;
    this.centermassTexture || (this.centermassTexture = e.texture()), this.centermassTexture({
      data: new Float32Array(4).fill(0),
      shape: [1, 1, 4],
      type: "float"
    }), this.centermassFbo || (this.centermassFbo = e.framebuffer()), this.centermassFbo({
      color: this.centermassTexture,
      depth: false,
      stencil: false
    }), this.pointIndices || (this.pointIndices = e.buffer(0)), this.pointIndices(Ti(n.pointsTextureSize));
  }
  initPrograms() {
    const { reglInstance: e, config: n, store: i, data: r, points: o } = this;
    this.clearCentermassCommand || (this.clearCentermassCommand = e({
      frag: Ai,
      vert: Dt,
      framebuffer: () => this.centermassFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) }
    })), this.calculateCentermassCommand || (this.calculateCentermassCommand = e({
      frag: Dg,
      vert: Fg,
      framebuffer: () => this.centermassFbo,
      primitive: "points",
      count: () => r.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.pointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        pointsTextureSize: () => i.pointsTextureSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.runCommand || (this.runCommand = e({
      frag: zg,
      vert: Dt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        centermassTexture: () => this.centermassFbo,
        centerForce: () => n.simulationCenter,
        alpha: () => i.alpha
      }
    }));
  }
  run() {
    var e, n, i;
    (e = this.clearCentermassCommand) == null || e.call(this), (n = this.calculateCentermassCommand) == null || n.call(this), (i = this.runCommand) == null || i.call(this);
  }
};
var Mg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float gravity;
uniform float spaceSize;
uniform float alpha;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);

  vec4 velocity = vec4(0.0);

  vec2 centerPosition = vec2(spaceSize / 2.0);
  vec2 distVector = centerPosition - pointPosition.rg;
  float dist = sqrt(dot(distVector, distVector));
  if (dist > 0.0) {
    float angle = atan(distVector.y, distVector.x);
    float additionalVelocity = alpha * gravity * dist * 0.1;
    velocity.rg += additionalVelocity * vec2(cos(angle), sin(angle));
  }

  gl_FragColor = velocity;
}`;
var Og = class extends Gn {
  initPrograms() {
    const { reglInstance: e, config: n, store: i, points: r } = this;
    this.runCommand || (this.runCommand = e({
      frag: Mg,
      vert: Dt,
      framebuffer: () => r == null ? void 0 : r.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => r == null ? void 0 : r.previousPositionFbo,
        gravity: () => n.simulationGravity,
        spaceSize: () => i.adjustedSpaceSize,
        alpha: () => i.alpha
      }
    }));
  }
  run() {
    var e;
    (e = this.runCommand) == null || e.call(this);
  }
};
function Ng(t3) {
  return `
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float linkSpring;
uniform float linkDistance;
uniform vec2 linkDistRandomVariationRange;

uniform sampler2D linkInfoTexture; // Texture storing first link indices and amount
uniform sampler2D linkIndicesTexture;
uniform sampler2D linkPropertiesTexture; // Texture storing link bias and strength
uniform sampler2D linkRandomDistanceTexture;

uniform float pointsTextureSize;
uniform float linksTextureSize;
uniform float alpha;

varying vec2 textureCoords;

const float MAX_LINKS = ${t3}.0;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 velocity = vec4(0.0);

  vec4 linkInfo = texture2D(linkInfoTexture, textureCoords);
  float iCount = linkInfo.r;
  float jCount = linkInfo.g;
  float linkAmount = linkInfo.b;
  if (linkAmount > 0.0) {
    for (float i = 0.0; i < MAX_LINKS; i += 1.0) {
      if (i < linkAmount) {
        if (iCount >= linksTextureSize) {
          iCount = 0.0;
          jCount += 1.0;
        }
        vec2 linkTextureIndex = (vec2(iCount, jCount) + 0.5) / linksTextureSize;
        vec4 connectedPointIndex = texture2D(linkIndicesTexture, linkTextureIndex);
        vec4 biasAndStrength = texture2D(linkPropertiesTexture, linkTextureIndex);
        vec4 randomMinDistance = texture2D(linkRandomDistanceTexture, linkTextureIndex);
        float bias = biasAndStrength.r;
        float strength = biasAndStrength.g;
        float randomMinLinkDist = randomMinDistance.r * (linkDistRandomVariationRange.g - linkDistRandomVariationRange.r) + linkDistRandomVariationRange.r;
        randomMinLinkDist *= linkDistance;

        iCount += 1.0;

        vec4 connectedPointPosition = texture2D(positionsTexture, (connectedPointIndex.rg + 0.5) / pointsTextureSize);
        float x = connectedPointPosition.x - (pointPosition.x + velocity.x);
        float y = connectedPointPosition.y - (pointPosition.y + velocity.y);
        float l = sqrt(x * x + y * y);

        // Apply the link force
        l = max(l, randomMinLinkDist * 0.99);
        l = (l - randomMinLinkDist) / l;
        l *= linkSpring * alpha;
        l *= strength;
        l *= bias;
        x *= l;
        y *= l;
        velocity.x += x;
        velocity.y += y;
      }
    }
  }

  gl_FragColor = vec4(velocity.rg, 0.0, 0.0);
}
  `;
}
var Ns = ((t3) => (t3.OUTGOING = "outgoing", t3.INCOMING = "incoming", t3))(Ns || {});
var Tu = class extends Gn {
  constructor() {
    super(...arguments), this.linkFirstIndicesAndAmount = new Float32Array(), this.indices = new Float32Array(), this.maxPointDegree = 0;
  }
  create(e) {
    const { reglInstance: n, store: { pointsTextureSize: i, linksTextureSize: r }, data: o } = this;
    if (!i || !r) return;
    this.linkFirstIndicesAndAmount = new Float32Array(i * i * 4), this.indices = new Float32Array(r * r * 4);
    const s = new Float32Array(r * r * 4), f = new Float32Array(r * r * 4), l = e === "incoming" ? o.sourceIndexToTargetIndices : o.targetIndexToSourceIndices;
    this.maxPointDegree = 0;
    let u = 0;
    l == null || l.forEach((m, y) => {
      m && (this.linkFirstIndicesAndAmount[y * 4 + 0] = u % r, this.linkFirstIndicesAndAmount[y * 4 + 1] = Math.floor(u / r), this.linkFirstIndicesAndAmount[y * 4 + 2] = m.length ?? 0, m.forEach(([S, D]) => {
        var V, se, Le;
        this.indices[u * 4 + 0] = S % i, this.indices[u * 4 + 1] = Math.floor(S / i);
        const q = ((V = o.degree) == null ? void 0 : V[S]) ?? 0, Te = ((se = o.degree) == null ? void 0 : se[y]) ?? 0, we = q + Te, fe = we !== 0 ? q / we : 0.5, Oe = Math.min(q, Te);
        let Ve = ((Le = o.linkStrength) == null ? void 0 : Le[D]) ?? 1 / Math.max(Oe, 1);
        Ve = Math.sqrt(Ve), s[u * 4 + 0] = fe, s[u * 4 + 1] = Ve, f[u * 4] = this.store.getRandomFloat(0, 1), u += 1;
      }), this.maxPointDegree = Math.max(this.maxPointDegree, m.length ?? 0));
    }), this.linkFirstIndicesAndAmountTexture || (this.linkFirstIndicesAndAmountTexture = n.texture()), this.linkFirstIndicesAndAmountTexture({
      data: this.linkFirstIndicesAndAmount,
      shape: [i, i, 4],
      type: "float"
    }), this.linkFirstIndicesAndAmountFbo || (this.linkFirstIndicesAndAmountFbo = n.framebuffer()), this.linkFirstIndicesAndAmountFbo({
      color: this.linkFirstIndicesAndAmountTexture,
      depth: false,
      stencil: false
    }), this.indicesTexture || (this.indicesTexture = n.texture()), this.indicesTexture({
      data: this.indices,
      shape: [r, r, 4],
      type: "float"
    }), this.indicesFbo || (this.indicesFbo = n.framebuffer()), this.indicesFbo({
      color: this.indicesTexture,
      depth: false,
      stencil: false
    }), this.biasAndStrengthTexture || (this.biasAndStrengthTexture = n.texture()), this.biasAndStrengthTexture({
      data: s,
      shape: [r, r, 4],
      type: "float"
    }), this.biasAndStrengthFbo || (this.biasAndStrengthFbo = n.framebuffer()), this.biasAndStrengthFbo({
      color: this.biasAndStrengthTexture,
      depth: false,
      stencil: false
    }), this.randomDistanceTexture || (this.randomDistanceTexture = n.texture()), this.randomDistanceTexture({
      data: f,
      shape: [r, r, 4],
      type: "float"
    }), this.randomDistanceFbo || (this.randomDistanceFbo = n.framebuffer()), this.randomDistanceFbo({
      color: this.randomDistanceTexture,
      depth: false,
      stencil: false
    });
  }
  initPrograms() {
    const { reglInstance: e, config: n, store: i, points: r } = this;
    this.runCommand || (this.runCommand = e({
      frag: () => Ng(this.maxPointDegree),
      vert: Dt,
      framebuffer: () => r == null ? void 0 : r.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => r == null ? void 0 : r.previousPositionFbo,
        linkSpring: () => n.simulationLinkSpring,
        linkDistance: () => n.simulationLinkDistance,
        linkDistRandomVariationRange: () => n.simulationLinkDistRandomVariationRange,
        linkInfoTexture: () => this.linkFirstIndicesAndAmountFbo,
        linkIndicesTexture: () => this.indicesFbo,
        linkPropertiesTexture: () => this.biasAndStrengthFbo,
        linkRandomDistanceTexture: () => this.randomDistanceFbo,
        pointsTextureSize: () => i.pointsTextureSize,
        linksTextureSize: () => i.linksTextureSize,
        alpha: () => i.alpha
      }
    }));
  }
  run() {
    var e;
    (e = this.runCommand) == null || e.call(this);
  }
};
var Ac = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var Ec = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float pointsTextureSize;
uniform float levelTextureSize;
uniform float cellSize;

attribute vec2 pointIndices;

varying vec4 rgba;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, pointIndices / pointsTextureSize);
  rgba = vec4(pointPosition.rg, 1.0, 0.0);

  float n = floor(pointPosition.x / cellSize);
  float m = floor(pointPosition.y / cellSize);
  
  vec2 levelPosition = 2.0 * (vec2(n, m) + 0.5) / levelTextureSize - 1.0;

  gl_Position = vec4(levelPosition, 0.0, 1.0);
  gl_PointSize = 1.0;
}`;
var Gg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D levelFbo;

uniform float level;
uniform float levels;
uniform float levelTextureSize;
uniform float repulsion;
uniform float alpha;
uniform float spaceSize;
uniform float theta;

varying vec2 textureCoords;

const float MAX_LEVELS_NUM = 14.0;

vec2 calculateAdditionalVelocity (vec2 ij, vec2 pp) {
  vec2 add = vec2(0.0);
  vec4 centermass = texture2D(levelFbo, ij);
  if (centermass.r > 0.0 && centermass.g > 0.0 && centermass.b > 0.0) {
    vec2 centermassPosition = vec2(centermass.rg / centermass.b);
    vec2 distVector = pp - centermassPosition;
    float l = dot(distVector, distVector);
    float dist = sqrt(l);
    if (l > 0.0) {
      float c = alpha * repulsion * centermass.b;

      float distanceMin2 = 1.0;
      if (l < distanceMin2) l = sqrt(distanceMin2 * l);
      float addV = c / sqrt(l);
      add = addV * normalize(distVector);
    }
  }
  return add;
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  float x = pointPosition.x;
  float y = pointPosition.y;

  float left = 0.0;
  float top = 0.0;
  float right = spaceSize;
  float bottom = spaceSize;

  float n_left = 0.0;
  float n_top = 0.0;
  float n_right = 0.0;
  float n_bottom = 0.0;

  float cellSize = 0.0;

  
  for (float i = 0.0; i < MAX_LEVELS_NUM; i += 1.0) {
    if (i <= level) {
      left += cellSize * n_left;
      top += cellSize * n_top;
      right -= cellSize * n_right;
      bottom -= cellSize * n_bottom;

      cellSize = pow(2.0 , levels - i - 1.0);

      float dist_left = x - left;
      n_left = max(0.0, floor(dist_left / cellSize - theta));

      float dist_top = y - top;
      n_top = max(0.0, floor(dist_top / cellSize - theta));
      
      float dist_right = right - x;
      n_right = max(0.0, floor(dist_right / cellSize - theta));

      float dist_bottom = bottom - y;
      n_bottom = max(0.0, floor(dist_bottom / cellSize - theta));

    }
  }

  vec4 velocity = vec4(vec2(0.0), 1.0, 0.0);

  
  for (float i = 0.0; i < 12.0; i += 1.0) {
    for (float j = 0.0; j < 4.0; j += 1.0) {
      float n = left + cellSize * j;
      float m = top + cellSize * n_top + cellSize * i;

      if (n < (left + n_left * cellSize) && m < bottom) {
        velocity.xy += calculateAdditionalVelocity(vec2(n / cellSize, m / cellSize) / levelTextureSize, pointPosition.xy);
      }

      n = left + cellSize * i;
      m = top + cellSize * j;

      if (n < (right - n_right * cellSize) && m < (top + n_top * cellSize)) {
        velocity.xy += calculateAdditionalVelocity(vec2(n / cellSize, m / cellSize) / levelTextureSize, pointPosition.xy);
      }

      n = right - n_right * cellSize + cellSize * j;
      m = top + cellSize * i;

      if (n < right && m < (bottom - n_bottom * cellSize)) {
        velocity.xy += calculateAdditionalVelocity(vec2(n / cellSize, m / cellSize) / levelTextureSize, pointPosition.xy);
      }

      n = left + n_left * cellSize + cellSize * i;
      m = bottom - n_bottom * cellSize + cellSize * j;

      if (n < right && m < bottom) {
        velocity.xy += calculateAdditionalVelocity(vec2(n / cellSize, m / cellSize) / levelTextureSize, pointPosition.xy);
      }
    }
  }

  gl_FragColor = velocity;
}`;
var Bg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D levelFbo;
uniform sampler2D randomValues;

uniform float levelTextureSize;
uniform float repulsion;
uniform float alpha;

varying vec2 textureCoords;

vec2 calculateAdditionalVelocity (vec2 ij, vec2 pp) {
  vec2 add = vec2(0.0);
  vec4 centermass = texture2D(levelFbo, ij);
  if (centermass.r > 0.0 && centermass.g > 0.0 && centermass.b > 0.0) {
    vec2 centermassPosition = vec2(centermass.rg / centermass.b);
    vec2 distVector = pp - centermassPosition;
    float l = dot(distVector, distVector);
    float dist = sqrt(l);
    if (l > 0.0) {
      float angle = atan(distVector.y, distVector.x);
      float c = alpha * repulsion * centermass.b;

      float distanceMin2 = 1.0;
      if (l < distanceMin2) l = sqrt(distanceMin2 * l);
      float addV = c / sqrt(l);
      add = addV * vec2(cos(angle), sin(angle));
    }
  }
  return add;
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 random = texture2D(randomValues, textureCoords);

  vec4 velocity = vec4(0.0);

  
  velocity.xy += calculateAdditionalVelocity(pointPosition.xy / levelTextureSize, pointPosition.xy);
  
  velocity.xy += velocity.xy * random.rg;

  gl_FragColor = velocity;
}`;
var Ug = class extends Gn {
  constructor() {
    super(...arguments), this.levelsFbos = /* @__PURE__ */ new Map(), this.quadtreeLevels = 0;
  }
  create() {
    const { reglInstance: e, store: n } = this;
    if (!n.pointsTextureSize) return;
    this.quadtreeLevels = Math.log2(n.adjustedSpaceSize);
    for (let r = 0; r < this.quadtreeLevels; r += 1) {
      const o = Math.pow(2, r + 1);
      this.levelsFbos.has(`level[${r}]`) || this.levelsFbos.set(`level[${r}]`, e.framebuffer());
      const s = this.levelsFbos.get(`level[${r}]`);
      s && s({
        shape: [o, o],
        colorType: "float",
        depth: false,
        stencil: false
      });
    }
    const i = new Float32Array(n.pointsTextureSize * n.pointsTextureSize * 4);
    for (let r = 0; r < n.pointsTextureSize * n.pointsTextureSize; ++r)
      i[r * 4] = n.getRandomFloat(-1, 1) * 1e-5, i[r * 4 + 1] = n.getRandomFloat(-1, 1) * 1e-5;
    this.randomValuesTexture || (this.randomValuesTexture = e.texture()), this.randomValuesTexture({
      data: i,
      shape: [n.pointsTextureSize, n.pointsTextureSize, 4],
      type: "float"
    }), this.randomValuesFbo || (this.randomValuesFbo = e.framebuffer()), this.randomValuesFbo({
      color: this.randomValuesTexture,
      depth: false,
      stencil: false
    }), this.pointIndices || (this.pointIndices = e.buffer(0)), this.pointIndices(Ti(n.pointsTextureSize));
  }
  initPrograms() {
    const { reglInstance: e, config: n, store: i, data: r, points: o } = this;
    this.clearLevelsCommand || (this.clearLevelsCommand = e({
      frag: Ai,
      vert: Dt,
      framebuffer: (s, f) => f.levelFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) }
    })), this.calculateLevelsCommand || (this.calculateLevelsCommand = e({
      frag: Ac,
      vert: Ec,
      framebuffer: (s, f) => f.levelFbo,
      primitive: "points",
      count: () => r.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.pointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        pointsTextureSize: () => i.pointsTextureSize,
        levelTextureSize: (s, f) => f.levelTextureSize,
        cellSize: (s, f) => f.cellSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.forceCommand || (this.forceCommand = e({
      frag: Gg,
      vert: Dt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        level: (s, f) => f.level,
        levels: this.quadtreeLevels,
        levelFbo: (s, f) => f.levelFbo,
        levelTextureSize: (s, f) => f.levelTextureSize,
        alpha: () => i.alpha,
        repulsion: () => n.simulationRepulsion,
        spaceSize: () => i.adjustedSpaceSize,
        theta: () => n.simulationRepulsionTheta
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.forceFromItsOwnCentermassCommand || (this.forceFromItsOwnCentermassCommand = e({
      frag: Bg,
      vert: Dt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        randomValues: () => this.randomValuesFbo,
        levelFbo: (s, f) => f.levelFbo,
        levelTextureSize: (s, f) => f.levelTextureSize,
        alpha: () => i.alpha,
        repulsion: () => n.simulationRepulsion,
        spaceSize: () => i.adjustedSpaceSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.clearVelocityCommand || (this.clearVelocityCommand = e({
      frag: Ai,
      vert: Dt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) }
    }));
  }
  run() {
    var n, i, r, o, s;
    const { store: e } = this;
    for (let f = 0; f < this.quadtreeLevels; f += 1) {
      (n = this.clearLevelsCommand) == null || n.call(this, { levelFbo: this.levelsFbos.get(`level[${f}]`) });
      const l = Math.pow(2, f + 1), u = e.adjustedSpaceSize / l;
      (i = this.calculateLevelsCommand) == null || i.call(this, {
        levelFbo: this.levelsFbos.get(`level[${f}]`),
        levelTextureSize: l,
        cellSize: u
      });
    }
    (r = this.clearVelocityCommand) == null || r.call(this);
    for (let f = 0; f < this.quadtreeLevels; f += 1) {
      const l = Math.pow(2, f + 1);
      (o = this.forceCommand) == null || o.call(this, {
        levelFbo: this.levelsFbos.get(`level[${f}]`),
        levelTextureSize: l,
        level: f
      }), f === this.quadtreeLevels - 1 && ((s = this.forceFromItsOwnCentermassCommand) == null || s.call(this, {
        levelFbo: this.levelsFbos.get(`level[${f}]`),
        levelTextureSize: l,
        level: f
      }));
    }
  }
};
function Vg(t3, e) {
  t3 = Math.min(t3, e);
  const n = e - t3, i = `
    float dist = sqrt(l);
    if (dist > 0.0) {
      float c = alpha * repulsion * centermass.b;
      addVelocity += calcAdd(vec2(x, y), l, c);
      addVelocity += addVelocity * random.rg;
    }
  `;
  function r(o) {
    if (o >= e)
      return i;
    {
      const s = Math.pow(2, o + 1), f = new Array(o + 1 - n).fill(0).map((u, m) => `pow(2.0, ${o - (m + n)}.0) * i${m + n}`).join("+"), l = new Array(o + 1 - n).fill(0).map((u, m) => `pow(2.0, ${o - (m + n)}.0) * j${m + n}`).join("+");
      return `
      for (float ij${o} = 0.0; ij${o} < 4.0; ij${o} += 1.0) {
        float i${o} = 0.0;
        float j${o} = 0.0;
        if (ij${o} == 1.0 || ij${o} == 3.0) i${o} = 1.0;
        if (ij${o} == 2.0 || ij${o} == 3.0) j${o} = 1.0;
        float i = pow(2.0, ${t3}.0) * n / width${o + 1} + ${f};
        float j = pow(2.0, ${t3}.0) * m / width${o + 1} + ${l};
        float groupPosX = (i + 0.5) / ${s}.0;
        float groupPosY = (j + 0.5) / ${s}.0;
        
        vec4 centermass = texture2D(level[${o}], vec2(groupPosX, groupPosY));
        if (centermass.r > 0.0 && centermass.g > 0.0 && centermass.b > 0.0) {
          float x = centermass.r / centermass.b - pointPosition.r;
          float y = centermass.g / centermass.b - pointPosition.g;
          float l = x * x + y * y;
          if ((width${o + 1} * width${o + 1}) / theta < l) {
            ${i}
          } else {
            ${r(o + 1)}
          }
        }
      }
      `;
    }
  }
  return `
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D randomValues;
uniform float spaceSize;
uniform float repulsion;
uniform float theta;
uniform float alpha;
uniform sampler2D level[${e}];
varying vec2 textureCoords;

vec2 calcAdd(vec2 xy, float l, float c) {
  float distanceMin2 = 1.0;
  if (l < distanceMin2) l = sqrt(distanceMin2 * l);
  float add = c / l;
  return add * xy;
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 random = texture2D(randomValues, textureCoords);

  float width0 = spaceSize;

  vec2 velocity = vec2(0.0);
  vec2 addVelocity = vec2(0.0);

  ${new Array(e).fill(0).map((o, s) => `float width${s + 1} = width${s} / 2.0;`).join(`
`)}

  for (float n = 0.0; n < pow(2.0, ${n}.0); n += 1.0) {
    for (float m = 0.0; m < pow(2.0, ${n}.0); m += 1.0) {
      ${r(n)}
    }
  }

  velocity -= addVelocity;

  gl_FragColor = vec4(velocity, 0.0, 0.0);
}
`;
}
var $g = class extends Gn {
  constructor() {
    super(...arguments), this.levelsTextures = /* @__PURE__ */ new Map(), this.levelsFbos = /* @__PURE__ */ new Map(), this.quadtreeLevels = 0;
  }
  create() {
    const { reglInstance: e, store: n } = this;
    if (!n.pointsTextureSize) return;
    this.quadtreeLevels = Math.log2(n.adjustedSpaceSize);
    for (let r = 0; r < this.quadtreeLevels; r += 1) {
      const o = Math.pow(2, r + 1), s = `level[${r}]`;
      this.levelsTextures.has(s) || this.levelsTextures.set(s, e.texture());
      const f = this.levelsTextures.get(s);
      f && f({
        data: new Float32Array(o * o * 4),
        shape: [o, o, 4],
        type: "float"
      }), this.levelsFbos.has(s) || this.levelsFbos.set(s, e.framebuffer());
      const l = this.levelsFbos.get(s);
      l && l({
        color: this.levelsTextures.get(s),
        depth: false,
        stencil: false
      });
    }
    const i = new Float32Array(n.pointsTextureSize * n.pointsTextureSize * 4);
    for (let r = 0; r < n.pointsTextureSize * n.pointsTextureSize; ++r)
      i[r * 4] = n.getRandomFloat(-1, 1) * 1e-5, i[r * 4 + 1] = n.getRandomFloat(-1, 1) * 1e-5;
    this.randomValuesTexture || (this.randomValuesTexture = e.texture()), this.randomValuesTexture({
      data: i,
      shape: [n.pointsTextureSize, n.pointsTextureSize, 4],
      type: "float"
    }), this.randomValuesFbo || (this.randomValuesFbo = e.framebuffer()), this.randomValuesFbo({
      color: this.randomValuesTexture,
      depth: false,
      stencil: false
    }), this.pointIndices || (this.pointIndices = e.buffer(0)), this.pointIndices(Ti(n.pointsTextureSize));
  }
  initPrograms() {
    const { reglInstance: e, config: n, store: i, data: r, points: o } = this;
    this.clearLevelsCommand || (this.clearLevelsCommand = e({
      frag: Ai,
      vert: Dt,
      framebuffer: (s, f) => f.levelFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) }
    })), this.calculateLevelsCommand || (this.calculateLevelsCommand = e({
      frag: Ac,
      vert: Ec,
      framebuffer: (s, f) => f.levelFbo,
      primitive: "points",
      count: () => r.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.pointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        pointsTextureSize: () => i.pointsTextureSize,
        levelTextureSize: (s, f) => f.levelTextureSize,
        cellSize: (s, f) => f.cellSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.quadtreeCommand = e({
      frag: Vg(n.simulationRepulsionQuadtreeLevels ?? this.quadtreeLevels, this.quadtreeLevels),
      vert: Dt,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => o == null ? void 0 : o.previousPositionFbo,
        randomValues: () => this.randomValuesFbo,
        spaceSize: () => i.adjustedSpaceSize,
        repulsion: () => n.simulationRepulsion,
        theta: () => n.simulationRepulsionTheta,
        alpha: () => i.alpha,
        ...Object.fromEntries(this.levelsFbos)
      }
    });
  }
  run() {
    var n, i, r;
    const { store: e } = this;
    for (let o = 0; o < this.quadtreeLevels; o += 1) {
      (n = this.clearLevelsCommand) == null || n.call(this, { levelFbo: this.levelsFbos.get(`level[${o}]`) });
      const s = Math.pow(2, o + 1), f = e.adjustedSpaceSize / s;
      (i = this.calculateLevelsCommand) == null || i.call(this, {
        levelFbo: this.levelsFbos.get(`level[${o}]`),
        levelTextureSize: s,
        cellSize: f
      });
    }
    (r = this.quadtreeCommand) == null || r.call(this);
  }
};
var Hg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float repulsion;
uniform vec2 mousePos;

varying vec2 textureCoords;

void main() {  
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 velocity = vec4(0.0);
  vec2 mouse = mousePos;
  
  vec2 distVector = mouse - pointPosition.rg;
  float dist = sqrt(dot(distVector, distVector));
  dist = max(dist, 10.0);
  float angle = atan(distVector.y, distVector.x);
  float addV = 100.0 * repulsion / (dist * dist);
  velocity.rg -= addV * vec2(cos(angle), sin(angle));

  gl_FragColor = velocity;
}`;
var Wg = class extends Gn {
  initPrograms() {
    const { reglInstance: e, config: n, store: i, points: r } = this;
    this.runCommand || (this.runCommand = e({
      frag: Hg,
      vert: Dt,
      framebuffer: () => r == null ? void 0 : r.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => r == null ? void 0 : r.previousPositionFbo,
        mousePos: () => i.mousePosition,
        repulsion: () => n.simulationRepulsionFromMouse
      }
    }));
  }
  run() {
    var e;
    (e = this.runCommand) == null || e.call(this);
  }
};
var Xg = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var jg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D clusterTexture;
uniform float pointsTextureSize;
uniform float clustersTextureSize;

attribute vec2 pointIndices;

varying vec4 rgba;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, pointIndices / pointsTextureSize);
  rgba = vec4(pointPosition.xy, 1.0, 0.0);

  vec4 pointClusterIndices = texture2D(clusterTexture, pointIndices / pointsTextureSize);
  vec2 xy = vec2(0.0);
  if (pointClusterIndices.x >= 0.0 && pointClusterIndices.y >= 0.0) {
    xy = 2.0 * (pointClusterIndices.xy + 0.5) / clustersTextureSize - 1.0;
  }
  
  gl_Position = vec4(xy, 0.0, 1.0);
  gl_PointSize = 1.0;
}`;
var qg = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D centermassTexture;
uniform sampler2D clusterTexture;
uniform sampler2D clusterPositionsTexture;
uniform sampler2D clusterForceCoefficient;
uniform float alpha;
uniform float clustersTextureSize;
uniform float clusterCoefficient;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 velocity = vec4(0.0);
  vec4 pointClusterIndices = texture2D(clusterTexture, textureCoords);
  
  if (pointClusterIndices.x >= 0.0 && pointClusterIndices.y >= 0.0) {
    
    vec2 clusterPositions = texture2D(clusterPositionsTexture, pointClusterIndices.xy / clustersTextureSize).xy;
    if (clusterPositions.x < 0.0 || clusterPositions.y < 0.0) {
      vec4 centermassValues = texture2D(centermassTexture, pointClusterIndices.xy / clustersTextureSize);
      clusterPositions = centermassValues.xy / centermassValues.b;
    }
    vec4 clusterCustomCoeff = texture2D(clusterForceCoefficient, textureCoords);
    vec2 distVector = clusterPositions.xy - pointPosition.xy;
    float dist = length(distVector);
    if (dist > 0.0) {
      float addV = alpha * dist * clusterCoefficient * clusterCustomCoeff.r;
      velocity.rg += addV * normalize(distVector);
    }
  }

  gl_FragColor = velocity;
}`;
var Yg = class extends Gn {
  create() {
    var l;
    const { reglInstance: e, store: n, data: i } = this, { pointsTextureSize: r } = n;
    if (i.pointsNumber === void 0 || !i.pointClusters && !i.clusterPositions) return;
    this.clusterCount = (i.pointClusters ?? []).reduce((u, m) => m === void 0 || m < 0 ? u : Math.max(u, m), 0) + 1, this.clustersTextureSize = Math.ceil(Math.sqrt(this.clusterCount));
    const o = new Float32Array(r * r * 4), s = new Float32Array(this.clustersTextureSize * this.clustersTextureSize * 4).fill(-1), f = new Float32Array(r * r * 4).fill(1);
    if (i.clusterPositions)
      for (let u = 0; u < this.clusterCount; ++u)
        s[u * 4 + 0] = i.clusterPositions[u * 2 + 0] ?? -1, s[u * 4 + 1] = i.clusterPositions[u * 2 + 1] ?? -1;
    for (let u = 0; u < i.pointsNumber; ++u) {
      const m = (l = i.pointClusters) == null ? void 0 : l[u];
      m === void 0 ? (o[u * 4 + 0] = -1, o[u * 4 + 1] = -1) : (o[u * 4 + 0] = m % this.clustersTextureSize, o[u * 4 + 1] = Math.floor(m / this.clustersTextureSize)), i.clusterStrength && (f[u * 4 + 0] = i.clusterStrength[u] ?? 1);
    }
    this.clusterTexture || (this.clusterTexture = e.texture()), this.clusterTexture({
      data: o,
      shape: [r, r, 4],
      type: "float"
    }), this.clusterFbo || (this.clusterFbo = e.framebuffer()), this.clusterFbo({
      color: this.clusterTexture,
      depth: false,
      stencil: false
    }), this.clusterPositionsTexture || (this.clusterPositionsTexture = e.texture()), this.clusterPositionsTexture({
      data: s,
      shape: [this.clustersTextureSize, this.clustersTextureSize, 4],
      type: "float"
    }), this.clusterPositionsFbo || (this.clusterPositionsFbo = e.framebuffer()), this.clusterPositionsFbo({
      color: this.clusterPositionsTexture,
      depth: false,
      stencil: false
    }), this.clusterForceCoefficientTexture || (this.clusterForceCoefficientTexture = e.texture()), this.clusterForceCoefficientTexture({
      data: f,
      shape: [r, r, 4],
      type: "float"
    }), this.clusterForceCoefficientFbo || (this.clusterForceCoefficientFbo = e.framebuffer()), this.clusterForceCoefficientFbo({
      color: this.clusterForceCoefficientTexture,
      depth: false,
      stencil: false
    }), this.centermassTexture || (this.centermassTexture = e.texture()), this.centermassTexture({
      data: new Float32Array(this.clustersTextureSize * this.clustersTextureSize * 4).fill(0),
      shape: [this.clustersTextureSize, this.clustersTextureSize, 4],
      type: "float"
    }), this.centermassFbo || (this.centermassFbo = e.framebuffer()), this.centermassFbo({
      color: this.centermassTexture,
      depth: false,
      stencil: false
    }), this.pointIndices || (this.pointIndices = e.buffer(0)), this.pointIndices(Ti(n.pointsTextureSize));
  }
  initPrograms() {
    const { reglInstance: e, store: n, data: i, points: r } = this;
    i.pointClusters !== void 0 && (this.clearCentermassCommand || (this.clearCentermassCommand = e({
      frag: Ai,
      vert: Dt,
      framebuffer: () => this.centermassFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) }
    })), this.calculateCentermassCommand || (this.calculateCentermassCommand = e({
      frag: Xg,
      vert: jg,
      framebuffer: () => this.centermassFbo,
      primitive: "points",
      count: () => i.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.pointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => r == null ? void 0 : r.previousPositionFbo,
        pointsTextureSize: () => n.pointsTextureSize,
        clusterTexture: () => this.clusterFbo,
        clustersTextureSize: () => this.clustersTextureSize
      },
      blend: {
        enable: true,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: false, mask: false },
      stencil: { enable: false }
    })), this.applyForcesCommand || (this.applyForcesCommand = e({
      frag: qg,
      vert: Dt,
      framebuffer: () => r == null ? void 0 : r.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => r == null ? void 0 : r.previousPositionFbo,
        clusterTexture: () => this.clusterFbo,
        centermassTexture: () => this.centermassFbo,
        clusterPositionsTexture: () => this.clusterPositionsFbo,
        clusterForceCoefficient: () => this.clusterForceCoefficientFbo,
        alpha: () => n.alpha,
        clustersTextureSize: () => this.clustersTextureSize,
        clusterCoefficient: () => this.config.simulationCluster
      }
    })));
  }
  calculateCentermass() {
    var e, n;
    (e = this.clearCentermassCommand) == null || e.call(this), (n = this.calculateCentermassCommand) == null || n.call(this);
  }
  run() {
    var e;
    !this.data.pointClusters && !this.data.clusterPositions || (this.calculateCentermass(), (e = this.applyForcesCommand) == null || e.call(this));
  }
};
var jo = { exports: {} };
var Zg = jo.exports;
var wu;
function Qg() {
  return wu || (wu = 1, (function(t3, e) {
    (function(n, i) {
      t3.exports = i();
    })(Zg, function() {
      var n = `<div class="gl-box">
  <svg viewBox="0 0 55 60">
    <text x="27" y="56" class="gl-fps">00 FPS</text>
    <text x="28" y="8" class="gl-mem"></text>
    <rect x="0" y="14" rx="4" ry="4" width="55" height="32"></rect>
    <polyline class="gl-chart"></polyline>
  </svg>
  <svg viewBox="0 0 14 60" class="gl-cpu-svg">
    <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
    <line x1="7" y1="38" x2="7" y2="11" class="gl-cpu" stroke-dasharray="0 27"/>
    <path d="M5.35 43c-.464 0-.812.377-.812.812v1.16c-.783.1972-1.421.812-1.595 1.624h-1.16c-.435 0-.812.348-.812.812s.348.812.812.812h1.102v1.653H1.812c-.464 0-.812.377-.812.812 0 .464.377.812.812.812h1.131c.1943.783.812 1.392 1.595 1.595v1.131c0 .464.377.812.812.812.464 0 .812-.377.812-.812V53.15h1.653v1.073c0 .464.377.812.812.812.464 0 .812-.377.812-.812v-1.131c.783-.1943 1.392-.812 1.595-1.595h1.131c.464 0 .812-.377.812-.812 0-.464-.377-.812-.812-.812h-1.073V48.22h1.102c.435 0 .812-.348.812-.812s-.348-.812-.812-.812h-1.16c-.1885-.783-.812-1.421-1.595-1.624v-1.131c0-.464-.377-.812-.812-.812-.464 0-.812.377-.812.812v1.073H6.162v-1.073c0-.464-.377-.812-.812-.812zm.58 3.48h2.088c.754 0 1.363.609 1.363 1.363v2.088c0 .754-.609 1.363-1.363 1.363H5.93c-.754 0-1.363-.609-1.363-1.363v-2.088c0-.754.609-1.363 1.363-1.363z"/>
  </svg>
  <svg viewBox="0 0 14 60" class="gl-gpu-svg">
    <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
    <line x1="7" y1="38" x2="7" y2="11" class="gl-gpu" stroke-dasharray="0 27"/>
    <path d="M1.94775 43.3772a.736.736 0 10-.00416 1.472c.58535.00231.56465.1288.6348.3197.07015.18975.04933.43585.04933.43585l-.00653.05405v8.671a.736.736 0 101.472 0v-1.4145c.253.09522.52785.1495.81765.1495h5.267c1.2535 0 2.254-.9752 2.254-2.185v-3.105c0-1.2075-1.00625-2.185-2.254-2.185h-5.267c-.28865 0-.5635.05405-.8165.1495.01806-.16445.04209-.598-.1357-1.0787-.22425-.6072-.9499-1.2765-2.0125-1.2765zm2.9095 3.6455c.42435 0 .7659.36225.7659.8119v2.9785c0 .44965-.34155.8119-.7659.8119s-.7659-.36225-.7659-.8119v-2.9785c0-.44965.34155-.8119.7659-.8119zm4.117 0a2.3 2.3 0 012.3 2.3 2.3 2.3 0 01-2.3 2.3 2.3 2.3 0 01-2.3-2.3 2.3 2.3 0 012.3-2.3z"/>
  </svg>
</div>`, i = `#gl-bench {
  position:absolute;
  left:0;
  top:0;
  z-index:1000;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}

#gl-bench div {
  position: relative;
  display: block;
  margin: 4px;
  padding: 0 7px 0 10px;
  background: #6c6;
  border-radius: 15px;
  cursor: pointer;
  opacity: 0.9;
}

#gl-bench svg {
  height: 60px;
  margin: 0 -1px;
}

#gl-bench text {
  font-size: 12px;
  font-family: Helvetica,Arial,sans-serif;
  font-weight: 700;
  dominant-baseline: middle;
  text-anchor: middle;
}

#gl-bench .gl-mem {
  font-size: 9px;
}

#gl-bench line {
  stroke-width: 5;
  stroke: #112211;
  stroke-linecap: round;
}

#gl-bench polyline {
  fill: none;
  stroke: #112211;
  stroke-linecap: round;
  stroke-linejoin: round;
  stroke-width: 3.5;
}

#gl-bench rect {
  fill: #448844;
}

#gl-bench .opacity {
  stroke: #448844;
}
`;
      class r {
        /** GLBench constructor
         * @param { WebGLRenderingContext | WebGL2RenderingContext } gl context
         * @param { Object | undefined } settings additional settings
         */
        constructor(s, f = {}) {
          this.css = i, this.svg = n, this.paramLogger = () => {
          }, this.chartLogger = () => {
          }, this.chartLen = 20, this.chartHz = 20, this.names = [], this.cpuAccums = [], this.gpuAccums = [], this.activeAccums = [], this.chart = new Array(this.chartLen), this.now = () => performance && performance.now ? performance.now() : Date.now(), this.updateUI = () => {
            [].forEach.call(this.nodes["gl-gpu-svg"], (S) => {
              S.style.display = this.trackGPU ? "inline" : "none";
            });
          }, Object.assign(this, f), this.detected = 0, this.finished = [], this.isFramebuffer = 0, this.frameId = 0;
          let l, u = 0, m, y = (S) => {
            ++u < 20 ? l = requestAnimationFrame(y) : (this.detected = Math.ceil(1e3 * u / (S - m) / 70), cancelAnimationFrame(l)), m || (m = S);
          };
          if (requestAnimationFrame(y), s) {
            const S = async (q, Te) => Promise.resolve(setTimeout(() => {
              s.getError();
              const we = this.now() - q;
              Te.forEach((fe, Oe) => {
                fe && (this.gpuAccums[Oe] += we);
              });
            }, 0)), D = (q, Te, we) => function() {
              const fe = Te.now();
              q.apply(we, arguments), Te.trackGPU && Te.finished.push(S(fe, Te.activeAccums.slice(0)));
            };
            [
              "drawArrays",
              "drawElements",
              "drawArraysInstanced",
              "drawBuffers",
              "drawElementsInstanced",
              "drawRangeElements"
            ].forEach((q) => {
              s[q] && (s[q] = D(s[q], this, s));
            }), s.getExtension = /* @__PURE__ */ ((q, Te) => function() {
              let we = q.apply(s, arguments);
              return we && ["drawElementsInstancedANGLE", "drawBuffersWEBGL"].forEach((fe) => {
                we[fe] && (we[fe] = D(we[fe], Te, we));
              }), we;
            })(s.getExtension, this);
          }
          if (!this.withoutUI) {
            this.dom || (this.dom = document.body);
            let S = document.createElement("div");
            S.id = "gl-bench", this.dom.appendChild(S), this.dom.insertAdjacentHTML("afterbegin", '<style id="gl-bench-style">' + this.css + "</style>"), this.dom = S, this.dom.addEventListener("click", () => {
              this.trackGPU = !this.trackGPU, this.updateUI();
            }), this.paramLogger = ((D, q, Te) => {
              const we = ["gl-cpu", "gl-gpu", "gl-mem", "gl-fps", "gl-gpu-svg", "gl-chart"], fe = Object.assign({}, we);
              return we.forEach((Oe) => fe[Oe] = q.getElementsByClassName(Oe)), this.nodes = fe, (Oe, Ve, V, se, Le, Be, Xe) => {
                fe["gl-cpu"][Oe].style.strokeDasharray = (Ve * 0.27).toFixed(0) + " 100", fe["gl-gpu"][Oe].style.strokeDasharray = (V * 0.27).toFixed(0) + " 100", fe["gl-mem"][Oe].innerHTML = Te[Oe] ? Te[Oe] : se ? "mem: " + se.toFixed(0) + "mb" : "", fe["gl-fps"][Oe].innerHTML = Le.toFixed(0) + " FPS", D(Te[Oe], Ve, V, se, Le, Be, Xe);
              };
            })(this.paramLogger, this.dom, this.names), this.chartLogger = ((D, q) => {
              let Te = { "gl-chart": q.getElementsByClassName("gl-chart") };
              return (we, fe, Oe) => {
                let Ve = "", V = fe.length;
                for (let se = 0; se < V; se++) {
                  let Le = (Oe + se + 1) % V;
                  fe[Le] != null && (Ve = Ve + " " + (55 * se / (V - 1)).toFixed(1) + "," + (45 - fe[Le] * 22 / 60 / this.detected).toFixed(1));
                }
                Te["gl-chart"][we].setAttribute("points", Ve), D(this.names[we], fe, Oe);
              };
            })(this.chartLogger, this.dom);
          }
        }
        /**
         * Explicit UI add
         * @param { string | undefined } name 
         */
        addUI(s) {
          this.names.indexOf(s) == -1 && (this.names.push(s), this.dom && (this.dom.insertAdjacentHTML("beforeend", this.svg), this.updateUI()), this.cpuAccums.push(0), this.gpuAccums.push(0), this.activeAccums.push(false));
        }
        /**
         * Increase frameID
         * @param { number | undefined } now
         */
        nextFrame(s) {
          this.frameId++;
          const f = s || this.now();
          if (this.frameId <= 1)
            this.paramFrame = this.frameId, this.paramTime = f;
          else {
            let l = f - this.paramTime;
            if (l >= 1e3) {
              const u = this.frameId - this.paramFrame, m = u / l * 1e3;
              for (let y = 0; y < this.names.length; y++) {
                const S = this.cpuAccums[y] / l * 100, D = this.gpuAccums[y] / l * 100, q = performance && performance.memory ? performance.memory.usedJSHeapSize / (1 << 20) : 0;
                this.paramLogger(y, S, D, q, m, l, u), this.cpuAccums[y] = 0, Promise.all(this.finished).then(() => {
                  this.gpuAccums[y] = 0, this.finished = [];
                });
              }
              this.paramFrame = this.frameId, this.paramTime = f;
            }
          }
          if (!this.detected || !this.chartFrame)
            this.chartFrame = this.frameId, this.chartTime = f, this.circularId = 0;
          else {
            let l = f - this.chartTime, u = this.chartHz * l / 1e3;
            for (; --u > 0 && this.detected; ) {
              const y = (this.frameId - this.chartFrame) / l * 1e3;
              this.chart[this.circularId % this.chartLen] = y;
              for (let S = 0; S < this.names.length; S++)
                this.chartLogger(S, this.chart, this.circularId);
              this.circularId++, this.chartFrame = this.frameId, this.chartTime = f;
            }
          }
        }
        /**
         * Begin named measurement
         * @param { string | undefined } name
         */
        begin(s) {
          this.updateAccums(s);
        }
        /**
         * End named measure
         * @param { string | undefined } name
         */
        end(s) {
          this.updateAccums(s);
        }
        updateAccums(s) {
          let f = this.names.indexOf(s);
          f == -1 && (f = this.names.length, this.addUI(s));
          const l = this.now(), u = l - this.t0;
          for (let m = 0; m < f + 1; m++)
            this.activeAccums[m] && (this.cpuAccums[m] += u);
          this.activeAccums[f] = !this.activeAccums[f], this.t0 = l;
        }
      }
      return r;
    });
  })(jo)), jo.exports;
}
var Kg = Qg();
var Jg = nf(Kg);
var ey = `
  #gl-bench {
    position:absolute;
    right:0;
    top:0;
    z-index:1000;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }
  #gl-bench div {
    position: relative;
    display: block;
    margin: 4px;
    padding: 0 7px 0 10px;
    background: #5f69de;
    border-radius: 15px;
    cursor: pointer;
    opacity: 0.9;
  }
  #gl-bench svg {
    height: 60px;
    margin: 0 -1px;
  }
  #gl-bench text {
    font-size: 12px;
    font-family: Helvetica,Arial,sans-serif;
    font-weight: 700;
    dominant-baseline: middle;
    text-anchor: middle;
  }
  #gl-bench .gl-mem {
    font-size: 9px;
  }
  #gl-bench line {
    stroke-width: 5;
    stroke: #112211;
    stroke-linecap: round;
  }
  #gl-bench polyline {
    fill: none;
    stroke: #112211;
    stroke-linecap: round;
    stroke-linejoin: round;
    stroke-width: 3.5;
  }
  #gl-bench rect {
    fill: #8288e4;
  }
  #gl-bench .opacity {
    stroke: #8288e4;
  }
`;
var Au = class {
  constructor(e) {
    this.destroy();
    const n = e.getContext("webgl") || e.getContext("experimental-webgl");
    this.bench = new Jg(n, { css: ey });
  }
  begin() {
    var e;
    (e = this.bench) == null || e.begin("frame");
  }
  end(e) {
    var n, i;
    (n = this.bench) == null || n.end("frame"), (i = this.bench) == null || i.nextFrame(e);
  }
  destroy() {
    this.bench = void 0, zt("#gl-bench").remove();
  }
};
var ty = ((t3) => (t3[t3.Circle = 0] = "Circle", t3[t3.Square = 1] = "Square", t3[t3.Triangle = 2] = "Triangle", t3[t3.Diamond = 3] = "Diamond", t3[t3.Pentagon = 4] = "Pentagon", t3[t3.Hexagon = 5] = "Hexagon", t3[t3.Star = 6] = "Star", t3[t3.Cross = 7] = "Cross", t3[t3.None = 8] = "None", t3))(ty || {});
var ny = class {
  constructor(e) {
    this._config = e;
  }
  get pointsNumber() {
    return this.pointPositions && this.pointPositions.length / 2;
  }
  get linksNumber() {
    return this.links && this.links.length / 2;
  }
  updatePoints() {
    this.pointPositions = this.inputPointPositions;
  }
  /**
   * Updates the point colors based on the input data or default config value.
   */
  updatePointColor() {
    if (this.pointsNumber === void 0) {
      this.pointColors = void 0;
      return;
    }
    const e = Kn(this._config.pointColor);
    if (this.inputPointColors === void 0 || this.inputPointColors.length / 4 !== this.pointsNumber) {
      this.pointColors = new Float32Array(this.pointsNumber * 4);
      for (let n = 0; n < this.pointColors.length / 4; n++)
        this.pointColors[n * 4] = e[0], this.pointColors[n * 4 + 1] = e[1], this.pointColors[n * 4 + 2] = e[2], this.pointColors[n * 4 + 3] = e[3];
    } else {
      this.pointColors = this.inputPointColors;
      for (let n = 0; n < this.pointColors.length / 4; n++)
        fn(this.pointColors[n * 4]) || (this.pointColors[n * 4] = e[0]), fn(this.pointColors[n * 4 + 1]) || (this.pointColors[n * 4 + 1] = e[1]), fn(this.pointColors[n * 4 + 2]) || (this.pointColors[n * 4 + 2] = e[2]), fn(this.pointColors[n * 4 + 3]) || (this.pointColors[n * 4 + 3] = e[3]);
    }
  }
  /**
   * Updates the point sizes based on the input data or default config value.
   */
  updatePointSize() {
    if (this.pointsNumber === void 0) {
      this.pointSizes = void 0;
      return;
    }
    if (this.inputPointSizes === void 0 || this.inputPointSizes.length !== this.pointsNumber)
      this.pointSizes = new Float32Array(this.pointsNumber).fill(this._config.pointSize);
    else {
      this.pointSizes = this.inputPointSizes;
      for (let e = 0; e < this.pointSizes.length; e++)
        fn(this.pointSizes[e]) || (this.pointSizes[e] = this._config.pointSize);
    }
  }
  /**
   * Updates the point shapes based on the input data or default shape.
   * Default behavior: Circle (0).
  * Images are rendered above shapes.
   */
  updatePointShape() {
    if (this.pointsNumber === void 0) {
      this.pointShapes = void 0;
      return;
    }
    const e = 0;
    if (this.inputPointShapes === void 0 || this.inputPointShapes.length !== this.pointsNumber)
      this.pointShapes = new Float32Array(this.pointsNumber).fill(e);
    else {
      this.pointShapes = new Float32Array(this.inputPointShapes);
      const n = this.pointShapes;
      for (let i = 0; i < n.length; i++) {
        const r = n[i];
        (r == null || !fn(r) || r < 0 || r > 8) && (n[i] = e);
      }
    }
  }
  /**
   * Updates the point image indices based on the input data or default value (-1 for no image).
   */
  updatePointImageIndices() {
    if (this.pointsNumber === void 0) {
      this.pointImageIndices = void 0;
      return;
    }
    if (this.inputPointImageIndices === void 0 || this.inputPointImageIndices.length !== this.pointsNumber)
      this.pointImageIndices = new Float32Array(this.pointsNumber).fill(-1);
    else {
      const e = new Float32Array(this.inputPointImageIndices);
      for (let n = 0; n < e.length; n++) {
        const i = e[n], r = i === void 0 ? NaN : i;
        !Number.isFinite(r) || r < 0 ? e[n] = -1 : e[n] = Math.trunc(r);
      }
      this.pointImageIndices = e;
    }
  }
  /**
   * Updates the point image sizes based on the input data or default to point sizes.
   */
  updatePointImageSizes() {
    var e;
    if (this.pointsNumber === void 0) {
      this.pointImageSizes = void 0;
      return;
    }
    if (this.inputPointImageSizes === void 0 || this.inputPointImageSizes.length !== this.pointsNumber)
      this.pointImageSizes = this.pointSizes ? new Float32Array(this.pointSizes) : new Float32Array(this.pointsNumber).fill(this._config.pointSize);
    else {
      this.pointImageSizes = new Float32Array(this.inputPointImageSizes);
      for (let n = 0; n < this.pointImageSizes.length; n++)
        fn(this.pointImageSizes[n]) || (this.pointImageSizes[n] = ((e = this.pointSizes) == null ? void 0 : e[n]) ?? this._config.pointSize);
    }
  }
  updateLinks() {
    this.links = this.inputLinks;
  }
  /**
   * Updates the link colors based on the input data or default config value.
   */
  updateLinkColor() {
    if (this.linksNumber === void 0) {
      this.linkColors = void 0;
      return;
    }
    const e = Kn(this._config.linkColor);
    if (this.inputLinkColors === void 0 || this.inputLinkColors.length / 4 !== this.linksNumber) {
      this.linkColors = new Float32Array(this.linksNumber * 4);
      for (let n = 0; n < this.linkColors.length / 4; n++)
        this.linkColors[n * 4] = e[0], this.linkColors[n * 4 + 1] = e[1], this.linkColors[n * 4 + 2] = e[2], this.linkColors[n * 4 + 3] = e[3];
    } else {
      this.linkColors = this.inputLinkColors;
      for (let n = 0; n < this.linkColors.length / 4; n++)
        fn(this.linkColors[n * 4]) || (this.linkColors[n * 4] = e[0]), fn(this.linkColors[n * 4 + 1]) || (this.linkColors[n * 4 + 1] = e[1]), fn(this.linkColors[n * 4 + 2]) || (this.linkColors[n * 4 + 2] = e[2]), fn(this.linkColors[n * 4 + 3]) || (this.linkColors[n * 4 + 3] = e[3]);
    }
  }
  /**
   * Updates the link width based on the input data or default config value.
   */
  updateLinkWidth() {
    if (this.linksNumber === void 0) {
      this.linkWidths = void 0;
      return;
    }
    if (this.inputLinkWidths === void 0 || this.inputLinkWidths.length !== this.linksNumber)
      this.linkWidths = new Float32Array(this.linksNumber).fill(this._config.linkWidth);
    else {
      this.linkWidths = this.inputLinkWidths;
      for (let e = 0; e < this.linkWidths.length; e++)
        fn(this.linkWidths[e]) || (this.linkWidths[e] = this._config.linkWidth);
    }
  }
  /**
   * Updates the link arrows based on the input data or default config value.
   */
  updateArrows() {
    if (this.linksNumber === void 0) {
      this.linkArrows = void 0;
      return;
    }
    this.linkArrowsBoolean === void 0 || this.linkArrowsBoolean.length !== this.linksNumber ? this.linkArrows = new Array(this.linksNumber).fill(+this._config.linkArrows) : this.linkArrows = this.linkArrowsBoolean.map((e) => +e);
  }
  updateLinkStrength() {
    this.linksNumber === void 0 && (this.linkStrength = void 0), this.inputLinkStrength === void 0 || this.inputLinkStrength.length !== this.linksNumber ? this.linkStrength = void 0 : this.linkStrength = this.inputLinkStrength;
  }
  updateClusters() {
    if (this.pointsNumber === void 0) {
      this.pointClusters = void 0, this.clusterPositions = void 0;
      return;
    }
    this.inputPointClusters === void 0 || this.inputPointClusters.length !== this.pointsNumber ? this.pointClusters = void 0 : this.pointClusters = this.inputPointClusters, this.inputClusterPositions === void 0 ? this.clusterPositions = void 0 : this.clusterPositions = this.inputClusterPositions, this.inputClusterStrength === void 0 || this.inputClusterStrength.length !== this.pointsNumber ? this.clusterStrength = void 0 : this.clusterStrength = this.inputClusterStrength;
  }
  update() {
    this.updatePoints(), this.updatePointColor(), this.updatePointSize(), this.updatePointShape(), this.updatePointImageIndices(), this.updatePointImageSizes(), this.updateLinks(), this.updateLinkColor(), this.updateLinkWidth(), this.updateArrows(), this.updateLinkStrength(), this.updateClusters(), this._createAdjacencyLists(), this._calculateDegrees();
  }
  getAdjacentIndices(e) {
    var n, i, r, o;
    return [...((i = (n = this.sourceIndexToTargetIndices) == null ? void 0 : n[e]) == null ? void 0 : i.map((s) => s[0])) || [], ...((o = (r = this.targetIndexToSourceIndices) == null ? void 0 : r[e]) == null ? void 0 : o.map((s) => s[0])) || []];
  }
  _createAdjacencyLists() {
    var e, n;
    if (this.linksNumber === void 0 || this.links === void 0) {
      this.sourceIndexToTargetIndices = void 0, this.targetIndexToSourceIndices = void 0;
      return;
    }
    this.sourceIndexToTargetIndices = new Array(this.pointsNumber).fill(void 0), this.targetIndexToSourceIndices = new Array(this.pointsNumber).fill(void 0);
    for (let i = 0; i < this.linksNumber; i++) {
      const r = this.links[i * 2], o = this.links[i * 2 + 1];
      r !== void 0 && o !== void 0 && (this.sourceIndexToTargetIndices[r] === void 0 && (this.sourceIndexToTargetIndices[r] = []), (e = this.sourceIndexToTargetIndices[r]) == null || e.push([o, i]), this.targetIndexToSourceIndices[o] === void 0 && (this.targetIndexToSourceIndices[o] = []), (n = this.targetIndexToSourceIndices[o]) == null || n.push([r, i]));
    }
  }
  _calculateDegrees() {
    var e, n, i, r;
    if (this.pointsNumber === void 0) {
      this.degree = void 0, this.inDegree = void 0, this.outDegree = void 0;
      return;
    }
    this.degree = new Array(this.pointsNumber).fill(0), this.inDegree = new Array(this.pointsNumber).fill(0), this.outDegree = new Array(this.pointsNumber).fill(0);
    for (let o = 0; o < this.pointsNumber; o++)
      this.inDegree[o] = ((n = (e = this.targetIndexToSourceIndices) == null ? void 0 : e[o]) == null ? void 0 : n.length) ?? 0, this.outDegree[o] = ((r = (i = this.sourceIndexToTargetIndices) == null ? void 0 : i[o]) == null ? void 0 : r.length) ?? 0, this.degree[o] = (this.inDegree[o] ?? 0) + (this.outDegree[o] ?? 0);
  }
};
var iy = `precision highp float;

varying vec4 rgbaColor;
varying vec2 pos;
varying float arrowLength;
varying float useArrow;
varying float smoothing;
varying float arrowWidthFactor;
varying float linkIndex;

uniform float renderMode;

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

void main() {
  float opacity = 1.0;
  vec3 color = rgbaColor.rgb;

  if (useArrow > 0.5) {
    float end_arrow = 0.5 + arrowLength / 2.0;
    float start_arrow = end_arrow - arrowLength;
    float arrowWidthDelta = arrowWidthFactor / 2.0;
    float linkOpacity = rgbaColor.a * smoothstep(0.5 - arrowWidthDelta, 0.5 - arrowWidthDelta - smoothing / 2.0, abs(pos.y));
    float arrowOpacity = 1.0;
    if (pos.x > start_arrow && pos.x < start_arrow + arrowLength) {
      float xmapped = map(pos.x, start_arrow, end_arrow, 0.0, 1.0);
      arrowOpacity = rgbaColor.a * smoothstep(xmapped - smoothing, xmapped, map(abs(pos.y), 0.5, 0.0, 0.0, 1.0));
      if (linkOpacity != arrowOpacity) {
        linkOpacity = max(linkOpacity, arrowOpacity);
      }
    }
    opacity = linkOpacity;
  } else opacity = rgbaColor.a * smoothstep(0.5, 0.5 - smoothing, abs(pos.y));
  
  if (renderMode > 0.0) {
    if (opacity > 0.0) {
      gl_FragColor = vec4(linkIndex, 0.0, 0.0, 1.0);
    } else {
      gl_FragColor = vec4(-1.0, 0.0, 0.0, 0.0);
    }
  } else gl_FragColor = vec4(color, opacity);

}`;
var ry = `precision highp float;

attribute vec2 position, pointA, pointB;
attribute vec4 color;
attribute float width;
attribute float arrow;
attribute float linkIndices;

uniform sampler2D positionsTexture;
uniform sampler2D pointGreyoutStatus;
uniform mat3 transformationMatrix;
uniform float pointsTextureSize;
uniform float widthScale;
uniform float linkArrowsSizeScale;
uniform float spaceSize;
uniform vec2 screenSize;
uniform vec2 linkVisibilityDistanceRange;
uniform float linkVisibilityMinTransparency;
uniform float linkOpacity;
uniform float greyoutOpacity;
uniform float curvedWeight;
uniform float curvedLinkControlPointDistance;
uniform float curvedLinkSegments;
uniform bool scaleLinksOnZoom;
uniform float maxPointSize;

uniform float renderMode;
uniform float hoveredLinkIndex;
uniform vec4 hoveredLinkColor;
uniform float hoveredLinkWidthIncrease;

varying vec4 rgbaColor;
varying vec2 pos;
varying float arrowLength;
varying float useArrow;
varying float smoothing;
varying float arrowWidthFactor;
varying float linkIndex;

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec2 conicParametricCurve(vec2 A, vec2 B, vec2 ControlPoint, float t, float w) {
  vec2 divident = (1.0 - t) * (1.0 - t) * A + 2.0 * (1.0 - t) * t * w * ControlPoint + t * t * B;
  float divisor = (1.0 - t) * (1.0 - t) + 2.0 * (1.0 - t) * t * w + t * t;
  return divident / divisor;
}

float calculateLinkWidth(float width) {
  float linkWidth;
  if (scaleLinksOnZoom) {
    
    linkWidth = width;
  } else {
    
    linkWidth = width / transformationMatrix[0][0];
    
    linkWidth *= min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
  }
  
  if (useArrow > 0.5) {
    return min(linkWidth, (maxPointSize * 2.0) / transformationMatrix[0][0]);
  } else {
    return min(linkWidth, maxPointSize / transformationMatrix[0][0]);
  }
}

float calculateArrowWidth(float arrowWidth) {
  if (scaleLinksOnZoom) {
    return arrowWidth;
  } else {
    
    arrowWidth = arrowWidth / transformationMatrix[0][0];
    
    arrowWidth *= min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
    return arrowWidth;
  }
}

void main() {
  pos = position;
  linkIndex = linkIndices;

  vec2 pointTexturePosA = (pointA + 0.5) / pointsTextureSize;
  vec2 pointTexturePosB = (pointB + 0.5) / pointsTextureSize;
  
  vec4 greyoutStatusA = texture2D(pointGreyoutStatus, pointTexturePosA);
  vec4 greyoutStatusB = texture2D(pointGreyoutStatus, pointTexturePosB);
  
  vec4 pointPositionA = texture2D(positionsTexture, pointTexturePosA);
  vec4 pointPositionB = texture2D(positionsTexture, pointTexturePosB);
  vec2 a = pointPositionA.xy;
  vec2 b = pointPositionB.xy;
  
  
  vec2 xBasis = b - a;
  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));

  
  float linkDist = length(xBasis);
  float h = curvedLinkControlPointDistance;
  vec2 controlPoint = (a + b) / 2.0 + yBasis * linkDist * h;

  
  float linkDistPx = linkDist * transformationMatrix[0][0];
  
  
  float linkWidth = width * widthScale;
  float k = 2.0;
  
  float arrowWidth = linkWidth * k;
  arrowWidth *= linkArrowsSizeScale;

  
  float arrowWidthDifference = max(0.0, arrowWidth - linkWidth);

  
  float arrowWidthPx = calculateArrowWidth(arrowWidth);

  
  
  
  arrowLength = min(0.3, (0.866 * arrowWidthPx * 2.0) / linkDist);

  useArrow = arrow;
  if (useArrow > 0.5) {
    linkWidth += arrowWidthDifference;
  }

  arrowWidthFactor = arrowWidthDifference / linkWidth;

  
  float linkWidthPx = calculateLinkWidth(linkWidth);
    
  if (renderMode > 0.0) {
    
    linkWidthPx += 5.0 / transformationMatrix[0][0];
  } else {
      
    if (hoveredLinkIndex == linkIndex) {
      linkWidthPx += hoveredLinkWidthIncrease / transformationMatrix[0][0];
    }
  }
  float smoothingPx = 0.5 / transformationMatrix[0][0];
  smoothing = smoothingPx / linkWidthPx;
  linkWidthPx += smoothingPx;

  
  vec3 rgbColor = color.rgb;
  
  float opacity = color.a * linkOpacity * max(linkVisibilityMinTransparency, map(linkDistPx, linkVisibilityDistanceRange.g, linkVisibilityDistanceRange.r, 0.0, 1.0));

  
  if (greyoutStatusA.r > 0.0 || greyoutStatusB.r > 0.0) {
    opacity *= greyoutOpacity;
  }

  
  rgbaColor = vec4(rgbColor, opacity);

  
  if (hoveredLinkIndex == linkIndex && hoveredLinkColor.a > -0.5) {
    
    rgbaColor.rgb = hoveredLinkColor.rgb;
    rgbaColor.a *= hoveredLinkColor.a;
  }

  
  float t = position.x;
  float w = curvedWeight;
  
  float tPrev = t - 1.0 / curvedLinkSegments;
  float tNext = t + 1.0 / curvedLinkSegments;
  
  vec2 pointCurr = conicParametricCurve(a, b, controlPoint, t, w);
  
  vec2 pointPrev = conicParametricCurve(a, b, controlPoint, max(0.0, tPrev), w);
  vec2 pointNext = conicParametricCurve(a, b, controlPoint, min(tNext, 1.0), w);
  
  vec2 xBasisCurved = pointNext - pointPrev;
  vec2 yBasisCurved = normalize(vec2(-xBasisCurved.y, xBasisCurved.x));
  
  pointCurr += yBasisCurved * linkWidthPx * position.y;
  
  
  vec2 p = 2.0 * pointCurr / spaceSize - 1.0;
  p *= spaceSize / screenSize;
  vec3 final = transformationMatrix * vec3(p, 1);
  
  gl_Position = vec4(final.rg, 0, 1);
}`;
var oy = `precision highp float;

uniform sampler2D linkIndexTexture;
uniform vec2 mousePosition;
uniform vec2 screenSize;

varying vec2 vTexCoord;

void main() {
  
  vec2 texCoord = mousePosition / screenSize;
  
  
  vec4 linkIndexData = texture2D(linkIndexTexture, texCoord);
  
  
  float linkIndex = linkIndexData.r;
  
  
  if (linkIndexData.a > 0.0 && linkIndex >= 0.0) {
    
    gl_FragColor = vec4(linkIndex, 0.0, 0.0, 1.0);
  } else {
    
    gl_FragColor = vec4(-1.0, 0.0, 0.0, 0.0);
  }
}`;
var ay = `attribute vec2 position;

varying vec2 vTexCoord;

void main() {
  vTexCoord = position * 0.5 + 0.5;
  gl_Position = vec4(position, 0.0, 1.0);
}`;
function qo(t3, e) {
  return t3 == null || e == null ? NaN : t3 < e ? -1 : t3 > e ? 1 : t3 >= e ? 0 : NaN;
}
function sy(t3, e) {
  return t3 == null || e == null ? NaN : e < t3 ? -1 : e > t3 ? 1 : e >= t3 ? 0 : NaN;
}
function Cc(t3) {
  let e, n, i;
  t3.length !== 2 ? (e = qo, n = (f, l) => qo(t3(f), l), i = (f, l) => t3(f) - l) : (e = t3 === qo || t3 === sy ? t3 : fy, n = t3, i = t3);
  function r(f, l, u = 0, m = f.length) {
    if (u < m) {
      if (e(l, l) !== 0) return m;
      do {
        const y = u + m >>> 1;
        n(f[y], l) < 0 ? u = y + 1 : m = y;
      } while (u < m);
    }
    return u;
  }
  function o(f, l, u = 0, m = f.length) {
    if (u < m) {
      if (e(l, l) !== 0) return m;
      do {
        const y = u + m >>> 1;
        n(f[y], l) <= 0 ? u = y + 1 : m = y;
      } while (u < m);
    }
    return u;
  }
  function s(f, l, u = 0, m = f.length) {
    const y = r(f, l, u, m - 1);
    return y > u && i(f[y - 1], l) > -i(f[y], l) ? y - 1 : y;
  }
  return { left: r, center: s, right: o };
}
function fy() {
  return 0;
}
function ly(t3) {
  return t3 === null ? NaN : +t3;
}
var uy = Cc(qo);
var cy = uy.right;
Cc(ly).center;
function Eu(t3, e) {
  let n, i;
  for (const r of t3)
    r != null && (n === void 0 ? r >= r && (n = i = r) : (n > r && (n = r), i < r && (i = r)));
  return [n, i];
}
var Gs = Math.sqrt(50);
var Bs = Math.sqrt(10);
var Us = Math.sqrt(2);
function hy(t3, e, n) {
  var i, r = -1, o, s, f;
  if (e = +e, t3 = +t3, n = +n, t3 === e && n > 0) return [t3];
  if ((i = e < t3) && (o = t3, t3 = e, e = o), (f = Pc(t3, e, n)) === 0 || !isFinite(f)) return [];
  if (f > 0) {
    let l = Math.round(t3 / f), u = Math.round(e / f);
    for (l * f < t3 && ++l, u * f > e && --u, s = new Array(o = u - l + 1); ++r < o; ) s[r] = (l + r) * f;
  } else {
    f = -f;
    let l = Math.round(t3 * f), u = Math.round(e * f);
    for (l / f < t3 && ++l, u / f > e && --u, s = new Array(o = u - l + 1); ++r < o; ) s[r] = (l + r) / f;
  }
  return i && s.reverse(), s;
}
function Pc(t3, e, n) {
  var i = (e - t3) / Math.max(0, n), r = Math.floor(Math.log(i) / Math.LN10), o = i / Math.pow(10, r);
  return r >= 0 ? (o >= Gs ? 10 : o >= Bs ? 5 : o >= Us ? 2 : 1) * Math.pow(10, r) : -Math.pow(10, -r) / (o >= Gs ? 10 : o >= Bs ? 5 : o >= Us ? 2 : 1);
}
function dy(t3, e, n) {
  var i = Math.abs(e - t3) / Math.max(0, n), r = Math.pow(10, Math.floor(Math.log(i) / Math.LN10)), o = i / r;
  return o >= Gs ? r *= 10 : o >= Bs ? r *= 5 : o >= Us && (r *= 2), e < t3 ? -r : r;
}
function my(t3, e, n) {
  t3 = +t3, e = +e, n = (r = arguments.length) < 2 ? (e = t3, t3 = 0, 1) : r < 3 ? 1 : +n;
  for (var i = -1, r = Math.max(0, Math.ceil((e - t3) / n)) | 0, o = new Array(r); ++i < r; )
    o[i] = t3 + i * n;
  return o;
}
function kc(t3, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t3);
      break;
    default:
      this.range(e).domain(t3);
      break;
  }
  return this;
}
function py(t3) {
  return function() {
    return t3;
  };
}
function vy(t3) {
  return +t3;
}
var Cu = [0, 1];
function An(t3) {
  return t3;
}
function Vs(t3, e) {
  return (e -= t3 = +t3) ? function(n) {
    return (n - t3) / e;
  } : py(isNaN(e) ? NaN : 0.5);
}
function gy(t3, e) {
  var n;
  return t3 > e && (n = t3, t3 = e, e = n), function(i) {
    return Math.max(t3, Math.min(e, i));
  };
}
function yy(t3, e, n) {
  var i = t3[0], r = t3[1], o = e[0], s = e[1];
  return r < i ? (i = Vs(r, i), o = n(s, o)) : (i = Vs(i, r), o = n(o, s)), function(f) {
    return o(i(f));
  };
}
function xy(t3, e, n) {
  var i = Math.min(t3.length, e.length) - 1, r = new Array(i), o = new Array(i), s = -1;
  for (t3[i] < t3[0] && (t3 = t3.slice().reverse(), e = e.slice().reverse()); ++s < i; )
    r[s] = Vs(t3[s], t3[s + 1]), o[s] = n(e[s], e[s + 1]);
  return function(f) {
    var l = cy(t3, f, 1, i) - 1;
    return o[l](r[l](f));
  };
}
function Ic(t3, e) {
  return e.domain(t3.domain()).range(t3.range()).interpolate(t3.interpolate()).clamp(t3.clamp()).unknown(t3.unknown());
}
function Lc() {
  var t3 = Cu, e = Cu, n = ef, i, r, o, s = An, f, l, u;
  function m() {
    var S = Math.min(t3.length, e.length);
    return s !== An && (s = gy(t3[0], t3[S - 1])), f = S > 2 ? xy : yy, l = u = null, y;
  }
  function y(S) {
    return S == null || isNaN(S = +S) ? o : (l || (l = f(t3.map(i), e, n)))(i(s(S)));
  }
  return y.invert = function(S) {
    return s(r((u || (u = f(e, t3.map(i), pn)))(S)));
  }, y.domain = function(S) {
    return arguments.length ? (t3 = Array.from(S, vy), m()) : t3.slice();
  }, y.range = function(S) {
    return arguments.length ? (e = Array.from(S), m()) : e.slice();
  }, y.rangeRound = function(S) {
    return e = Array.from(S), n = E0, m();
  }, y.clamp = function(S) {
    return arguments.length ? (s = S ? true : An, m()) : s !== An;
  }, y.interpolate = function(S) {
    return arguments.length ? (n = S, m()) : n;
  }, y.unknown = function(S) {
    return arguments.length ? (o = S, y) : o;
  }, function(S, D) {
    return i = S, r = D, m();
  };
}
function by() {
  return Lc()(An, An);
}
function _y(t3) {
  return Math.abs(t3 = Math.round(t3)) >= 1e21 ? t3.toLocaleString("en").replace(/,/g, "") : t3.toString(10);
}
function la(t3, e) {
  if ((n = (t3 = e ? t3.toExponential(e - 1) : t3.toExponential()).indexOf("e")) < 0) return null;
  var n, i = t3.slice(0, n);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +t3.slice(n + 1)
  ];
}
function Ji(t3) {
  return t3 = la(Math.abs(t3)), t3 ? t3[1] : NaN;
}
function Sy(t3, e) {
  return function(n, i) {
    for (var r = n.length, o = [], s = 0, f = t3[0], l = 0; r > 0 && f > 0 && (l + f + 1 > i && (f = Math.max(1, i - l)), o.push(n.substring(r -= f, r + f)), !((l += f + 1) > i)); )
      f = t3[s = (s + 1) % t3.length];
    return o.reverse().join(e);
  };
}
function Ty(t3) {
  return function(e) {
    return e.replace(/[0-9]/g, function(n) {
      return t3[+n];
    });
  };
}
var wy = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function ua(t3) {
  if (!(e = wy.exec(t3))) throw new Error("invalid format: " + t3);
  var e;
  return new rf({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
ua.prototype = rf.prototype;
function rf(t3) {
  this.fill = t3.fill === void 0 ? " " : t3.fill + "", this.align = t3.align === void 0 ? ">" : t3.align + "", this.sign = t3.sign === void 0 ? "-" : t3.sign + "", this.symbol = t3.symbol === void 0 ? "" : t3.symbol + "", this.zero = !!t3.zero, this.width = t3.width === void 0 ? void 0 : +t3.width, this.comma = !!t3.comma, this.precision = t3.precision === void 0 ? void 0 : +t3.precision, this.trim = !!t3.trim, this.type = t3.type === void 0 ? "" : t3.type + "";
}
rf.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function Ay(t3) {
  e: for (var e = t3.length, n = 1, i = -1, r; n < e; ++n)
    switch (t3[n]) {
      case ".":
        i = r = n;
        break;
      case "0":
        i === 0 && (i = n), r = n;
        break;
      default:
        if (!+t3[n]) break e;
        i > 0 && (i = 0);
        break;
    }
  return i > 0 ? t3.slice(0, i) + t3.slice(r + 1) : t3;
}
var Dc;
function Ey(t3, e) {
  var n = la(t3, e);
  if (!n) return t3 + "";
  var i = n[0], r = n[1], o = r - (Dc = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, s = i.length;
  return o === s ? i : o > s ? i + new Array(o - s + 1).join("0") : o > 0 ? i.slice(0, o) + "." + i.slice(o) : "0." + new Array(1 - o).join("0") + la(t3, Math.max(0, e + o - 1))[0];
}
function Pu(t3, e) {
  var n = la(t3, e);
  if (!n) return t3 + "";
  var i = n[0], r = n[1];
  return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
}
var ku = {
  "%": (t3, e) => (t3 * 100).toFixed(e),
  b: (t3) => Math.round(t3).toString(2),
  c: (t3) => t3 + "",
  d: _y,
  e: (t3, e) => t3.toExponential(e),
  f: (t3, e) => t3.toFixed(e),
  g: (t3, e) => t3.toPrecision(e),
  o: (t3) => Math.round(t3).toString(8),
  p: (t3, e) => Pu(t3 * 100, e),
  r: Pu,
  s: Ey,
  X: (t3) => Math.round(t3).toString(16).toUpperCase(),
  x: (t3) => Math.round(t3).toString(16)
};
function Iu(t3) {
  return t3;
}
var Lu = Array.prototype.map;
var Du = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Cy(t3) {
  var e = t3.grouping === void 0 || t3.thousands === void 0 ? Iu : Sy(Lu.call(t3.grouping, Number), t3.thousands + ""), n = t3.currency === void 0 ? "" : t3.currency[0] + "", i = t3.currency === void 0 ? "" : t3.currency[1] + "", r = t3.decimal === void 0 ? "." : t3.decimal + "", o = t3.numerals === void 0 ? Iu : Ty(Lu.call(t3.numerals, String)), s = t3.percent === void 0 ? "%" : t3.percent + "", f = t3.minus === void 0 ? "" : t3.minus + "", l = t3.nan === void 0 ? "NaN" : t3.nan + "";
  function u(y) {
    y = ua(y);
    var S = y.fill, D = y.align, q = y.sign, Te = y.symbol, we = y.zero, fe = y.width, Oe = y.comma, Ve = y.precision, V = y.trim, se = y.type;
    se === "n" ? (Oe = true, se = "g") : ku[se] || (Ve === void 0 && (Ve = 12), V = true, se = "g"), (we || S === "0" && D === "=") && (we = true, S = "0", D = "=");
    var Le = Te === "$" ? n : Te === "#" && /[boxX]/.test(se) ? "0" + se.toLowerCase() : "", Be = Te === "$" ? i : /[%p]/.test(se) ? s : "", Xe = ku[se], nt = /[defgprs%]/.test(se);
    Ve = Ve === void 0 ? 6 : /[gprs]/.test(se) ? Math.max(1, Math.min(21, Ve)) : Math.max(0, Math.min(20, Ve));
    function lt(Ee) {
      var ut = Le, rt = Be, N, Pe, ie;
      if (se === "c")
        rt = Xe(Ee) + rt, Ee = "";
      else {
        Ee = +Ee;
        var ke = Ee < 0 || 1 / Ee < 0;
        if (Ee = isNaN(Ee) ? l : Xe(Math.abs(Ee), Ve), V && (Ee = Ay(Ee)), ke && +Ee == 0 && q !== "+" && (ke = false), ut = (ke ? q === "(" ? q : f : q === "-" || q === "(" ? "" : q) + ut, rt = (se === "s" ? Du[8 + Dc / 3] : "") + rt + (ke && q === "(" ? ")" : ""), nt) {
          for (N = -1, Pe = Ee.length; ++N < Pe; )
            if (ie = Ee.charCodeAt(N), 48 > ie || ie > 57) {
              rt = (ie === 46 ? r + Ee.slice(N + 1) : Ee.slice(N)) + rt, Ee = Ee.slice(0, N);
              break;
            }
        }
      }
      Oe && !we && (Ee = e(Ee, 1 / 0));
      var qe = ut.length + Ee.length + rt.length, je = qe < fe ? new Array(fe - qe + 1).join(S) : "";
      switch (Oe && we && (Ee = e(je + Ee, je.length ? fe - rt.length : 1 / 0), je = ""), D) {
        case "<":
          Ee = ut + Ee + rt + je;
          break;
        case "=":
          Ee = ut + je + Ee + rt;
          break;
        case "^":
          Ee = je.slice(0, qe = je.length >> 1) + ut + Ee + rt + je.slice(qe);
          break;
        default:
          Ee = je + ut + Ee + rt;
          break;
      }
      return o(Ee);
    }
    return lt.toString = function() {
      return y + "";
    }, lt;
  }
  function m(y, S) {
    var D = u((y = ua(y), y.type = "f", y)), q = Math.max(-8, Math.min(8, Math.floor(Ji(S) / 3))) * 3, Te = Math.pow(10, -q), we = Du[8 + q / 3];
    return function(fe) {
      return D(Te * fe) + we;
    };
  }
  return {
    format: u,
    formatPrefix: m
  };
}
var No;
var Fc;
var zc;
Py({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Py(t3) {
  return No = Cy(t3), Fc = No.format, zc = No.formatPrefix, No;
}
function ky(t3) {
  return Math.max(0, -Ji(Math.abs(t3)));
}
function Iy(t3, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Ji(e) / 3))) * 3 - Ji(Math.abs(t3)));
}
function Ly(t3, e) {
  return t3 = Math.abs(t3), e = Math.abs(e) - t3, Math.max(0, Ji(e) - Ji(t3)) + 1;
}
function Dy(t3, e, n, i) {
  var r = dy(t3, e, n), o;
  switch (i = ua(i ?? ",f"), i.type) {
    case "s": {
      var s = Math.max(Math.abs(t3), Math.abs(e));
      return i.precision == null && !isNaN(o = Iy(r, s)) && (i.precision = o), zc(i, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(o = Ly(r, Math.max(Math.abs(t3), Math.abs(e)))) && (i.precision = o - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(o = ky(r)) && (i.precision = o - (i.type === "%") * 2);
      break;
    }
  }
  return Fc(i);
}
function Rc(t3) {
  var e = t3.domain;
  return t3.ticks = function(n) {
    var i = e();
    return hy(i[0], i[i.length - 1], n ?? 10);
  }, t3.tickFormat = function(n, i) {
    var r = e();
    return Dy(r[0], r[r.length - 1], n ?? 10, i);
  }, t3.nice = function(n) {
    n == null && (n = 10);
    var i = e(), r = 0, o = i.length - 1, s = i[r], f = i[o], l, u, m = 10;
    for (f < s && (u = s, s = f, f = u, u = r, r = o, o = u); m-- > 0; ) {
      if (u = Pc(s, f, n), u === l)
        return i[r] = s, i[o] = f, e(i);
      if (u > 0)
        s = Math.floor(s / u) * u, f = Math.ceil(f / u) * u;
      else if (u < 0)
        s = Math.ceil(s * u) / u, f = Math.floor(f * u) / u;
      else
        break;
      l = u;
    }
    return t3;
  }, t3;
}
function $s() {
  var t3 = by();
  return t3.copy = function() {
    return Ic(t3, $s());
  }, kc.apply(t3, arguments), Rc(t3);
}
function Fu(t3) {
  return function(e) {
    return e < 0 ? -Math.pow(-e, t3) : Math.pow(e, t3);
  };
}
function Fy(t3) {
  return t3 < 0 ? -Math.sqrt(-t3) : Math.sqrt(t3);
}
function zy(t3) {
  return t3 < 0 ? -t3 * t3 : t3 * t3;
}
function Ry(t3) {
  var e = t3(An, An), n = 1;
  function i() {
    return n === 1 ? t3(An, An) : n === 0.5 ? t3(Fy, zy) : t3(Fu(n), Fu(1 / n));
  }
  return e.exponent = function(r) {
    return arguments.length ? (n = +r, i()) : n;
  }, Rc(e);
}
function Mc() {
  var t3 = Ry(Lc());
  return t3.copy = function() {
    return Ic(t3, Mc()).exponent(t3.exponent());
  }, kc.apply(t3, arguments), t3;
}
var My = (t3) => {
  const e = Mc().exponent(2).range([0, 1]).domain([-1, 1]), n = my(0, t3).map((r) => -0.5 + r / t3);
  n.push(0.5);
  const i = new Array(n.length * 2);
  return n.forEach((r, o) => {
    i[o * 2] = [e(r * 2), 0.5], i[o * 2 + 1] = [e(r * 2), -0.5];
  }), i;
};
var Oy = class extends Gn {
  initPrograms() {
    const { reglInstance: e, config: n, store: i } = this;
    this.updateLinkIndexFbo(), this.hoveredLineIndexFbo || (this.hoveredLineIndexFbo = e.framebuffer({
      color: e.texture({
        width: 1,
        height: 1,
        format: "rgba",
        type: "float"
      }),
      depth: false,
      stencil: false
    })), this.drawCurveCommand || (this.drawCurveCommand = e({
      vert: ry,
      frag: iy,
      attributes: {
        position: {
          buffer: () => this.curveLineBuffer,
          divisor: 0
        },
        pointA: {
          buffer: () => this.pointsBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 4
        },
        pointB: {
          buffer: () => this.pointsBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 2,
          stride: Float32Array.BYTES_PER_ELEMENT * 4
        },
        color: {
          buffer: () => this.colorBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 4
        },
        width: {
          buffer: () => this.widthBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 1
        },
        arrow: {
          buffer: () => this.arrowBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 1
        },
        linkIndices: {
          buffer: () => this.linkIndexBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 1
        }
      },
      uniforms: {
        positionsTexture: () => {
          var r;
          return (r = this.points) == null ? void 0 : r.currentPositionFbo;
        },
        pointGreyoutStatus: () => {
          var r;
          return (r = this.points) == null ? void 0 : r.greyoutStatusFbo;
        },
        transformationMatrix: () => i.transform,
        pointsTextureSize: () => i.pointsTextureSize,
        widthScale: () => n.linkWidthScale,
        linkArrowsSizeScale: () => n.linkArrowsSizeScale,
        spaceSize: () => i.adjustedSpaceSize,
        screenSize: () => i.screenSize,
        linkVisibilityDistanceRange: () => n.linkVisibilityDistanceRange,
        linkVisibilityMinTransparency: () => n.linkVisibilityMinTransparency,
        linkOpacity: () => n.linkOpacity,
        greyoutOpacity: () => n.linkGreyoutOpacity,
        scaleLinksOnZoom: () => n.scaleLinksOnZoom,
        maxPointSize: () => i.maxPointSize,
        curvedWeight: () => n.curvedLinkWeight,
        curvedLinkControlPointDistance: () => n.curvedLinkControlPointDistance,
        curvedLinkSegments: () => n.curvedLinks ? n.curvedLinkSegments ?? Ge.curvedLinkSegments : 1,
        hoveredLinkIndex: () => i.hoveredLinkIndex ?? -1,
        hoveredLinkColor: () => i.hoveredLinkColor,
        hoveredLinkWidthIncrease: () => n.hoveredLinkWidthIncrease,
        renderMode: e.prop("renderMode")
      },
      cull: {
        enable: true,
        face: "back"
      },
      /**
       * Blending behavior for link index rendering (renderMode: 1.0 - hover detection):
       *
       * When rendering link indices to the framebuffer, we use full opacity (1.0).
       * This means:
       * - The source color completely overwrites the destination
       * - No blending occurs - it's like drawing with a permanent marker
       * - This preserves the exact index values we need for picking/selection
       */
      blend: {
        enable: true,
        func: {
          dstRGB: "one minus src alpha",
          srcRGB: "src alpha",
          dstAlpha: "one minus src alpha",
          srcAlpha: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: {
        enable: false,
        mask: false
      },
      framebuffer: e.prop("framebuffer"),
      count: () => {
        var r;
        return ((r = this.curveLineGeometry) == null ? void 0 : r.length) ?? 0;
      },
      instances: () => this.data.linksNumber ?? 0,
      primitive: "triangle strip"
    })), this.hoveredLineIndexCommand || (this.hoveredLineIndexCommand = e({
      vert: ay,
      frag: oy,
      attributes: {
        position: {
          buffer: () => this.quadBuffer
        }
      },
      uniforms: {
        linkIndexTexture: () => this.linkIndexFbo,
        mousePosition: () => i.screenMousePosition,
        screenSize: () => i.screenSize
      },
      framebuffer: this.hoveredLineIndexFbo,
      count: 4,
      primitive: "triangle strip"
    })), this.quadBuffer || (this.quadBuffer = e.buffer([-1, -1, 1, -1, -1, 1, 1, 1]));
  }
  draw() {
    var e;
    this.pointsBuffer && (this.colorBuffer || this.updateColor(), this.widthBuffer || this.updateWidth(), this.arrowBuffer || this.updateArrow(), this.curveLineGeometry || this.updateCurveLineGeometry(), (e = this.drawCurveCommand) == null || e.call(this, { framebuffer: null, renderMode: 0 }));
  }
  updateLinkIndexFbo() {
    const { reglInstance: e, store: n } = this;
    this.store.isLinkHoveringEnabled && (this.linkIndexFbo || (this.linkIndexFbo = e.framebuffer()), this.linkIndexFbo({
      color: e.texture({
        width: n.screenSize[0],
        height: n.screenSize[1],
        format: "rgba",
        type: "float"
      }),
      depth: false,
      stencil: false
    }));
  }
  updatePointsBuffer() {
    const { reglInstance: e, data: n, store: i } = this;
    if (n.linksNumber === void 0 || n.links === void 0) return;
    const r = new Float32Array(n.linksNumber * 4);
    for (let s = 0; s < n.linksNumber; s++) {
      const f = n.links[s * 2], l = n.links[s * 2 + 1], u = f % i.pointsTextureSize, m = Math.floor(f / i.pointsTextureSize), y = l % i.pointsTextureSize, S = Math.floor(l / i.pointsTextureSize), D = s * 4;
      r[D] = u, r[D + 1] = m, r[D + 2] = y, r[D + 3] = S;
    }
    this.pointsBuffer || (this.pointsBuffer = e.buffer(0)), this.pointsBuffer(r);
    const o = new Float32Array(n.linksNumber);
    for (let s = 0; s < n.linksNumber; s++)
      o[s] = s;
    this.linkIndexBuffer || (this.linkIndexBuffer = e.buffer(0)), this.linkIndexBuffer(o);
  }
  updateColor() {
    const { reglInstance: e, data: n } = this;
    this.colorBuffer || (this.colorBuffer = e.buffer(0)), this.colorBuffer(n.linkColors ?? new Float32Array());
  }
  updateWidth() {
    const { reglInstance: e, data: n } = this;
    this.widthBuffer || (this.widthBuffer = e.buffer(0)), this.widthBuffer(n.linkWidths ?? new Float32Array());
  }
  updateArrow() {
    const { reglInstance: e, data: n } = this;
    this.arrowBuffer || (this.arrowBuffer = e.buffer(0)), this.arrowBuffer(n.linkArrows ?? new Float32Array());
  }
  updateCurveLineGeometry() {
    const { reglInstance: e, config: { curvedLinks: n, curvedLinkSegments: i } } = this;
    this.curveLineGeometry = My(n ? i ?? Ge.curvedLinkSegments : 1), this.curveLineBuffer || (this.curveLineBuffer = e.buffer(0)), this.curveLineBuffer(this.curveLineGeometry);
  }
  findHoveredLine() {
    var e, n;
    !this.data.linksNumber || !this.store.isLinkHoveringEnabled || (this.linkIndexFbo || this.updateLinkIndexFbo(), this.reglInstance.clear({
      framebuffer: this.linkIndexFbo,
      color: [0, 0, 0, 0]
    }), (e = this.drawCurveCommand) == null || e.call(this, { framebuffer: this.linkIndexFbo, renderMode: 1 }), (n = this.hoveredLineIndexCommand) == null || n.call(this));
  }
};
var Ny = `#ifdef GL_ES
precision highp float;
#endif

uniform float greyoutOpacity;
uniform float pointOpacity;
uniform sampler2D imageAtlasTexture;
uniform bool isDarkenGreyout;
uniform vec4 backgroundColor;

varying float pointShape;
varying float isGreyedOut;
varying vec4 shapeColor;
varying vec4 imageAtlasUV;
varying float shapeSize;
varying float imageSizeVarying;
varying float overallSize;

const float smoothing = 0.9;

const float CIRCLE = 0.0;
const float SQUARE = 1.0;
const float TRIANGLE = 2.0;
const float DIAMOND = 3.0;
const float PENTAGON = 4.0;
const float HEXAGON = 5.0;
const float STAR = 6.0;
const float CROSS = 7.0;
const float NONE = 8.0;

float circleDistance(vec2 p) {
    return dot(p, p);
}

vec4 applyGreyoutToImage(vec4 imageColor) {
    vec3 finalColor = imageColor.rgb;
    float finalAlpha = imageColor.a;
    
    if (isGreyedOut > 0.0) {
        float blendFactor = 0.65; 
        
        if (isDarkenGreyout) {
            finalColor = mix(finalColor, vec3(0.2), blendFactor);
        } else {
            finalColor = mix(finalColor, max(backgroundColor.rgb, vec3(0.8)), blendFactor);
        }
    }
    
    return vec4(finalColor, finalAlpha);
}

float squareDistance(vec2 p) {
    vec2 d = abs(p) - vec2(0.8);
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

float triangleDistance(vec2 p) {
    const float k = sqrt(3.0);   
    p.x = abs(p.x) - 0.9;        
    p.y = p.y + 0.55;             

    
    if (p.x + k * p.y > 0.0)
        p = vec2(p.x - k * p.y,  -k * p.x - p.y) / 2.0;

    p.x -= clamp(p.x, -1.0, 0.0); 

    
    return -length(p) * sign(p.y);
}

float diamondDistance(vec2 p) {
    
    const float aspect = 1.2;
    return abs(p.x) + abs(p.y) / aspect - 0.8;
}

float pentagonDistance(vec2 p) {
    
    const vec3 k = vec3(0.809016994, 0.587785252, 0.726542528);
    p.x = abs(p.x);

    
    p -= 2.0 * min(dot(vec2(-k.x, k.y), p), 0.0) * vec2(-k.x, k.y);
    p -= 2.0 * min(dot(vec2( k.x, k.y), p), 0.0) * vec2( k.x, k.y);

    
    p -= vec2(clamp(p.x, -k.z * k.x, k.z * k.x), k.z);

    
    return length(p) * sign(p.y);
}

float hexagonDistance(vec2 p) {
    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);
    p = abs(p);
    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;
    p -= vec2(clamp(p.x, -k.z * 0.8, k.z * 0.8), 0.8);
    return length(p) * sign(p.y);
}

float starDistance(vec2 p) {
    
    
    const float r  = 0.9;
    const float rf = 0.45;

    
    const vec2 k1 = vec2(0.809016994, -0.587785252);
    const vec2 k2 = vec2(-k1.x, k1.y);

    
    p.x = abs(p.x);
    p -= 2.0 * max(dot(k1, p), 0.0) * k1;
    p -= 2.0 * max(dot(k2, p), 0.0) * k2;
    p.x = abs(p.x);

    
    p.y -= r;

    
    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);
    
    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);

    
    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);
}

float crossDistance(vec2 p) {
    
    
    
    p = abs(p);
    if (p.y > p.x) p = p.yx;       

    vec2 q = p - vec2(0.8, 0.3);   

    
    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);
}

float getShapeDistance(vec2 p, float shape) {
    if (shape == SQUARE) return squareDistance(p);
    else if (shape == TRIANGLE) return triangleDistance(p);
    else if (shape == DIAMOND) return diamondDistance(p);
    else if (shape == PENTAGON) return pentagonDistance(p);
    else if (shape == HEXAGON) return hexagonDistance(p);
    else if (shape == STAR) return starDistance(p);
    else if (shape == CROSS) return crossDistance(p);
    else return circleDistance(p); 
}

void main() {
    
    if (shapeColor.a == 0.0 && imageAtlasUV.x == -1.0) {
        discard;
    }

    
    if (pointShape == NONE && imageAtlasUV.x == -1.0) {
        discard;
    }

    
    vec2 pointCoord = 2.0 * gl_PointCoord - 1.0;

    vec4 finalShapeColor = vec4(0.0);
    vec4 finalImageColor = vec4(0.0);
    
    
    if (pointShape != NONE) {
        
        vec2 shapeCoord = pointCoord;
        if (overallSize > shapeSize && shapeSize > 0.0) {
            
            float scale = shapeSize / overallSize;
            shapeCoord = pointCoord / scale;
        }
        
        float opacity;
        if (pointShape == CIRCLE) {
            
            float pointCenterDistance = dot(shapeCoord, shapeCoord);
            opacity = 1.0 - smoothstep(smoothing, 1.0, pointCenterDistance);
        } else {
            
            float shapeDistance = getShapeDistance(shapeCoord, pointShape);
            opacity = 1.0 - smoothstep(-0.01, 0.01, shapeDistance);
        }
        opacity *= shapeColor.a;

        finalShapeColor = vec4(shapeColor.rgb, opacity);
    }

    
    if (imageAtlasUV.x != -1.0) {
        
        vec2 imageCoord = pointCoord;
        if (overallSize > imageSizeVarying && imageSizeVarying > 0.0) {
            
            float scale = imageSizeVarying / overallSize;
            imageCoord = pointCoord / scale;
            
            
            if (abs(imageCoord.x) > 1.0 || abs(imageCoord.y) > 1.0) {
                
                finalImageColor = vec4(0.0);
            } else {
                
                vec2 atlasUV = mix(imageAtlasUV.xy, imageAtlasUV.zw, (imageCoord + 1.0) * 0.5);
                vec4 imageColor = texture2D(imageAtlasTexture, atlasUV);
                finalImageColor = applyGreyoutToImage(imageColor);
            }
        } else {
            
            
            vec2 atlasUV = mix(imageAtlasUV.xy, imageAtlasUV.zw, (imageCoord + 1.0) * 0.5);
            vec4 imageColor = texture2D(imageAtlasTexture, atlasUV);
            finalImageColor = applyGreyoutToImage(imageColor);
        }
    }

    float finalPointAlpha = max(finalShapeColor.a, finalImageColor.a);
    if (isGreyedOut > 0.0 && greyoutOpacity != -1.0) {
        finalPointAlpha *= greyoutOpacity;
    } else {
        finalPointAlpha *= pointOpacity;
    }

    
    gl_FragColor = vec4(
        mix(finalShapeColor.rgb, finalImageColor.rgb, finalImageColor.a),
        finalPointAlpha
    );
}`;
var Gy = `#ifdef GL_ES
precision highp float;
#endif

attribute vec2 pointIndices;
attribute float size;
attribute vec4 color;
attribute float shape;
attribute float imageIndex;
attribute float imageSize;

uniform sampler2D positionsTexture;
uniform sampler2D pointGreyoutStatus;
uniform sampler2D imageAtlasCoords;
uniform float ratio;
uniform mat3 transformationMatrix;
uniform float pointsTextureSize;
uniform float sizeScale;
uniform float spaceSize;
uniform vec2 screenSize;

uniform vec4 greyoutColor;
uniform vec4 backgroundColor;
uniform bool scalePointsOnZoom;
uniform float maxPointSize;
uniform bool isDarkenGreyout;
uniform bool skipSelected;
uniform bool skipUnselected;
uniform bool hasImages;
uniform float imageCount;
uniform float imageAtlasCoordsTextureSize;

varying float pointShape;
varying float isGreyedOut;
varying vec4 shapeColor;
varying vec4 imageAtlasUV;
varying float shapeSize;
varying float imageSizeVarying;
varying float overallSize;

float calculatePointSize(float size) {
  float pSize;
  if (scalePointsOnZoom) { 
    pSize = size * ratio * transformationMatrix[0][0];
  } else {
    pSize = size * ratio * min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
  }

  return min(pSize, maxPointSize * ratio);
}

void main() {    
  
  vec4 greyoutStatus = texture2D(pointGreyoutStatus, (pointIndices + 0.5) / pointsTextureSize);
  isGreyedOut = greyoutStatus.r;
  bool isSelected = greyoutStatus.r == 0.0;
  
  
  if (skipSelected && isSelected) {
    gl_Position = vec4(2.0, 2.0, 2.0, 1.0); 
    gl_PointSize = 0.0;
    return;
  }
  if (skipUnselected && !isSelected) {
    gl_Position = vec4(2.0, 2.0, 2.0, 1.0); 
    gl_PointSize = 0.0;
    return;
  }
  
  
  vec4 pointPosition = texture2D(positionsTexture, (pointIndices + 0.5) / pointsTextureSize);
  vec2 point = pointPosition.rg;

  
  vec2 normalizedPosition = 2.0 * point / spaceSize - 1.0;
  normalizedPosition *= spaceSize / screenSize;
  vec3 finalPosition = transformationMatrix * vec3(normalizedPosition, 1);
  gl_Position = vec4(finalPosition.rg, 0, 1);

  
  float shapeSizeValue = calculatePointSize(size * sizeScale);
  float imageSizeValue = calculatePointSize(imageSize * sizeScale);
  
  
  float overallSizeValue = max(shapeSizeValue, imageSizeValue);
  gl_PointSize = overallSizeValue;

  
  shapeSize = shapeSizeValue;
  imageSizeVarying = imageSizeValue;
  overallSize = overallSizeValue;

  shapeColor = color;
  pointShape = shape;

  
  if (isGreyedOut > 0.0) {
    if (greyoutColor[0] != -1.0) {
      shapeColor = greyoutColor;
    } else {
      
      float blendFactor = 0.65; 
      
      if (isDarkenGreyout) {
        
        shapeColor.rgb = mix(shapeColor.rgb, vec3(0.2), blendFactor);
      } else {
        
        shapeColor.rgb = mix(shapeColor.rgb, max(backgroundColor.rgb, vec3(0.8)), blendFactor);
      }
    }
  }

  if (!hasImages || imageIndex < 0.0 || imageIndex >= imageCount) {
    imageAtlasUV = vec4(-1.0);
    return;
  }
  
  float atlasCoordIndex = imageIndex;
  
  float texX = mod(atlasCoordIndex, imageAtlasCoordsTextureSize);
  float texY = floor(atlasCoordIndex / imageAtlasCoordsTextureSize);
  
  vec2 atlasCoordTexCoord = (vec2(texX, texY) + 0.5) / imageAtlasCoordsTextureSize;
  vec4 atlasCoords = texture2D(imageAtlasCoords, atlasCoordTexCoord);
  imageAtlasUV = atlasCoords;
}`;
var By = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D pointSize;
uniform float sizeScale;
uniform float spaceSize;
uniform vec2 screenSize;
uniform float ratio;
uniform mat3 transformationMatrix;
uniform vec2 selection0;
uniform vec2 selection1;
uniform bool scalePointsOnZoom;
uniform float maxPointSize;

varying vec2 textureCoords;

float pointSizeF(float size) {
  float pSize;
  if (scalePointsOnZoom) { 
    pSize = size * ratio * transformationMatrix[0][0];
  } else {
    pSize = size * ratio * min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
  }
  return min(pSize, maxPointSize * ratio);
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec2 p = 2.0 * pointPosition.rg / spaceSize - 1.0;
  p *= spaceSize / screenSize;
  vec3 final = transformationMatrix * vec3(p, 1);

  vec4 pSize = texture2D(pointSize, textureCoords);
  float size = pSize.r * sizeScale;

  float left = 2.0 * (selection0.x - 0.5 * pointSizeF(size)) / screenSize.x - 1.0;
  float right = 2.0 * (selection1.x + 0.5 * pointSizeF(size)) / screenSize.x - 1.0;
  float top =  2.0 * (selection0.y - 0.5 * pointSizeF(size)) / screenSize.y - 1.0;
  float bottom =  2.0 * (selection1.y + 0.5 * pointSizeF(size)) / screenSize.y - 1.0;

  gl_FragColor = vec4(0.0, 0.0, pointPosition.rg);
  if (final.x >= left && final.x <= right && final.y >= top && final.y <= bottom) {
    gl_FragColor.r = 1.0;
  }
}`;
var Uy = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D polygonPathTexture; 
uniform int polygonPathLength;
uniform float spaceSize;
uniform vec2 screenSize;
uniform mat3 transformationMatrix;

varying vec2 textureCoords;

vec2 getPolygonPoint(sampler2D pathTexture, int index, int pathLength) {
  if (index >= pathLength) return vec2(0.0);
  
  
  int textureSize = int(ceil(sqrt(float(pathLength))));
  int x = index - (index / textureSize) * textureSize;
  int y = index / textureSize;
  
  vec2 texCoord = (vec2(float(x), float(y)) + 0.5) / float(textureSize);
  vec4 pathData = texture2D(pathTexture, texCoord);
  
  return pathData.xy;
}

bool pointInPolygon(vec2 point, sampler2D pathTexture, int pathLength) {
  bool inside = false;
  
  for (int i = 0; i < 2048; i++) {
    if (i >= pathLength) break;
    
    int j = int(mod(float(i + 1), float(pathLength)));
    
    vec2 pi = getPolygonPoint(pathTexture, i, pathLength);
    vec2 pj = getPolygonPoint(pathTexture, j, pathLength);
    
    if (((pi.y > point.y) != (pj.y > point.y)) &&
        (point.x < (pj.x - pi.x) * (point.y - pi.y) / (pj.y - pi.y) + pi.x)) {
      inside = !inside;
    }
  }
  
  return inside;
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec2 p = 2.0 * pointPosition.rg / spaceSize - 1.0;
  p *= spaceSize / screenSize;
  vec3 final = transformationMatrix * vec3(p, 1);

  
  vec2 screenPos = (final.xy + 1.0) * screenSize / 2.0;
  
  gl_FragColor = vec4(0.0, 0.0, pointPosition.rg);
  
  
  if (pointInPolygon(screenPos, polygonPathTexture, polygonPathLength)) {
    gl_FragColor.r = 1.0;
  }
}`;
var Vy = `precision mediump float;

uniform float width;

varying vec2 vertexPosition;
varying float pointOpacity;
varying vec3 rgbColor;

const float smoothing = 1.05;

void main () {
  float r = dot(vertexPosition, vertexPosition);
  float opacity = smoothstep(r, r * smoothing, 1.0);
  float stroke = smoothstep(width, width * smoothing, r);
  gl_FragColor = vec4(rgbColor, opacity * stroke * pointOpacity);
}`;
var $y = `precision mediump float;

attribute vec2 vertexCoord;

uniform sampler2D positionsTexture;
uniform sampler2D pointGreyoutStatusTexture;
uniform float size;
uniform mat3 transformationMatrix;
uniform float pointsTextureSize;
uniform float sizeScale;
uniform float spaceSize;
uniform vec2 screenSize;
uniform bool scalePointsOnZoom;
uniform float pointIndex;
uniform float maxPointSize;
uniform vec4 color;
uniform float universalPointOpacity;
uniform float greyoutOpacity;
uniform bool isDarkenGreyout;
uniform vec4 backgroundColor;
uniform vec4 greyoutColor;
varying vec2 vertexPosition;
varying float pointOpacity;
varying vec3 rgbColor;

float calculatePointSize(float size) {
  float pSize;
  if (scalePointsOnZoom) { 
    pSize = size * transformationMatrix[0][0];
  } else {
    pSize = size * min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
  }
  return min(pSize, maxPointSize);
}

const float relativeRingRadius = 1.3;

void main () {
  vertexPosition = vertexCoord;

  vec2 textureCoordinates = vec2(mod(pointIndex, pointsTextureSize), floor(pointIndex / pointsTextureSize)) + 0.5;
  vec4 pointPosition = texture2D(positionsTexture, textureCoordinates / pointsTextureSize);

  rgbColor = color.rgb;
  pointOpacity = color.a * universalPointOpacity;
  vec4 greyoutStatus = texture2D(pointGreyoutStatusTexture, textureCoordinates / pointsTextureSize);
  if (greyoutStatus.r > 0.0) {
    if (greyoutColor[0] != -1.0) {
      rgbColor = greyoutColor.rgb;
      pointOpacity = greyoutColor.a;
    } else {
      
      float blendFactor = 0.65; 
      
      if (isDarkenGreyout) {
        
        rgbColor = mix(rgbColor, vec3(0.2), blendFactor);
      } else {
        
        rgbColor = mix(rgbColor, max(backgroundColor.rgb, vec3(0.8)), blendFactor);
      }
    }

    if (greyoutOpacity != -1.0) {
      pointOpacity *= greyoutOpacity;
    }
  }

  
  float pointSize = (calculatePointSize(size * sizeScale) * relativeRingRadius) / transformationMatrix[0][0];
  float radius = pointSize * 0.5;

  
  vec2 a = pointPosition.xy;
  vec2 b = pointPosition.xy + vec2(0.0, radius);
  vec2 xBasis = b - a;
  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));
  vec2 pointPositionInScreenSpace = a + xBasis * vertexCoord.x + yBasis * radius * vertexCoord.y;

  
  vec2 p = 2.0 * pointPositionInScreenSpace / spaceSize - 1.0;
  p *= spaceSize / screenSize;
  vec3 final =  transformationMatrix * vec3(p, 1);
  
  gl_Position = vec4(final.rg, 0, 1);
}`;
var Hy = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var Wy = `#ifdef GL_ES
precision highp float;
#endif

attribute float size;

uniform sampler2D positionsTexture;
uniform float pointsTextureSize;
uniform float sizeScale;
uniform float spaceSize;
uniform vec2 screenSize;
uniform float ratio;
uniform mat3 transformationMatrix;
uniform vec2 mousePosition;
uniform bool scalePointsOnZoom;
uniform float maxPointSize;

attribute vec2 pointIndices;

varying vec4 rgba;

float calculatePointSize(float size) {
  float pSize;
  if (scalePointsOnZoom) { 
    pSize = size * ratio * transformationMatrix[0][0];
  } else {
    pSize = size * ratio * min(5.0, max(1.0, transformationMatrix[0][0] * 0.01));
  }
  return min(pSize, maxPointSize * ratio);
}

float euclideanDistance (float x1, float x2, float y1, float y2) {
  return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}

void main() {
  vec4 pointPosition = texture2D(positionsTexture, (pointIndices + 0.5) / pointsTextureSize);

  
  vec2 normalizedPoint = 2.0 * pointPosition.rg / spaceSize - 1.0;
  normalizedPoint *= spaceSize / screenSize;
  vec3 finalPosition = transformationMatrix * vec3(normalizedPoint, 1);

  float pointRadius = 0.5 * calculatePointSize(size * sizeScale);

  vec2 pointScreenPosition = (finalPosition.xy + 1.0) * screenSize / 2.0;
  rgba = vec4(0.0);
  gl_Position = vec4(0.5, 0.5, 0.0, 1.0);
  
  if (euclideanDistance(pointScreenPosition.x, mousePosition.x, pointScreenPosition.y, mousePosition.y) < pointRadius / ratio) {
    float index = pointIndices.g * pointsTextureSize + pointIndices.r;
    rgba = vec4(index, size, pointPosition.xy);
    gl_Position = vec4(-0.5, -0.5, 0.0, 1.0);
  }

  gl_PointSize = 1.0;
}`;
var Xy = `#ifdef GL_ES
precision highp float;
#endif

varying vec4 rgba;

void main() {
  gl_FragColor = rgba;
}`;
var jy = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform float pointsTextureSize;
uniform float spaceSize;
uniform vec2 screenSize;
uniform mat3 transformationMatrix;

attribute vec2 pointIndices;

varying vec4 rgba;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, (pointIndices + 0.5) / pointsTextureSize);
  vec2 p = 2.0 * pointPosition.rg / spaceSize - 1.0;
  p *= spaceSize / screenSize;
  vec3 final = transformationMatrix * vec3(p, 1);

  vec2 pointScreenPosition = (final.xy + 1.0) * screenSize / 2.0;
  float index = pointIndices.g * pointsTextureSize + pointIndices.r;
  rgba = vec4(index, 1.0, pointPosition.xy);
  float i = (pointScreenPosition.x + 0.5) / screenSize.x;
  float j = (pointScreenPosition.y + 0.5) / screenSize.y;
  gl_Position = vec4(2.0 * vec2(i, j) - 1.0, 0.0, 1.0);

  gl_PointSize = 1.0;
}`;
var qy = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D velocity;
uniform float friction;
uniform float spaceSize;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);
  vec4 pointVelocity = texture2D(velocity, textureCoords);

  
  pointVelocity.rg *= friction;

  pointPosition.rg += pointVelocity.rg;

  pointPosition.r = clamp(pointPosition.r, 0.0, spaceSize);
  pointPosition.g = clamp(pointPosition.g, 0.0, spaceSize);
  
  gl_FragColor = pointPosition;
}`;
var Yy = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform sampler2D trackedIndices;
uniform float pointsTextureSize;

varying vec2 textureCoords;

void main() {
  vec4 trackedPointIndices = texture2D(trackedIndices, textureCoords);
  if (trackedPointIndices.r < 0.0) discard;
  vec4 pointPosition = texture2D(positionsTexture, (trackedPointIndices.rg + 0.5) / pointsTextureSize);

  gl_FragColor = vec4(pointPosition.rg, 1.0, 1.0);
}`;
var Zy = `#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D positionsTexture;
uniform vec2 mousePos;
uniform float index;

varying vec2 textureCoords;

void main() {
  vec4 pointPosition = texture2D(positionsTexture, textureCoords);

  
  if (index >= 0.0 && index == pointPosition.b) {
    pointPosition.rg = mousePos.rg;
  }

  gl_FragColor = pointPosition;
}`;
function Qy(t3, e = 16384) {
  if (!(t3 != null && t3.length))
    return null;
  let n = 0;
  for (const u of t3) {
    const m = Math.max(u.width, u.height);
    m > n && (n = m);
  }
  if (n === 0)
    return console.warn("Invalid image dimensions: all images have zero width or height"), null;
  const i = n, r = Math.ceil(Math.sqrt(t3.length));
  let o = r * n, s = 1;
  o > e && (s = e / o, n = Math.max(1, Math.floor(n * s)), o = Math.max(1, Math.floor(o * s)), console.warn(
    `  Atlas scaling required: Original size ${(i * r).toLocaleString()}px exceeds WebGL limit ${e.toLocaleString()}px. Scaling down to ${o.toLocaleString()}px (${Math.round(s * 100)}% of original quality)`
  ));
  const f = new Uint8Array(o * o * 4).fill(0), l = new Float32Array(r * r * 4).fill(-1);
  for (const [u, m] of t3.entries()) {
    const y = m.width, S = m.height;
    if (y === 0 || S === 0)
      continue;
    const D = Math.min(1, n / Math.max(y, S)), q = Math.floor(y * D), Te = Math.floor(S * D), we = Math.floor(u / r), Oe = u % r * n, Ve = we * n;
    l[u * 4] = Oe / o, l[u * 4 + 1] = Ve / o, l[u * 4 + 2] = (Oe + q) / o, l[u * 4 + 3] = (Ve + Te) / o;
    for (let V = 0; V < Te; V++)
      for (let se = 0; se < q; se++) {
        const Le = Math.floor(se * (y / q)), Xe = (Math.floor(V * (S / Te)) * y + Le) * 4, nt = ((Ve + V) * o + (Oe + se)) * 4;
        f[nt] = m.data[Xe] ?? 0, f[nt + 1] = m.data[Xe + 1] ?? 0, f[nt + 2] = m.data[Xe + 2] ?? 0, f[nt + 3] = m.data[Xe + 3] ?? 255;
      }
  }
  return {
    atlasData: f,
    atlasSize: o,
    atlasCoords: l,
    atlasCoordsSize: r
  };
}
var Ky = class extends Gn {
  constructor() {
    super(...arguments), this.imageCount = 0, this.isPositionsUpToDate = false, this.polygonPathLength = 0;
  }
  updatePositions() {
    const { reglInstance: e, store: n, data: i, config: { rescalePositions: r, enableSimulation: o } } = this, { pointsTextureSize: s } = n;
    if (!s || !i.pointPositions || i.pointsNumber === void 0) return;
    const f = new Float32Array(s * s * 4);
    let l = r;
    r === void 0 && !o && (l = true), this.shouldSkipRescale && (l = false), l ? this.rescaleInitialNodePositions() : this.shouldSkipRescale || (this.scaleX = void 0, this.scaleY = void 0), this.shouldSkipRescale = void 0;
    for (let u = 0; u < i.pointsNumber; ++u)
      f[u * 4 + 0] = i.pointPositions[u * 2 + 0], f[u * 4 + 1] = i.pointPositions[u * 2 + 1], f[u * 4 + 2] = u;
    this.currentPositionFbo || (this.currentPositionFbo = e.framebuffer()), this.currentPositionFbo({
      color: e.texture({
        data: f,
        shape: [s, s, 4],
        type: "float"
      }),
      depth: false,
      stencil: false
    }), this.previousPositionFbo || (this.previousPositionFbo = e.framebuffer()), this.previousPositionFbo({
      color: e.texture({
        data: f,
        shape: [s, s, 4],
        type: "float"
      }),
      depth: false,
      stencil: false
    }), this.config.enableSimulation && (this.velocityFbo || (this.velocityFbo = e.framebuffer()), this.velocityFbo({
      color: e.texture({
        data: new Float32Array(s * s * 4).fill(0),
        shape: [s, s, 4],
        type: "float"
      }),
      depth: false,
      stencil: false
    })), this.selectedTexture || (this.selectedTexture = e.texture()), this.selectedTexture({
      data: f,
      shape: [s, s, 4],
      type: "float"
    }), this.selectedFbo || (this.selectedFbo = e.framebuffer()), this.selectedFbo({
      color: this.selectedTexture,
      depth: false,
      stencil: false
    }), this.hoveredFbo || (this.hoveredFbo = e.framebuffer()), this.hoveredFbo({
      shape: [2, 2],
      colorType: "float",
      depth: false,
      stencil: false
    }), this.drawPointIndices || (this.drawPointIndices = e.buffer(0)), this.drawPointIndices(Ti(n.pointsTextureSize)), this.hoveredPointIndices || (this.hoveredPointIndices = e.buffer(0)), this.hoveredPointIndices(Ti(n.pointsTextureSize)), this.sampledPointIndices || (this.sampledPointIndices = e.buffer(0)), this.sampledPointIndices(Ti(n.pointsTextureSize)), this.updateGreyoutStatus(), this.updateSampledPointsGrid(), this.trackPointsByIndices();
  }
  initPrograms() {
    const { reglInstance: e, config: n, store: i, data: r } = this;
    n.enableSimulation && (this.updatePositionCommand || (this.updatePositionCommand = e({
      frag: qy,
      vert: Dt,
      framebuffer: () => this.currentPositionFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => this.previousPositionFbo,
        velocity: () => this.velocityFbo,
        friction: () => n.simulationFriction,
        spaceSize: () => i.adjustedSpaceSize
      }
    }))), this.dragPointCommand || (this.dragPointCommand = e({
      frag: Zy,
      vert: Dt,
      framebuffer: () => this.currentPositionFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => this.previousPositionFbo,
        mousePos: () => i.mousePosition,
        index: () => {
          var o;
          return ((o = i.hoveredPoint) == null ? void 0 : o.index) ?? -1;
        }
      }
    })), this.drawCommand || (this.drawCommand = e({
      frag: Ny,
      vert: Gy,
      primitive: "points",
      count: () => r.pointsNumber ?? 0,
      attributes: {
        pointIndices: {
          buffer: this.drawPointIndices,
          size: 2
        },
        size: {
          buffer: () => this.sizeBuffer,
          size: 1
        },
        color: {
          buffer: () => this.colorBuffer,
          size: 4
        },
        shape: {
          buffer: () => this.shapeBuffer,
          size: 1
        },
        imageIndex: {
          buffer: () => this.imageIndicesBuffer,
          size: 1
        },
        imageSize: {
          buffer: () => this.imageSizesBuffer,
          size: 1
        }
      },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        pointGreyoutStatus: () => this.greyoutStatusFbo,
        ratio: () => n.pixelRatio,
        sizeScale: () => n.pointSizeScale,
        pointsTextureSize: () => i.pointsTextureSize,
        transformationMatrix: () => i.transform,
        spaceSize: () => i.adjustedSpaceSize,
        screenSize: () => i.screenSize,
        pointOpacity: () => n.pointOpacity,
        greyoutOpacity: () => n.pointGreyoutOpacity ?? -1,
        greyoutColor: () => i.greyoutPointColor,
        backgroundColor: () => i.backgroundColor,
        isDarkenGreyout: () => i.isDarkenGreyout,
        scalePointsOnZoom: () => n.scalePointsOnZoom,
        maxPointSize: () => i.maxPointSize,
        skipSelected: e.prop("skipSelected"),
        skipUnselected: e.prop("skipUnselected"),
        imageAtlasTexture: () => this.imageAtlasTexture,
        imageAtlasCoords: () => this.imageAtlasCoordsTexture,
        hasImages: () => this.imageCount > 0,
        imageCount: () => this.imageCount,
        imageAtlasCoordsTextureSize: () => this.imageAtlasCoordsTextureSize
      },
      blend: {
        enable: true,
        func: {
          dstRGB: "one minus src alpha",
          srcRGB: "src alpha",
          dstAlpha: "one minus src alpha",
          srcAlpha: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: {
        enable: false,
        mask: false
      }
    })), this.findPointsOnAreaSelectionCommand || (this.findPointsOnAreaSelectionCommand = e({
      frag: By,
      vert: Dt,
      framebuffer: () => this.selectedFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: {
        vertexCoord: Pt(e)
      },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        pointSize: () => this.sizeFbo,
        spaceSize: () => i.adjustedSpaceSize,
        screenSize: () => i.screenSize,
        sizeScale: () => n.pointSizeScale,
        transformationMatrix: () => i.transform,
        ratio: () => n.pixelRatio,
        selection0: () => i.selectedArea[0],
        selection1: () => i.selectedArea[1],
        scalePointsOnZoom: () => n.scalePointsOnZoom,
        maxPointSize: () => i.maxPointSize
      }
    })), this.findPointsOnPolygonSelectionCommand || (this.findPointsOnPolygonSelectionCommand = e({
      frag: Uy,
      vert: Dt,
      framebuffer: () => this.selectedFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: {
        vertexCoord: Pt(e)
      },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        spaceSize: () => i.adjustedSpaceSize,
        screenSize: () => i.screenSize,
        transformationMatrix: () => i.transform,
        polygonPathTexture: () => this.polygonPathTexture,
        polygonPathLength: () => this.polygonPathLength
      }
    })), this.clearHoveredFboCommand || (this.clearHoveredFboCommand = e({
      frag: Ai,
      vert: Dt,
      framebuffer: this.hoveredFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) }
    })), this.findHoveredPointCommand || (this.findHoveredPointCommand = e({
      frag: Hy,
      vert: Wy,
      primitive: "points",
      count: () => r.pointsNumber ?? 0,
      framebuffer: () => this.hoveredFbo,
      attributes: {
        pointIndices: {
          buffer: this.hoveredPointIndices,
          size: 2
        },
        size: {
          buffer: () => this.sizeBuffer,
          size: 1
        }
      },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        ratio: () => n.pixelRatio,
        sizeScale: () => n.pointSizeScale,
        pointsTextureSize: () => i.pointsTextureSize,
        transformationMatrix: () => i.transform,
        spaceSize: () => i.adjustedSpaceSize,
        screenSize: () => i.screenSize,
        scalePointsOnZoom: () => n.scalePointsOnZoom,
        mousePosition: () => i.screenMousePosition,
        maxPointSize: () => i.maxPointSize
      },
      depth: {
        enable: false,
        mask: false
      }
    })), this.clearSampledPointsFboCommand || (this.clearSampledPointsFboCommand = e({
      frag: Ai,
      vert: Dt,
      framebuffer: () => this.sampledPointsFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) }
    })), this.fillSampledPointsFboCommand || (this.fillSampledPointsFboCommand = e({
      frag: Xy,
      vert: jy,
      primitive: "points",
      count: () => r.pointsNumber ?? 0,
      framebuffer: () => this.sampledPointsFbo,
      attributes: {
        pointIndices: {
          buffer: this.sampledPointIndices,
          size: 2
        }
      },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        pointsTextureSize: () => i.pointsTextureSize,
        transformationMatrix: () => i.transform,
        spaceSize: () => i.adjustedSpaceSize,
        screenSize: () => i.screenSize
      },
      depth: {
        enable: false,
        mask: false
      }
    })), this.drawHighlightedCommand || (this.drawHighlightedCommand = e({
      frag: Vy,
      vert: $y,
      attributes: { vertexCoord: Pt(e) },
      primitive: "triangle strip",
      count: 4,
      uniforms: {
        color: e.prop("color"),
        width: e.prop("width"),
        pointIndex: e.prop("pointIndex"),
        size: e.prop("size"),
        positionsTexture: () => this.currentPositionFbo,
        sizeScale: () => n.pointSizeScale,
        pointsTextureSize: () => i.pointsTextureSize,
        transformationMatrix: () => i.transform,
        spaceSize: () => i.adjustedSpaceSize,
        screenSize: () => i.screenSize,
        scalePointsOnZoom: () => n.scalePointsOnZoom,
        maxPointSize: () => i.maxPointSize,
        pointGreyoutStatusTexture: () => this.greyoutStatusFbo,
        universalPointOpacity: () => n.pointOpacity,
        greyoutOpacity: () => n.pointGreyoutOpacity ?? -1,
        isDarkenGreyout: () => i.isDarkenGreyout,
        backgroundColor: () => i.backgroundColor,
        greyoutColor: () => i.greyoutPointColor
      },
      blend: {
        enable: true,
        func: {
          dstRGB: "one minus src alpha",
          srcRGB: "src alpha",
          dstAlpha: "one minus src alpha",
          srcAlpha: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: {
        enable: false,
        mask: false
      }
    })), this.trackPointsCommand || (this.trackPointsCommand = e({
      frag: Yy,
      vert: Dt,
      framebuffer: () => this.trackedPositionsFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { vertexCoord: Pt(e) },
      uniforms: {
        positionsTexture: () => this.currentPositionFbo,
        trackedIndices: () => this.trackedIndicesFbo,
        pointsTextureSize: () => i.pointsTextureSize
      }
    }));
  }
  updateColor() {
    const { reglInstance: e, store: { pointsTextureSize: n }, data: i } = this;
    n && (this.colorBuffer || (this.colorBuffer = e.buffer(0)), this.colorBuffer(i.pointColors));
  }
  updateGreyoutStatus() {
    const { reglInstance: e, store: { selectedIndices: n, pointsTextureSize: i } } = this;
    if (!i) return;
    const r = new Float32Array(i * i * 4).fill(n ? 1 : 0);
    if (n)
      for (const o of n)
        r[o * 4] = 0;
    this.greyoutStatusTexture || (this.greyoutStatusTexture = e.texture()), this.greyoutStatusTexture({
      data: r,
      width: i,
      height: i,
      type: "float"
    }), this.greyoutStatusFbo || (this.greyoutStatusFbo = e.framebuffer()), this.greyoutStatusFbo({
      color: this.greyoutStatusTexture,
      depth: false,
      stencil: false
    });
  }
  updateSize() {
    const { reglInstance: e, store: { pointsTextureSize: n }, data: i } = this;
    if (!n || i.pointsNumber === void 0 || i.pointSizes === void 0) return;
    this.sizeBuffer || (this.sizeBuffer = e.buffer(0)), this.sizeBuffer(i.pointSizes);
    const r = new Float32Array(n * n * 4);
    for (let o = 0; o < i.pointsNumber; o++)
      r[o * 4] = i.pointSizes[o];
    this.sizeTexture || (this.sizeTexture = e.texture()), this.sizeTexture({
      data: r,
      width: n,
      height: n,
      type: "float"
    }), this.sizeFbo || (this.sizeFbo = e.framebuffer()), this.sizeFbo({
      color: this.sizeTexture,
      depth: false,
      stencil: false
    });
  }
  updateShape() {
    const { reglInstance: e, data: n } = this;
    n.pointsNumber === void 0 || n.pointShapes === void 0 || (this.shapeBuffer || (this.shapeBuffer = e.buffer(0)), this.shapeBuffer(n.pointShapes));
  }
  updateImageIndices() {
    const { reglInstance: e, data: n } = this;
    n.pointsNumber === void 0 || n.pointImageIndices === void 0 || (this.imageIndicesBuffer || (this.imageIndicesBuffer = e.buffer(0)), this.imageIndicesBuffer(n.pointImageIndices));
  }
  updateImageSizes() {
    const { reglInstance: e, data: n } = this;
    n.pointsNumber === void 0 || n.pointImageSizes === void 0 || (this.imageSizesBuffer || (this.imageSizesBuffer = e.buffer(0)), this.imageSizesBuffer(n.pointImageSizes));
  }
  createAtlas() {
    var u;
    const { reglInstance: e, data: n, store: i } = this;
    if (this.imageAtlasTexture || (this.imageAtlasTexture = e.texture()), this.imageAtlasCoordsTexture || (this.imageAtlasCoordsTexture = e.texture()), !((u = n.inputImageData) != null && u.length)) {
      this.imageCount = 0, this.imageAtlasCoordsTextureSize = 0;
      return;
    }
    const r = Qy(n.inputImageData, i.webglMaxTextureSize);
    if (!r) {
      console.warn("Failed to create atlas from image data");
      return;
    }
    this.imageCount = n.inputImageData.length;
    const { atlasData: o, atlasSize: s, atlasCoords: f, atlasCoordsSize: l } = r;
    this.imageAtlasCoordsTextureSize = l, this.imageAtlasTexture({
      data: o,
      shape: [s, s, 4],
      type: "uint8"
    }), this.imageAtlasCoordsTexture({
      data: f,
      shape: [l, l, 4],
      type: "float"
    });
  }
  updateSampledPointsGrid() {
    const { store: { screenSize: e }, config: { pointSamplingDistance: n }, reglInstance: i } = this;
    let r = n ?? Math.min(...e) / 2;
    r === 0 && (r = Ge.pointSamplingDistance);
    const o = Math.ceil(e[0] / r), s = Math.ceil(e[1] / r);
    this.sampledPointsFbo || (this.sampledPointsFbo = i.framebuffer()), this.sampledPointsFbo({
      shape: [o, s],
      depth: false,
      stencil: false,
      colorType: "float"
    });
  }
  trackPoints() {
    var e, n;
    (e = this.trackedIndices) != null && e.length && ((n = this.trackPointsCommand) == null || n.call(this));
  }
  draw() {
    var o, s, f, l, u, m, y;
    const { config: { renderHoveredPointRing: e, pointSize: n }, store: i, data: r } = this;
    this.colorBuffer || this.updateColor(), this.sizeBuffer || this.updateSize(), this.shapeBuffer || this.updateShape(), this.imageIndicesBuffer || this.updateImageIndices(), this.imageSizesBuffer || this.updateImageSizes(), (!this.imageAtlasCoordsTexture || !this.imageAtlasTexture) && this.createAtlas(), i.selectedIndices && i.selectedIndices.length > 0 ? ((o = this.drawCommand) == null || o.call(this, { skipSelected: true, skipUnselected: false }), (s = this.drawCommand) == null || s.call(this, { skipSelected: false, skipUnselected: true })) : (f = this.drawCommand) == null || f.call(this, { skipSelected: false, skipUnselected: false }), e && i.hoveredPoint && ((u = this.drawHighlightedCommand) == null || u.call(this, {
      width: 0.85,
      color: i.hoveredPointRingColor,
      pointIndex: i.hoveredPoint.index,
      size: ((l = r.pointSizes) == null ? void 0 : l[i.hoveredPoint.index]) ?? n
    })), i.focusedPoint && ((y = this.drawHighlightedCommand) == null || y.call(this, {
      width: 0.75,
      color: i.focusedPointRingColor,
      pointIndex: i.focusedPoint.index,
      size: ((m = r.pointSizes) == null ? void 0 : m[i.focusedPoint.index]) ?? n
    }));
  }
  updatePosition() {
    var e;
    (e = this.updatePositionCommand) == null || e.call(this), this.swapFbo(), this.isPositionsUpToDate = false;
  }
  drag() {
    var e;
    (e = this.dragPointCommand) == null || e.call(this), this.swapFbo(), this.isPositionsUpToDate = false;
  }
  findPointsOnAreaSelection() {
    var e;
    (e = this.findPointsOnAreaSelectionCommand) == null || e.call(this);
  }
  findPointsOnPolygonSelection() {
    var e;
    (e = this.findPointsOnPolygonSelectionCommand) == null || e.call(this);
  }
  updatePolygonPath(e) {
    const { reglInstance: n } = this;
    if (this.polygonPathLength = e.length, e.length === 0) {
      this.polygonPathTexture = void 0, this.polygonPathFbo = void 0;
      return;
    }
    const i = Math.ceil(Math.sqrt(e.length)), r = new Float32Array(i * i * 4);
    for (const [o, s] of e.entries()) {
      const [f, l] = s;
      r[o * 4] = f, r[o * 4 + 1] = l, r[o * 4 + 2] = 0, r[o * 4 + 3] = 0;
    }
    this.polygonPathTexture || (this.polygonPathTexture = n.texture()), this.polygonPathTexture({
      data: r,
      width: i,
      height: i,
      type: "float"
    }), this.polygonPathFbo || (this.polygonPathFbo = n.framebuffer()), this.polygonPathFbo({
      color: this.polygonPathTexture,
      depth: false,
      stencil: false
    });
  }
  findHoveredPoint() {
    var e, n;
    (e = this.clearHoveredFboCommand) == null || e.call(this), (n = this.findHoveredPointCommand) == null || n.call(this);
  }
  trackPointsByIndices(e) {
    const { store: { pointsTextureSize: n }, reglInstance: i } = this;
    if (this.trackedIndices = e, this.trackedPositions = void 0, this.isPositionsUpToDate = false, !(e != null && e.length) || !n) return;
    const r = Math.ceil(Math.sqrt(e.length)), o = new Float32Array(r * r * 4).fill(-1);
    for (const [s, f] of e.entries())
      f !== void 0 && (o[s * 4] = f % n, o[s * 4 + 1] = Math.floor(f / n), o[s * 4 + 2] = 0, o[s * 4 + 3] = 0);
    this.trackedIndicesTexture || (this.trackedIndicesTexture = i.texture()), this.trackedIndicesTexture({
      data: o,
      width: r,
      height: r,
      type: "float"
    }), this.trackedIndicesFbo || (this.trackedIndicesFbo = i.framebuffer()), this.trackedIndicesFbo({
      color: this.trackedIndicesTexture,
      depth: false,
      stencil: false
    }), this.trackedPositionsFbo || (this.trackedPositionsFbo = i.framebuffer()), this.trackedPositionsFbo({
      shape: [r, r],
      depth: false,
      stencil: false,
      colorType: "float"
    }), this.trackPoints();
  }
  /**
   * Get current X and Y coordinates of the tracked points.
   *
   * When the simulation is disabled or stopped, this method returns a cached
   * result to avoid expensive GPU-to-CPU memory transfers (`readPixels`).
   *
   * @returns A ReadonlyMap where keys are point indices and values are [x, y] coordinates.
   */
  getTrackedPositionsMap() {
    if (!this.trackedIndices) return /* @__PURE__ */ new Map();
    const { config: { enableSimulation: e }, store: { isSimulationRunning: n } } = this;
    if ((!e || !n) && this.isPositionsUpToDate && this.trackedPositions)
      return this.trackedPositions;
    const i = tn(this.reglInstance, this.trackedPositionsFbo), r = /* @__PURE__ */ new Map();
    for (let o = 0; o < i.length / 4; o += 1) {
      const s = i[o * 4], f = i[o * 4 + 1], l = this.trackedIndices[o];
      s !== void 0 && f !== void 0 && l !== void 0 && r.set(l, [s, f]);
    }
    return (!e || !n) && (this.trackedPositions = r, this.isPositionsUpToDate = true), r;
  }
  getSampledPointPositionsMap() {
    var i, r;
    const e = /* @__PURE__ */ new Map();
    if (!this.sampledPointsFbo) return e;
    (i = this.clearSampledPointsFboCommand) == null || i.call(this), (r = this.fillSampledPointsFboCommand) == null || r.call(this);
    const n = tn(this.reglInstance, this.sampledPointsFbo);
    for (let o = 0; o < n.length / 4; o++) {
      const s = n[o * 4], f = !!n[o * 4 + 1], l = n[o * 4 + 2], u = n[o * 4 + 3];
      f && s !== void 0 && l !== void 0 && u !== void 0 && e.set(s, [l, u]);
    }
    return e;
  }
  getSampledPoints() {
    var r, o;
    const e = [], n = [];
    if (!this.sampledPointsFbo) return { indices: e, positions: n };
    (r = this.clearSampledPointsFboCommand) == null || r.call(this), (o = this.fillSampledPointsFboCommand) == null || o.call(this);
    const i = tn(this.reglInstance, this.sampledPointsFbo);
    for (let s = 0; s < i.length / 4; s++) {
      const f = i[s * 4], l = !!i[s * 4 + 1], u = i[s * 4 + 2], m = i[s * 4 + 3];
      l && f !== void 0 && u !== void 0 && m !== void 0 && (e.push(f), n.push(u, m));
    }
    return { indices: e, positions: n };
  }
  getTrackedPositionsArray() {
    const e = [];
    if (!this.trackedIndices) return e;
    e.length = this.trackedIndices.length * 2;
    const n = tn(this.reglInstance, this.trackedPositionsFbo);
    for (let i = 0; i < n.length / 4; i += 1) {
      const r = n[i * 4], o = n[i * 4 + 1], s = this.trackedIndices[i];
      r !== void 0 && o !== void 0 && s !== void 0 && (e[i * 2] = r, e[i * 2 + 1] = o);
    }
    return e;
  }
  swapFbo() {
    const e = this.previousPositionFbo;
    this.previousPositionFbo = this.currentPositionFbo, this.currentPositionFbo = e;
  }
  rescaleInitialNodePositions() {
    const { config: { spaceSize: e } } = this;
    if (!this.data.pointPositions || !e) return;
    const n = this.data.pointPositions, i = n.length / 2;
    let r = 1 / 0, o = -1 / 0, s = 1 / 0, f = -1 / 0;
    for (let we = 0; we < n.length; we += 2) {
      const fe = n[we], Oe = n[we + 1];
      r = Math.min(r, fe), o = Math.max(o, fe), s = Math.min(s, Oe), f = Math.max(f, Oe);
    }
    const l = o - r, u = f - s, m = Math.max(l, u);
    if (m > e) {
      this.scaleX = void 0, this.scaleY = void 0;
      return;
    }
    const y = e * e * 1e-3, D = (i > y ? e * Math.max(1.2, Math.sqrt(i) / e) : e * 0.1) / m, q = (m - l) / 2 * D, Te = (m - u) / 2 * D;
    this.scaleX = (we) => (we - r) * D + q, this.scaleY = (we) => (we - s) * D + Te;
    for (let we = 0; we < i; we++)
      this.data.pointPositions[we * 2] = this.scaleX(n[we * 2]), this.data.pointPositions[we * 2 + 1] = this.scaleY(n[we * 2 + 1]);
  }
};
var zu = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var t3 = 0, e = arguments.length; e--; )
    t3 += arguments[e] * arguments[e];
  return Math.sqrt(t3);
});
function Jy() {
  var t3 = new zu(9);
  return zu != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
}
function Ru(t3, e, n) {
  var i = e[0], r = e[1], o = e[2], s = e[3], f = e[4], l = e[5], u = e[6], m = e[7], y = e[8], S = n[0], D = n[1];
  return t3[0] = i, t3[1] = r, t3[2] = o, t3[3] = s, t3[4] = f, t3[5] = l, t3[6] = S * i + D * s + u, t3[7] = S * r + D * f + m, t3[8] = S * o + D * l + y, t3;
}
function ws(t3, e, n) {
  var i = n[0], r = n[1];
  return t3[0] = i * e[0], t3[1] = i * e[1], t3[2] = i * e[2], t3[3] = r * e[3], t3[4] = r * e[4], t3[5] = r * e[5], t3[6] = e[6], t3[7] = e[7], t3[8] = e[8], t3;
}
function ex(t3, e, n) {
  return t3[0] = 2 / e, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = -2 / n, t3[5] = 0, t3[6] = -1, t3[7] = 1, t3[8] = 1, t3;
}
var Yo = { exports: {} };
var tx = Yo.exports;
var Mu;
function nx() {
  return Mu || (Mu = 1, (function(t3) {
    (function(e, n, i) {
      function r(l) {
        var u = this, m = f();
        u.next = function() {
          var y = 2091639 * u.s0 + u.c * 23283064365386963e-26;
          return u.s0 = u.s1, u.s1 = u.s2, u.s2 = y - (u.c = y | 0);
        }, u.c = 1, u.s0 = m(" "), u.s1 = m(" "), u.s2 = m(" "), u.s0 -= m(l), u.s0 < 0 && (u.s0 += 1), u.s1 -= m(l), u.s1 < 0 && (u.s1 += 1), u.s2 -= m(l), u.s2 < 0 && (u.s2 += 1), m = null;
      }
      function o(l, u) {
        return u.c = l.c, u.s0 = l.s0, u.s1 = l.s1, u.s2 = l.s2, u;
      }
      function s(l, u) {
        var m = new r(l), y = u && u.state, S = m.next;
        return S.int32 = function() {
          return m.next() * 4294967296 | 0;
        }, S.double = function() {
          return S() + (S() * 2097152 | 0) * 11102230246251565e-32;
        }, S.quick = S, y && (typeof y == "object" && o(y, m), S.state = function() {
          return o(m, {});
        }), S;
      }
      function f() {
        var l = 4022871197, u = function(m) {
          m = String(m);
          for (var y = 0; y < m.length; y++) {
            l += m.charCodeAt(y);
            var S = 0.02519603282416938 * l;
            l = S >>> 0, S -= l, S *= l, l = S >>> 0, S -= l, l += S * 4294967296;
          }
          return (l >>> 0) * 23283064365386963e-26;
        };
        return u;
      }
      n && n.exports ? n.exports = s : this.alea = s;
    })(
      tx,
      t3
    );
  })(Yo)), Yo.exports;
}
var Zo = { exports: {} };
var ix = Zo.exports;
var Ou;
function rx() {
  return Ou || (Ou = 1, (function(t3) {
    (function(e, n, i) {
      function r(f) {
        var l = this, u = "";
        l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.next = function() {
          var y = l.x ^ l.x << 11;
          return l.x = l.y, l.y = l.z, l.z = l.w, l.w ^= l.w >>> 19 ^ y ^ y >>> 8;
        }, f === (f | 0) ? l.x = f : u += f;
        for (var m = 0; m < u.length + 64; m++)
          l.x ^= u.charCodeAt(m) | 0, l.next();
      }
      function o(f, l) {
        return l.x = f.x, l.y = f.y, l.z = f.z, l.w = f.w, l;
      }
      function s(f, l) {
        var u = new r(f), m = l && l.state, y = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return y.double = function() {
          do
            var S = u.next() >>> 11, D = (u.next() >>> 0) / 4294967296, q = (S + D) / (1 << 21);
          while (q === 0);
          return q;
        }, y.int32 = u.next, y.quick = y, m && (typeof m == "object" && o(m, u), y.state = function() {
          return o(u, {});
        }), y;
      }
      n && n.exports ? n.exports = s : this.xor128 = s;
    })(
      ix,
      t3
    );
  })(Zo)), Zo.exports;
}
var Qo = { exports: {} };
var ox = Qo.exports;
var Nu;
function ax() {
  return Nu || (Nu = 1, (function(t3) {
    (function(e, n, i) {
      function r(f) {
        var l = this, u = "";
        l.next = function() {
          var y = l.x ^ l.x >>> 2;
          return l.x = l.y, l.y = l.z, l.z = l.w, l.w = l.v, (l.d = l.d + 362437 | 0) + (l.v = l.v ^ l.v << 4 ^ (y ^ y << 1)) | 0;
        }, l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.v = 0, f === (f | 0) ? l.x = f : u += f;
        for (var m = 0; m < u.length + 64; m++)
          l.x ^= u.charCodeAt(m) | 0, m == u.length && (l.d = l.x << 10 ^ l.x >>> 4), l.next();
      }
      function o(f, l) {
        return l.x = f.x, l.y = f.y, l.z = f.z, l.w = f.w, l.v = f.v, l.d = f.d, l;
      }
      function s(f, l) {
        var u = new r(f), m = l && l.state, y = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return y.double = function() {
          do
            var S = u.next() >>> 11, D = (u.next() >>> 0) / 4294967296, q = (S + D) / (1 << 21);
          while (q === 0);
          return q;
        }, y.int32 = u.next, y.quick = y, m && (typeof m == "object" && o(m, u), y.state = function() {
          return o(u, {});
        }), y;
      }
      n && n.exports ? n.exports = s : this.xorwow = s;
    })(
      ox,
      t3
    );
  })(Qo)), Qo.exports;
}
var Ko = { exports: {} };
var sx = Ko.exports;
var Gu;
function fx() {
  return Gu || (Gu = 1, (function(t3) {
    (function(e, n, i) {
      function r(f) {
        var l = this;
        l.next = function() {
          var m = l.x, y = l.i, S, D;
          return S = m[y], S ^= S >>> 7, D = S ^ S << 24, S = m[y + 1 & 7], D ^= S ^ S >>> 10, S = m[y + 3 & 7], D ^= S ^ S >>> 3, S = m[y + 4 & 7], D ^= S ^ S << 7, S = m[y + 7 & 7], S = S ^ S << 13, D ^= S ^ S << 9, m[y] = D, l.i = y + 1 & 7, D;
        };
        function u(m, y) {
          var S, D = [];
          if (y === (y | 0))
            D[0] = y;
          else
            for (y = "" + y, S = 0; S < y.length; ++S)
              D[S & 7] = D[S & 7] << 15 ^ y.charCodeAt(S) + D[S + 1 & 7] << 13;
          for (; D.length < 8; ) D.push(0);
          for (S = 0; S < 8 && D[S] === 0; ++S) ;
          for (S == 8 ? D[7] = -1 : D[S], m.x = D, m.i = 0, S = 256; S > 0; --S)
            m.next();
        }
        u(l, f);
      }
      function o(f, l) {
        return l.x = f.x.slice(), l.i = f.i, l;
      }
      function s(f, l) {
        f == null && (f = +/* @__PURE__ */ new Date());
        var u = new r(f), m = l && l.state, y = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return y.double = function() {
          do
            var S = u.next() >>> 11, D = (u.next() >>> 0) / 4294967296, q = (S + D) / (1 << 21);
          while (q === 0);
          return q;
        }, y.int32 = u.next, y.quick = y, m && (m.x && o(m, u), y.state = function() {
          return o(u, {});
        }), y;
      }
      n && n.exports ? n.exports = s : this.xorshift7 = s;
    })(
      sx,
      t3
    );
  })(Ko)), Ko.exports;
}
var Jo = { exports: {} };
var lx = Jo.exports;
var Bu;
function ux() {
  return Bu || (Bu = 1, (function(t3) {
    (function(e, n, i) {
      function r(f) {
        var l = this;
        l.next = function() {
          var m = l.w, y = l.X, S = l.i, D, q;
          return l.w = m = m + 1640531527 | 0, q = y[S + 34 & 127], D = y[S = S + 1 & 127], q ^= q << 13, D ^= D << 17, q ^= q >>> 15, D ^= D >>> 12, q = y[S] = q ^ D, l.i = S, q + (m ^ m >>> 16) | 0;
        };
        function u(m, y) {
          var S, D, q, Te, we, fe = [], Oe = 128;
          for (y === (y | 0) ? (D = y, y = null) : (y = y + "\0", D = 0, Oe = Math.max(Oe, y.length)), q = 0, Te = -32; Te < Oe; ++Te)
            y && (D ^= y.charCodeAt((Te + 32) % y.length)), Te === 0 && (we = D), D ^= D << 10, D ^= D >>> 15, D ^= D << 4, D ^= D >>> 13, Te >= 0 && (we = we + 1640531527 | 0, S = fe[Te & 127] ^= D + we, q = S == 0 ? q + 1 : 0);
          for (q >= 128 && (fe[(y && y.length || 0) & 127] = -1), q = 127, Te = 4 * 128; Te > 0; --Te)
            D = fe[q + 34 & 127], S = fe[q = q + 1 & 127], D ^= D << 13, S ^= S << 17, D ^= D >>> 15, S ^= S >>> 12, fe[q] = D ^ S;
          m.w = we, m.X = fe, m.i = q;
        }
        u(l, f);
      }
      function o(f, l) {
        return l.i = f.i, l.w = f.w, l.X = f.X.slice(), l;
      }
      function s(f, l) {
        f == null && (f = +/* @__PURE__ */ new Date());
        var u = new r(f), m = l && l.state, y = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return y.double = function() {
          do
            var S = u.next() >>> 11, D = (u.next() >>> 0) / 4294967296, q = (S + D) / (1 << 21);
          while (q === 0);
          return q;
        }, y.int32 = u.next, y.quick = y, m && (m.X && o(m, u), y.state = function() {
          return o(u, {});
        }), y;
      }
      n && n.exports ? n.exports = s : this.xor4096 = s;
    })(
      lx,
      // window object or global
      t3
    );
  })(Jo)), Jo.exports;
}
var ea = { exports: {} };
var cx = ea.exports;
var Uu;
function hx() {
  return Uu || (Uu = 1, (function(t3) {
    (function(e, n, i) {
      function r(f) {
        var l = this, u = "";
        l.next = function() {
          var y = l.b, S = l.c, D = l.d, q = l.a;
          return y = y << 25 ^ y >>> 7 ^ S, S = S - D | 0, D = D << 24 ^ D >>> 8 ^ q, q = q - y | 0, l.b = y = y << 20 ^ y >>> 12 ^ S, l.c = S = S - D | 0, l.d = D << 16 ^ S >>> 16 ^ q, l.a = q - y | 0;
        }, l.a = 0, l.b = 0, l.c = -1640531527, l.d = 1367130551, f === Math.floor(f) ? (l.a = f / 4294967296 | 0, l.b = f | 0) : u += f;
        for (var m = 0; m < u.length + 20; m++)
          l.b ^= u.charCodeAt(m) | 0, l.next();
      }
      function o(f, l) {
        return l.a = f.a, l.b = f.b, l.c = f.c, l.d = f.d, l;
      }
      function s(f, l) {
        var u = new r(f), m = l && l.state, y = function() {
          return (u.next() >>> 0) / 4294967296;
        };
        return y.double = function() {
          do
            var S = u.next() >>> 11, D = (u.next() >>> 0) / 4294967296, q = (S + D) / (1 << 21);
          while (q === 0);
          return q;
        }, y.int32 = u.next, y.quick = y, m && (typeof m == "object" && o(m, u), y.state = function() {
          return o(u, {});
        }), y;
      }
      n && n.exports ? n.exports = s : this.tychei = s;
    })(
      cx,
      t3
    );
  })(ea)), ea.exports;
}
var ta = { exports: {} };
var dx = {};
var mx = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: dx
}, Symbol.toStringTag, { value: "Module" }));
var px = Uv(mx);
var vx = ta.exports;
var Vu;
function gx() {
  return Vu || (Vu = 1, (function(t3) {
    (function(e, n, i) {
      var r = 256, o = 6, s = 52, f = "random", l = i.pow(r, o), u = i.pow(2, s), m = u * 2, y = r - 1, S;
      function D(V, se, Le) {
        var Be = [];
        se = se == true ? { entropy: true } : se || {};
        var Xe = fe(we(
          se.entropy ? [V, Ve(n)] : V ?? Oe(),
          3
        ), Be), nt = new q(Be), lt = function() {
          for (var Ee = nt.g(o), ut = l, rt = 0; Ee < u; )
            Ee = (Ee + rt) * r, ut *= r, rt = nt.g(1);
          for (; Ee >= m; )
            Ee /= 2, ut /= 2, rt >>>= 1;
          return (Ee + rt) / ut;
        };
        return lt.int32 = function() {
          return nt.g(4) | 0;
        }, lt.quick = function() {
          return nt.g(4) / 4294967296;
        }, lt.double = lt, fe(Ve(nt.S), n), (se.pass || Le || function(Ee, ut, rt, N) {
          return N && (N.S && Te(N, nt), Ee.state = function() {
            return Te(nt, {});
          }), rt ? (i[f] = Ee, ut) : Ee;
        })(
          lt,
          Xe,
          "global" in se ? se.global : this == i,
          se.state
        );
      }
      function q(V) {
        var se, Le = V.length, Be = this, Xe = 0, nt = Be.i = Be.j = 0, lt = Be.S = [];
        for (Le || (V = [Le++]); Xe < r; )
          lt[Xe] = Xe++;
        for (Xe = 0; Xe < r; Xe++)
          lt[Xe] = lt[nt = y & nt + V[Xe % Le] + (se = lt[Xe])], lt[nt] = se;
        (Be.g = function(Ee) {
          for (var ut, rt = 0, N = Be.i, Pe = Be.j, ie = Be.S; Ee--; )
            ut = ie[N = y & N + 1], rt = rt * r + ie[y & (ie[N] = ie[Pe = y & Pe + ut]) + (ie[Pe] = ut)];
          return Be.i = N, Be.j = Pe, rt;
        })(r);
      }
      function Te(V, se) {
        return se.i = V.i, se.j = V.j, se.S = V.S.slice(), se;
      }
      function we(V, se) {
        var Le = [], Be = typeof V, Xe;
        if (se && Be == "object")
          for (Xe in V)
            try {
              Le.push(we(V[Xe], se - 1));
            } catch {
            }
        return Le.length ? Le : Be == "string" ? V : V + "\0";
      }
      function fe(V, se) {
        for (var Le = V + "", Be, Xe = 0; Xe < Le.length; )
          se[y & Xe] = y & (Be ^= se[y & Xe] * 19) + Le.charCodeAt(Xe++);
        return Ve(se);
      }
      function Oe() {
        try {
          var V;
          return S && (V = S.randomBytes) ? V = V(r) : (V = new Uint8Array(r), (e.crypto || e.msCrypto).getRandomValues(V)), Ve(V);
        } catch {
          var se = e.navigator, Le = se && se.plugins;
          return [+/* @__PURE__ */ new Date(), e, Le, e.screen, Ve(n)];
        }
      }
      function Ve(V) {
        return String.fromCharCode.apply(0, V);
      }
      if (fe(i.random(), n), t3.exports) {
        t3.exports = D;
        try {
          S = px;
        } catch {
        }
      } else
        i["seed" + f] = D;
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self < "u" ? self : vx,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  })(ta)), ta.exports;
}
var As;
var $u;
function yx() {
  if ($u) return As;
  $u = 1;
  var t3 = nx(), e = rx(), n = ax(), i = fx(), r = ux(), o = hx(), s = gx();
  return s.alea = t3, s.xor128 = e, s.xorwow = n, s.xorshift7 = i, s.xor4096 = r, s.tychei = o, As = s, As;
}
var xx = yx();
var bx = nf(xx);
function _x(t3, e) {
  for (var n = 0; n < e.length; n++) {
    var i = e[n];
    i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(t3, Tx(i.key), i);
  }
}
function of(t3, e, n) {
  return e && _x(t3.prototype, e), Object.defineProperty(t3, "prototype", {
    writable: false
  }), t3;
}
function Oc(t3, e) {
  t3.prototype = Object.create(e.prototype), t3.prototype.constructor = t3, Hs(t3, e);
}
function Hs(t3, e) {
  return Hs = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
    return i.__proto__ = r, i;
  }, Hs(t3, e);
}
function Sx(t3, e) {
  if (typeof t3 != "object" || t3 === null) return t3;
  var n = t3[Symbol.toPrimitive];
  if (n !== void 0) {
    var i = n.call(t3, e);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t3);
}
function Tx(t3) {
  var e = Sx(t3, "string");
  return typeof e == "symbol" ? e : String(e);
}
var pa = (function() {
  function t3() {
  }
  var e = t3.prototype;
  return e._seed = function(i, r) {
    if (i === (i || 0))
      return i;
    for (var o = "" + i, s = 0, f = 0; f < o.length; ++f)
      s ^= o.charCodeAt(f) | 0;
    return s;
  }, t3;
})();
var Hu = (function(t3) {
  Oc(e, t3);
  function e(i, r) {
    var o;
    return o = t3.call(this) || this, o._rng = void 0, o.seed(i, r), o;
  }
  var n = e.prototype;
  return n.next = function() {
    return this._rng();
  }, n.seed = function(r, o) {
    this._rng = r;
  }, n.clone = function(r, o) {
    return new e(this._rng, o);
  }, of(e, [{
    key: "name",
    get: function() {
      return "function";
    }
  }]), e;
})(pa);
var Wu = function() {
  var t3 = [].slice.call(arguments), e = t3, n = e[0], i = n === void 0 ? "default" : n;
  switch (typeof i) {
    case "object":
      if (i instanceof pa)
        return i;
      break;
    case "function":
      return new Hu(i);
    case "number":
    case "string":
    default:
      return new Hu(bx.apply(void 0, t3));
  }
  throw new Error('invalid RNG "' + i + '"');
};
var wx = function(t3, e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = 1), function() {
    return t3.next() * (n - e) + e;
  };
};
function gn(t3) {
  return new Ax(t3);
}
var Ax = function(e) {
  var n = this;
  this.n = void 0, this.isInt = function() {
    if (Number.isInteger(n.n))
      return n;
    throw new Error("Expected number to be an integer, got " + n.n);
  }, this.isPositive = function() {
    if (n.n > 0)
      return n;
    throw new Error("Expected number to be positive, got " + n.n);
  }, this.lessThan = function(i) {
    if (n.n < i)
      return n;
    throw new Error("Expected number to be less than " + i + ", got " + n.n);
  }, this.greaterThanOrEqual = function(i) {
    if (n.n >= i)
      return n;
    throw new Error("Expected number to be greater than or equal to " + i + ", got " + n.n);
  }, this.greaterThan = function(i) {
    if (n.n > i)
      return n;
    throw new Error("Expected number to be greater than " + i + ", got " + n.n);
  }, this.n = e;
};
var Ex = function(t3, e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = 1), n === void 0 && (n = e === void 0 ? 1 : e, e = 0), gn(e).isInt(), gn(n).isInt(), function() {
    return Math.floor(t3.next() * (n - e + 1) + e);
  };
};
var Cx = function(t3) {
  return function() {
    return t3.next() >= 0.5;
  };
};
var Px = function(t3, e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = 1), function() {
    var i, r, o;
    do
      i = t3.next() * 2 - 1, r = t3.next() * 2 - 1, o = i * i + r * r;
    while (!o || o > 1);
    return e + n * r * Math.sqrt(-2 * Math.log(o) / o);
  };
};
var kx = function(t3, e, n) {
  e === void 0 && (e = 0), n === void 0 && (n = 1);
  var i = t3.normal(e, n);
  return function() {
    return Math.exp(i());
  };
};
var Ix = function(t3, e) {
  return e === void 0 && (e = 0.5), gn(e).greaterThanOrEqual(0).lessThan(1), function() {
    return Math.floor(t3.next() + e);
  };
};
var Lx = function(t3, e, n) {
  return e === void 0 && (e = 1), n === void 0 && (n = 0.5), gn(e).isInt().isPositive(), gn(n).greaterThanOrEqual(0).lessThan(1), function() {
    for (var i = 0, r = 0; i++ < e; )
      t3.next() < n && r++;
    return r;
  };
};
var Dx = function(t3, e) {
  e === void 0 && (e = 0.5), gn(e).greaterThan(0).lessThan(1);
  var n = 1 / Math.log(1 - e);
  return function() {
    return Math.floor(1 + Math.log(t3.next()) * n);
  };
};
var Fx = [0, 0, 0.6931471805599453, 1.791759469228055, 3.1780538303479458, 4.787491742782046, 6.579251212010101, 8.525161361065415, 10.60460290274525, 12.801827480081469];
var zx = function(e) {
  return Fx[e];
};
var Rx = 0.9189385332046727;
var Mx = function(t3, e) {
  if (e === void 0 && (e = 1), gn(e).isPositive(), e < 10) {
    var n = Math.exp(-e);
    return function() {
      for (var l = n, u = 0, m = t3.next(); m > l; )
        m = m - l, l = e * l / ++u;
      return u;
    };
  } else {
    var i = Math.sqrt(e), r = 0.931 + 2.53 * i, o = -0.059 + 0.02483 * r, s = 1.1239 + 1.1328 / (r - 3.4), f = 0.9277 - 3.6224 / (r - 2);
    return function() {
      for (; ; ) {
        var l = void 0, u = t3.next();
        if (u <= 0.86 * f)
          return l = u / f - 0.43, Math.floor((2 * o / (0.5 - Math.abs(l)) + r) * l + e + 0.445);
        u >= f ? l = t3.next() - 0.5 : (l = u / f - 0.93, l = (l < 0 ? -0.5 : 0.5) - l, u = t3.next() * f);
        var m = 0.5 - Math.abs(l);
        if (!(m < 0.013 && u > m)) {
          var y = Math.floor((2 * o / m + r) * l + e + 0.445);
          if (u = u * s / (o / (m * m) + r), y >= 10) {
            var S = (y + 0.5) * Math.log(e / y) - e - Rx + y - (0.08333333333333333 - (0.002777777777777778 - 1 / (1260 * y * y)) / (y * y)) / y;
            if (Math.log(u * i) <= S)
              return y;
          } else if (y >= 0) {
            var D, q = (D = zx(y)) != null ? D : 0;
            if (Math.log(u) <= y * Math.log(e) - e - q)
              return y;
          }
        }
      }
    };
  }
};
var Ox = function(t3, e) {
  return e === void 0 && (e = 1), gn(e).isPositive(), function() {
    return -Math.log(1 - t3.next()) / e;
  };
};
var Nx = function(t3, e) {
  return e === void 0 && (e = 1), gn(e).isInt().greaterThanOrEqual(0), function() {
    for (var n = 0, i = 0; i < e; ++i)
      n += t3.next();
    return n;
  };
};
var Gx = function(t3, e) {
  e === void 0 && (e = 1), gn(e).isInt().isPositive();
  var n = t3.irwinHall(e);
  return function() {
    return n() / e;
  };
};
var Bx = function(t3, e) {
  e === void 0 && (e = 1), gn(e).greaterThanOrEqual(0);
  var n = 1 / e;
  return function() {
    return 1 / Math.pow(1 - t3.next(), n);
  };
};
var Ux = (function(t3) {
  Oc(e, t3);
  function e() {
    return t3.apply(this, arguments) || this;
  }
  var n = e.prototype;
  return n.next = function() {
    return Math.random();
  }, n.seed = function(r, o) {
  }, n.clone = function() {
    return new e();
  }, of(e, [{
    key: "name",
    get: function() {
      return "default";
    }
  }]), e;
})(pa);
var Nc = (function() {
  function t3(n) {
    var i = this;
    this._rng = void 0, this._patch = void 0, this._cache = {}, this.next = function() {
      return i._rng.next();
    }, this.float = function(r, o) {
      return i.uniform(r, o)();
    }, this.int = function(r, o) {
      return i.uniformInt(r, o)();
    }, this.integer = function(r, o) {
      return i.uniformInt(r, o)();
    }, this.bool = function() {
      return i.uniformBoolean()();
    }, this.boolean = function() {
      return i.uniformBoolean()();
    }, this.uniform = function(r, o) {
      return i._memoize("uniform", wx, r, o);
    }, this.uniformInt = function(r, o) {
      return i._memoize("uniformInt", Ex, r, o);
    }, this.uniformBoolean = function() {
      return i._memoize("uniformBoolean", Cx);
    }, this.normal = function(r, o) {
      return Px(i, r, o);
    }, this.logNormal = function(r, o) {
      return kx(i, r, o);
    }, this.bernoulli = function(r) {
      return Ix(i, r);
    }, this.binomial = function(r, o) {
      return Lx(i, r, o);
    }, this.geometric = function(r) {
      return Dx(i, r);
    }, this.poisson = function(r) {
      return Mx(i, r);
    }, this.exponential = function(r) {
      return Ox(i, r);
    }, this.irwinHall = function(r) {
      return Nx(i, r);
    }, this.bates = function(r) {
      return Gx(i, r);
    }, this.pareto = function(r) {
      return Bx(i, r);
    }, n && n instanceof pa ? this.use(n) : this.use(new Ux()), this._cache = {};
  }
  var e = t3.prototype;
  return e.clone = function() {
    var i = [].slice.call(arguments);
    return i.length ? new t3(Wu.apply(void 0, i)) : new t3(this.rng.clone());
  }, e.use = function() {
    this._rng = Wu.apply(void 0, [].slice.call(arguments));
  }, e.patch = function() {
    if (this._patch)
      throw new Error("Math.random already patched");
    this._patch = Math.random, Math.random = this.uniform();
  }, e.unpatch = function() {
    this._patch && (Math.random = this._patch, delete this._patch);
  }, e.choice = function(i) {
    if (!Array.isArray(i))
      throw new Error("Random.choice expected input to be an array, got " + typeof i);
    var r = i == null ? void 0 : i.length;
    if (r > 0) {
      var o = this.uniformInt(0, r - 1)();
      return i[o];
    } else
      return;
  }, e._memoize = function(i, r) {
    var o = [].slice.call(arguments, 2), s = "" + o.join(";"), f = this._cache[i];
    return (f === void 0 || f.key !== s) && (f = {
      key: s,
      distribution: r.apply(void 0, [this].concat(o))
    }, this._cache[i] = f), f.distribution;
  }, of(t3, [{
    key: "rng",
    get: function() {
      return this._rng;
    }
  }]), t3;
})();
new Nc();
var Ws = 1e-3;
var Xs = 64;
var Vx = 4;
var $x = class {
  constructor() {
    this.pointsTextureSize = 0, this.linksTextureSize = 0, this.alpha = 1, this.transform = Jy(), this.screenSize = [0, 0], this.mousePosition = [0, 0], this.screenMousePosition = [0, 0], this.selectedArea = [[0, 0], [0, 0]], this.isSimulationRunning = false, this.simulationProgress = 0, this.selectedIndices = null, this.maxPointSize = Xs, this.hoveredPoint = void 0, this.focusedPoint = void 0, this.draggingPointIndex = void 0, this.hoveredLinkIndex = void 0, this.adjustedSpaceSize = Ge.spaceSize, this.isSpaceKeyPressed = false, this.webglMaxTextureSize = 16384, this.hoveredPointRingColor = [1, 1, 1, eg], this.focusedPointRingColor = [1, 1, 1, tg], this.hoveredLinkColor = [-1, -1, -1, -1], this.greyoutPointColor = [-1, -1, -1, -1], this.isDarkenGreyout = false, this.isLinkHoveringEnabled = false, this.alphaTarget = 0, this.scalePointX = $s(), this.scalePointY = $s(), this.random = new Nc(), this._backgroundColor = [0, 0, 0, 0], this.alphaDecay = (e) => 1 - Math.pow(Ws, 1 / e);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(e) {
    this._backgroundColor = e;
    const n = Pg(e[0], e[1], e[2]);
    document.documentElement.style.setProperty("--cosmosgl-attribution-color", n > 0.65 ? "black" : "white"), document.documentElement.style.setProperty("--cosmosgl-error-message-color", n > 0.65 ? "black" : "white"), this.div && (this.div.style.backgroundColor = `rgba(${e[0] * 255}, ${e[1] * 255}, ${e[2] * 255}, ${e[3]})`), this.isDarkenGreyout = n < 0.65;
  }
  addRandomSeed(e) {
    this.random = this.random.clone(e);
  }
  getRandomFloat(e, n) {
    return this.random.float(e, n);
  }
  /**
   * If the config parameter `spaceSize` exceeds the limits of WebGL,
   * it reduces the space size without changing the config parameter.
   */
  adjustSpaceSize(e, n) {
    e >= n ? (this.adjustedSpaceSize = n / 2, console.warn(`The \`spaceSize\` has been reduced to ${this.adjustedSpaceSize} due to WebGL limits`)) : this.adjustedSpaceSize = e;
  }
  /**
   * Sets the WebGL texture size limit for use in atlas creation and other texture operations.
   */
  setWebGLMaxTextureSize(e) {
    this.webglMaxTextureSize = e;
  }
  updateScreenSize(e, n) {
    const { adjustedSpaceSize: i } = this;
    this.screenSize = [e, n], this.scalePointX.domain([0, i]).range([(e - i) / 2, (e + i) / 2]), this.scalePointY.domain([i, 0]).range([(n - i) / 2, (n + i) / 2]);
  }
  scaleX(e) {
    return this.scalePointX(e);
  }
  scaleY(e) {
    return this.scalePointY(e);
  }
  setHoveredPointRingColor(e) {
    const n = Kn(e);
    this.hoveredPointRingColor[0] = n[0], this.hoveredPointRingColor[1] = n[1], this.hoveredPointRingColor[2] = n[2];
  }
  setFocusedPointRingColor(e) {
    const n = Kn(e);
    this.focusedPointRingColor[0] = n[0], this.focusedPointRingColor[1] = n[1], this.focusedPointRingColor[2] = n[2];
  }
  setGreyoutPointColor(e) {
    if (e === void 0) {
      this.greyoutPointColor = [-1, -1, -1, -1];
      return;
    }
    const n = Kn(e);
    this.greyoutPointColor[0] = n[0], this.greyoutPointColor[1] = n[1], this.greyoutPointColor[2] = n[2], this.greyoutPointColor[3] = n[3];
  }
  updateLinkHoveringEnabled(e) {
    this.isLinkHoveringEnabled = !!(e.onLinkClick || e.onLinkMouseOver || e.onLinkMouseOut), this.isLinkHoveringEnabled || (this.hoveredLinkIndex = void 0);
  }
  setHoveredLinkColor(e) {
    if (e === void 0) {
      this.hoveredLinkColor = [-1, -1, -1, -1];
      return;
    }
    const n = Kn(e);
    this.hoveredLinkColor[0] = n[0], this.hoveredLinkColor[1] = n[1], this.hoveredLinkColor[2] = n[2], this.hoveredLinkColor[3] = n[3];
  }
  setFocusedPoint(e) {
    e !== void 0 ? this.focusedPoint = { index: e } : this.focusedPoint = void 0;
  }
  addAlpha(e) {
    return (this.alphaTarget - this.alpha) * this.alphaDecay(e);
  }
};
var Hx = { passive: false };
var Rr = { capture: true, passive: false };
function Es(t3) {
  t3.stopImmediatePropagation();
}
function Zi(t3) {
  t3.preventDefault(), t3.stopImmediatePropagation();
}
function Gc(t3) {
  var e = t3.document.documentElement, n = zt(t3).on("dragstart.drag", Zi, Rr);
  "onselectstart" in e ? n.on("selectstart.drag", Zi, Rr) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function Bc(t3, e) {
  var n = t3.document.documentElement, i = zt(t3).on("dragstart.drag", null);
  e && (i.on("click.drag", Zi, Rr), setTimeout(function() {
    i.on("click.drag", null);
  }, 0)), "onselectstart" in n ? i.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
var Go = (t3) => () => t3;
function js(t3, {
  sourceEvent: e,
  subject: n,
  target: i,
  identifier: r,
  active: o,
  x: s,
  y: f,
  dx: l,
  dy: u,
  dispatch: m
}) {
  Object.defineProperties(this, {
    type: { value: t3, enumerable: true, configurable: true },
    sourceEvent: { value: e, enumerable: true, configurable: true },
    subject: { value: n, enumerable: true, configurable: true },
    target: { value: i, enumerable: true, configurable: true },
    identifier: { value: r, enumerable: true, configurable: true },
    active: { value: o, enumerable: true, configurable: true },
    x: { value: s, enumerable: true, configurable: true },
    y: { value: f, enumerable: true, configurable: true },
    dx: { value: l, enumerable: true, configurable: true },
    dy: { value: u, enumerable: true, configurable: true },
    _: { value: m }
  });
}
js.prototype.on = function() {
  var t3 = this._.on.apply(this._, arguments);
  return t3 === this._ ? this : t3;
};
function Wx(t3) {
  return !t3.ctrlKey && !t3.button;
}
function Xx() {
  return this.parentNode;
}
function jx(t3, e) {
  return e ?? { x: t3.x, y: t3.y };
}
function qx() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Yx() {
  var t3 = Wx, e = Xx, n = jx, i = qx, r = {}, o = ha("start", "drag", "end"), s = 0, f, l, u, m, y = 0;
  function S(V) {
    V.on("mousedown.drag", D).filter(i).on("touchstart.drag", we).on("touchmove.drag", fe, Hx).on("touchend.drag touchcancel.drag", Oe).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function D(V, se) {
    if (!(m || !t3.call(this, V, se))) {
      var Le = Ve(this, e.call(this, V, se), V, se, "mouse");
      Le && (zt(V.view).on("mousemove.drag", q, Rr).on("mouseup.drag", Te, Rr), Gc(V.view), Es(V), u = false, f = V.clientX, l = V.clientY, Le("start", V));
    }
  }
  function q(V) {
    if (Zi(V), !u) {
      var se = V.clientX - f, Le = V.clientY - l;
      u = se * se + Le * Le > y;
    }
    r.mouse("drag", V);
  }
  function Te(V) {
    zt(V.view).on("mousemove.drag mouseup.drag", null), Bc(V.view, u), Zi(V), r.mouse("end", V);
  }
  function we(V, se) {
    if (t3.call(this, V, se)) {
      var Le = V.changedTouches, Be = e.call(this, V, se), Xe = Le.length, nt, lt;
      for (nt = 0; nt < Xe; ++nt)
        (lt = Ve(this, Be, V, se, Le[nt].identifier, Le[nt])) && (Es(V), lt("start", V, Le[nt]));
    }
  }
  function fe(V) {
    var se = V.changedTouches, Le = se.length, Be, Xe;
    for (Be = 0; Be < Le; ++Be)
      (Xe = r[se[Be].identifier]) && (Zi(V), Xe("drag", V, se[Be]));
  }
  function Oe(V) {
    var se = V.changedTouches, Le = se.length, Be, Xe;
    for (m && clearTimeout(m), m = setTimeout(function() {
      m = null;
    }, 500), Be = 0; Be < Le; ++Be)
      (Xe = r[se[Be].identifier]) && (Es(V), Xe("end", V, se[Be]));
  }
  function Ve(V, se, Le, Be, Xe, nt) {
    var lt = o.copy(), Ee = Mn(nt || Le, se), ut, rt, N;
    if ((N = n.call(V, new js("beforestart", {
      sourceEvent: Le,
      target: S,
      identifier: Xe,
      active: s,
      x: Ee[0],
      y: Ee[1],
      dx: 0,
      dy: 0,
      dispatch: lt
    }), Be)) != null)
      return ut = N.x - Ee[0] || 0, rt = N.y - Ee[1] || 0, function Pe(ie, ke, qe) {
        var je = Ee, Qe;
        switch (ie) {
          case "start":
            r[Xe] = Pe, Qe = s++;
            break;
          case "end":
            delete r[Xe], --s;
          // falls through
          case "drag":
            Ee = Mn(qe || ke, se), Qe = s;
            break;
        }
        lt.call(
          ie,
          V,
          new js(ie, {
            sourceEvent: ke,
            subject: N,
            target: S,
            identifier: Xe,
            active: Qe,
            x: Ee[0] + ut,
            y: Ee[1] + rt,
            dx: Ee[0] - je[0],
            dy: Ee[1] - je[1],
            dispatch: lt
          }),
          Be
        );
      };
  }
  return S.filter = function(V) {
    return arguments.length ? (t3 = typeof V == "function" ? V : Go(!!V), S) : t3;
  }, S.container = function(V) {
    return arguments.length ? (e = typeof V == "function" ? V : Go(V), S) : e;
  }, S.subject = function(V) {
    return arguments.length ? (n = typeof V == "function" ? V : Go(V), S) : n;
  }, S.touchable = function(V) {
    return arguments.length ? (i = typeof V == "function" ? V : Go(!!V), S) : i;
  }, S.on = function() {
    var V = o.on.apply(o, arguments);
    return V === o ? S : V;
  }, S.clickDistance = function(V) {
    return arguments.length ? (y = (V = +V) * V, S) : Math.sqrt(y);
  }, S;
}
var Bo = (t3) => () => t3;
function Zx(t3, {
  sourceEvent: e,
  target: n,
  transform: i,
  dispatch: r
}) {
  Object.defineProperties(this, {
    type: { value: t3, enumerable: true, configurable: true },
    sourceEvent: { value: e, enumerable: true, configurable: true },
    target: { value: n, enumerable: true, configurable: true },
    transform: { value: i, enumerable: true, configurable: true },
    _: { value: r }
  });
}
function On(t3, e, n) {
  this.k = t3, this.x = e, this.y = n;
}
On.prototype = {
  constructor: On,
  scale: function(t3) {
    return t3 === 1 ? this : new On(this.k * t3, this.x, this.y);
  },
  translate: function(t3, e) {
    return t3 === 0 & e === 0 ? this : new On(this.k, this.x + this.k * t3, this.y + this.k * e);
  },
  apply: function(t3) {
    return [t3[0] * this.k + this.x, t3[1] * this.k + this.y];
  },
  applyX: function(t3) {
    return t3 * this.k + this.x;
  },
  applyY: function(t3) {
    return t3 * this.k + this.y;
  },
  invert: function(t3) {
    return [(t3[0] - this.x) / this.k, (t3[1] - this.y) / this.k];
  },
  invertX: function(t3) {
    return (t3 - this.x) / this.k;
  },
  invertY: function(t3) {
    return (t3 - this.y) / this.k;
  },
  rescaleX: function(t3) {
    return t3.copy().domain(t3.range().map(this.invertX, this).map(t3.invert, t3));
  },
  rescaleY: function(t3) {
    return t3.copy().domain(t3.range().map(this.invertY, this).map(t3.invert, t3));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var Lr = new On(1, 0, 0);
On.prototype;
function Cs(t3) {
  t3.stopImmediatePropagation();
}
function Pr(t3) {
  t3.preventDefault(), t3.stopImmediatePropagation();
}
function Qx(t3) {
  return (!t3.ctrlKey || t3.type === "wheel") && !t3.button;
}
function Kx() {
  var t3 = this;
  return t3 instanceof SVGElement ? (t3 = t3.ownerSVGElement || t3, t3.hasAttribute("viewBox") ? (t3 = t3.viewBox.baseVal, [[t3.x, t3.y], [t3.x + t3.width, t3.y + t3.height]]) : [[0, 0], [t3.width.baseVal.value, t3.height.baseVal.value]]) : [[0, 0], [t3.clientWidth, t3.clientHeight]];
}
function Xu() {
  return this.__zoom || Lr;
}
function Jx(t3) {
  return -t3.deltaY * (t3.deltaMode === 1 ? 0.05 : t3.deltaMode ? 1 : 2e-3) * (t3.ctrlKey ? 10 : 1);
}
function eb() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function tb(t3, e, n) {
  var i = t3.invertX(e[0][0]) - n[0][0], r = t3.invertX(e[1][0]) - n[1][0], o = t3.invertY(e[0][1]) - n[0][1], s = t3.invertY(e[1][1]) - n[1][1];
  return t3.translate(
    r > i ? (i + r) / 2 : Math.min(0, i) || Math.max(0, r),
    s > o ? (o + s) / 2 : Math.min(0, o) || Math.max(0, s)
  );
}
function nb() {
  var t3 = Qx, e = Kx, n = tb, i = Jx, r = eb, o = [0, 1 / 0], s = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], f = 250, l = z0, u = ha("start", "zoom", "end"), m, y, S, D = 500, q = 150, Te = 0, we = 10;
  function fe(N) {
    N.property("__zoom", Xu).on("wheel.zoom", Xe, { passive: false }).on("mousedown.zoom", nt).on("dblclick.zoom", lt).filter(r).on("touchstart.zoom", Ee).on("touchmove.zoom", ut).on("touchend.zoom touchcancel.zoom", rt).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  fe.transform = function(N, Pe, ie, ke) {
    var qe = N.selection ? N.selection() : N;
    qe.property("__zoom", Xu), N !== qe ? se(N, Pe, ie, ke) : qe.interrupt().each(function() {
      Le(this, arguments).event(ke).start().zoom(null, typeof Pe == "function" ? Pe.apply(this, arguments) : Pe).end();
    });
  }, fe.scaleBy = function(N, Pe, ie, ke) {
    fe.scaleTo(N, function() {
      var qe = this.__zoom.k, je = typeof Pe == "function" ? Pe.apply(this, arguments) : Pe;
      return qe * je;
    }, ie, ke);
  }, fe.scaleTo = function(N, Pe, ie, ke) {
    fe.transform(N, function() {
      var qe = e.apply(this, arguments), je = this.__zoom, Qe = ie == null ? V(qe) : typeof ie == "function" ? ie.apply(this, arguments) : ie, Ze = je.invert(Qe), dt = typeof Pe == "function" ? Pe.apply(this, arguments) : Pe;
      return n(Ve(Oe(je, dt), Qe, Ze), qe, s);
    }, ie, ke);
  }, fe.translateBy = function(N, Pe, ie, ke) {
    fe.transform(N, function() {
      return n(this.__zoom.translate(
        typeof Pe == "function" ? Pe.apply(this, arguments) : Pe,
        typeof ie == "function" ? ie.apply(this, arguments) : ie
      ), e.apply(this, arguments), s);
    }, null, ke);
  }, fe.translateTo = function(N, Pe, ie, ke, qe) {
    fe.transform(N, function() {
      var je = e.apply(this, arguments), Qe = this.__zoom, Ze = ke == null ? V(je) : typeof ke == "function" ? ke.apply(this, arguments) : ke;
      return n(Lr.translate(Ze[0], Ze[1]).scale(Qe.k).translate(
        typeof Pe == "function" ? -Pe.apply(this, arguments) : -Pe,
        typeof ie == "function" ? -ie.apply(this, arguments) : -ie
      ), je, s);
    }, ke, qe);
  };
  function Oe(N, Pe) {
    return Pe = Math.max(o[0], Math.min(o[1], Pe)), Pe === N.k ? N : new On(Pe, N.x, N.y);
  }
  function Ve(N, Pe, ie) {
    var ke = Pe[0] - ie[0] * N.k, qe = Pe[1] - ie[1] * N.k;
    return ke === N.x && qe === N.y ? N : new On(N.k, ke, qe);
  }
  function V(N) {
    return [(+N[0][0] + +N[1][0]) / 2, (+N[0][1] + +N[1][1]) / 2];
  }
  function se(N, Pe, ie, ke) {
    N.on("start.zoom", function() {
      Le(this, arguments).event(ke).start();
    }).on("interrupt.zoom end.zoom", function() {
      Le(this, arguments).event(ke).end();
    }).tween("zoom", function() {
      var qe = this, je = arguments, Qe = Le(qe, je).event(ke), Ze = e.apply(qe, je), dt = ie == null ? V(Ze) : typeof ie == "function" ? ie.apply(qe, je) : ie, ct = Math.max(Ze[1][0] - Ze[0][0], Ze[1][1] - Ze[0][1]), _t = qe.__zoom, st = typeof Pe == "function" ? Pe.apply(qe, je) : Pe, Vt = l(_t.invert(dt).concat(ct / _t.k), st.invert(dt).concat(ct / st.k));
      return function($t) {
        if ($t === 1) $t = st;
        else {
          var Yt = Vt($t), Pn = ct / Yt[2];
          $t = new On(Pn, dt[0] - Yt[0] * Pn, dt[1] - Yt[1] * Pn);
        }
        Qe.zoom(null, $t);
      };
    });
  }
  function Le(N, Pe, ie) {
    return !ie && N.__zooming || new Be(N, Pe);
  }
  function Be(N, Pe) {
    this.that = N, this.args = Pe, this.active = 0, this.sourceEvent = null, this.extent = e.apply(N, Pe), this.taps = 0;
  }
  Be.prototype = {
    event: function(N) {
      return N && (this.sourceEvent = N), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(N, Pe) {
      return this.mouse && N !== "mouse" && (this.mouse[1] = Pe.invert(this.mouse[0])), this.touch0 && N !== "touch" && (this.touch0[1] = Pe.invert(this.touch0[0])), this.touch1 && N !== "touch" && (this.touch1[1] = Pe.invert(this.touch1[0])), this.that.__zoom = Pe, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(N) {
      var Pe = zt(this.that).datum();
      u.call(
        N,
        this.that,
        new Zx(N, {
          sourceEvent: this.sourceEvent,
          target: fe,
          transform: this.that.__zoom,
          dispatch: u
        }),
        Pe
      );
    }
  };
  function Xe(N, ...Pe) {
    if (!t3.apply(this, arguments)) return;
    var ie = Le(this, Pe).event(N), ke = this.__zoom, qe = Math.max(o[0], Math.min(o[1], ke.k * Math.pow(2, i.apply(this, arguments)))), je = Mn(N);
    if (ie.wheel)
      (ie.mouse[0][0] !== je[0] || ie.mouse[0][1] !== je[1]) && (ie.mouse[1] = ke.invert(ie.mouse[0] = je)), clearTimeout(ie.wheel);
    else {
      if (ke.k === qe) return;
      ie.mouse = [je, ke.invert(je)], Ho(this), ie.start();
    }
    Pr(N), ie.wheel = setTimeout(Qe, q), ie.zoom("mouse", n(Ve(Oe(ke, qe), ie.mouse[0], ie.mouse[1]), ie.extent, s));
    function Qe() {
      ie.wheel = null, ie.end();
    }
  }
  function nt(N, ...Pe) {
    if (S || !t3.apply(this, arguments)) return;
    var ie = N.currentTarget, ke = Le(this, Pe, true).event(N), qe = zt(N.view).on("mousemove.zoom", dt, true).on("mouseup.zoom", ct, true), je = Mn(N, ie), Qe = N.clientX, Ze = N.clientY;
    Gc(N.view), Cs(N), ke.mouse = [je, this.__zoom.invert(je)], Ho(this), ke.start();
    function dt(_t) {
      if (Pr(_t), !ke.moved) {
        var st = _t.clientX - Qe, Vt = _t.clientY - Ze;
        ke.moved = st * st + Vt * Vt > Te;
      }
      ke.event(_t).zoom("mouse", n(Ve(ke.that.__zoom, ke.mouse[0] = Mn(_t, ie), ke.mouse[1]), ke.extent, s));
    }
    function ct(_t) {
      qe.on("mousemove.zoom mouseup.zoom", null), Bc(_t.view, ke.moved), Pr(_t), ke.event(_t).end();
    }
  }
  function lt(N, ...Pe) {
    if (t3.apply(this, arguments)) {
      var ie = this.__zoom, ke = Mn(N.changedTouches ? N.changedTouches[0] : N, this), qe = ie.invert(ke), je = ie.k * (N.shiftKey ? 0.5 : 2), Qe = n(Ve(Oe(ie, je), ke, qe), e.apply(this, Pe), s);
      Pr(N), f > 0 ? zt(this).transition().duration(f).call(se, Qe, ke, N) : zt(this).call(fe.transform, Qe, ke, N);
    }
  }
  function Ee(N, ...Pe) {
    if (t3.apply(this, arguments)) {
      var ie = N.touches, ke = ie.length, qe = Le(this, Pe, N.changedTouches.length === ke).event(N), je, Qe, Ze, dt;
      for (Cs(N), Qe = 0; Qe < ke; ++Qe)
        Ze = ie[Qe], dt = Mn(Ze, this), dt = [dt, this.__zoom.invert(dt), Ze.identifier], qe.touch0 ? !qe.touch1 && qe.touch0[2] !== dt[2] && (qe.touch1 = dt, qe.taps = 0) : (qe.touch0 = dt, je = true, qe.taps = 1 + !!m);
      m && (m = clearTimeout(m)), je && (qe.taps < 2 && (y = dt[0], m = setTimeout(function() {
        m = null;
      }, D)), Ho(this), qe.start());
    }
  }
  function ut(N, ...Pe) {
    if (this.__zooming) {
      var ie = Le(this, Pe).event(N), ke = N.changedTouches, qe = ke.length, je, Qe, Ze, dt;
      for (Pr(N), je = 0; je < qe; ++je)
        Qe = ke[je], Ze = Mn(Qe, this), ie.touch0 && ie.touch0[2] === Qe.identifier ? ie.touch0[0] = Ze : ie.touch1 && ie.touch1[2] === Qe.identifier && (ie.touch1[0] = Ze);
      if (Qe = ie.that.__zoom, ie.touch1) {
        var ct = ie.touch0[0], _t = ie.touch0[1], st = ie.touch1[0], Vt = ie.touch1[1], $t = ($t = st[0] - ct[0]) * $t + ($t = st[1] - ct[1]) * $t, Yt = (Yt = Vt[0] - _t[0]) * Yt + (Yt = Vt[1] - _t[1]) * Yt;
        Qe = Oe(Qe, Math.sqrt($t / Yt)), Ze = [(ct[0] + st[0]) / 2, (ct[1] + st[1]) / 2], dt = [(_t[0] + Vt[0]) / 2, (_t[1] + Vt[1]) / 2];
      } else if (ie.touch0) Ze = ie.touch0[0], dt = ie.touch0[1];
      else return;
      ie.zoom("touch", n(Ve(Qe, Ze, dt), ie.extent, s));
    }
  }
  function rt(N, ...Pe) {
    if (this.__zooming) {
      var ie = Le(this, Pe).event(N), ke = N.changedTouches, qe = ke.length, je, Qe;
      for (Cs(N), S && clearTimeout(S), S = setTimeout(function() {
        S = null;
      }, D), je = 0; je < qe; ++je)
        Qe = ke[je], ie.touch0 && ie.touch0[2] === Qe.identifier ? delete ie.touch0 : ie.touch1 && ie.touch1[2] === Qe.identifier && delete ie.touch1;
      if (ie.touch1 && !ie.touch0 && (ie.touch0 = ie.touch1, delete ie.touch1), ie.touch0) ie.touch0[1] = this.__zoom.invert(ie.touch0[0]);
      else if (ie.end(), ie.taps === 2 && (Qe = Mn(Qe, this), Math.hypot(y[0] - Qe[0], y[1] - Qe[1]) < we)) {
        var Ze = zt(this).on("dblclick.zoom");
        Ze && Ze.apply(this, arguments);
      }
    }
  }
  return fe.wheelDelta = function(N) {
    return arguments.length ? (i = typeof N == "function" ? N : Bo(+N), fe) : i;
  }, fe.filter = function(N) {
    return arguments.length ? (t3 = typeof N == "function" ? N : Bo(!!N), fe) : t3;
  }, fe.touchable = function(N) {
    return arguments.length ? (r = typeof N == "function" ? N : Bo(!!N), fe) : r;
  }, fe.extent = function(N) {
    return arguments.length ? (e = typeof N == "function" ? N : Bo([[+N[0][0], +N[0][1]], [+N[1][0], +N[1][1]]]), fe) : e;
  }, fe.scaleExtent = function(N) {
    return arguments.length ? (o[0] = +N[0], o[1] = +N[1], fe) : [o[0], o[1]];
  }, fe.translateExtent = function(N) {
    return arguments.length ? (s[0][0] = +N[0][0], s[1][0] = +N[1][0], s[0][1] = +N[0][1], s[1][1] = +N[1][1], fe) : [[s[0][0], s[0][1]], [s[1][0], s[1][1]]];
  }, fe.constrain = function(N) {
    return arguments.length ? (n = N, fe) : n;
  }, fe.duration = function(N) {
    return arguments.length ? (f = +N, fe) : f;
  }, fe.interpolate = function(N) {
    return arguments.length ? (l = N, fe) : l;
  }, fe.on = function() {
    var N = u.on.apply(u, arguments);
    return N === u ? fe : N;
  }, fe.clickDistance = function(N) {
    return arguments.length ? (Te = (N = +N) * N, fe) : Math.sqrt(Te);
  }, fe.tapDistance = function(N) {
    return arguments.length ? (we = +N, fe) : we;
  }, fe;
}
var ib = class {
  constructor(e, n) {
    this.eventTransform = Lr, this.behavior = nb().scaleExtent([1e-3, 1 / 0]).on("start", (i) => {
      var o, s;
      this.isRunning = true;
      const r = !!i.sourceEvent;
      (s = (o = this.config) == null ? void 0 : o.onZoomStart) == null || s.call(o, i, r);
    }).on("zoom", (i) => {
      var S, D;
      this.eventTransform = i.transform;
      const { eventTransform: { x: r, y: o, k: s }, store: { transform: f, screenSize: l } } = this, u = l[0], m = l[1];
      if (!u || !m) return;
      ex(f, u, m), Ru(f, f, [r, o]), ws(f, f, [s, s]), Ru(f, f, [u / 2, m / 2]), ws(f, f, [u / 2, m / 2]), ws(f, f, [1, -1]);
      const y = !!i.sourceEvent;
      (D = (S = this.config) == null ? void 0 : S.onZoom) == null || D.call(S, i, y);
    }).on("end", (i) => {
      var o, s;
      this.isRunning = false;
      const r = !!i.sourceEvent;
      (s = (o = this.config) == null ? void 0 : o.onZoomEnd) == null || s.call(o, i, r);
    }), this.isRunning = false, this.store = e, this.config = n;
  }
  /**
   * Get the zoom transform that will fit the given point positions into the viewport
   *
   * @param positions An array of point positions in the form `[x, y]`
   * @param scale An optional scale factor to apply to the transform
   * @param padding Padding around the viewport in percentage
   */
  getTransform(e, n, i = 0.1) {
    if (e.length === 0) return this.eventTransform;
    const { store: { screenSize: r } } = this, o = r[0], s = r[1], f = Eu(e.map((fe) => fe[0])), l = Eu(e.map((fe) => fe[1]));
    f[0] = this.store.scaleX(f[0]), f[1] = this.store.scaleX(f[1]), l[0] = this.store.scaleY(l[0]), l[1] = this.store.scaleY(l[1]), f[0] === f[1] && (f[0] -= 0.5, f[1] += 0.5), l[0] === l[1] && (l[0] += 0.5, l[1] -= 0.5);
    const u = o * (1 - i * 2) / (f[1] - f[0]), m = s * (1 - i * 2) / (l[0] - l[1]), y = kg(n ?? Math.min(u, m), ...this.behavior.scaleExtent()), S = (f[1] + f[0]) / 2, D = (l[1] + l[0]) / 2, q = o / 2 - S * y, Te = s / 2 - D * y;
    return Lr.translate(q, Te).scale(y);
  }
  getDistanceToPoint(e) {
    const { x: n, y: i, k: r } = this.eventTransform, o = this.getTransform([e], r), s = n - o.x, f = i - o.y;
    return Math.sqrt(s * s + f * f);
  }
  getMiddlePointTransform(e) {
    const { store: { screenSize: n }, eventTransform: { x: i, y: r, k: o } } = this, s = n[0], f = n[1], l = (s / 2 - i) / o, u = (f / 2 - r) / o, m = this.store.scaleX(e[0]), y = this.store.scaleY(e[1]), S = (l + m) / 2, D = (u + y) / 2, q = 1, Te = s / 2 - S * q, we = f / 2 - D * q;
    return Lr.translate(Te, we).scale(q);
  }
  convertScreenToSpacePosition(e) {
    const { eventTransform: { x: n, y: i, k: r }, store: { screenSize: o } } = this, s = o[0], f = o[1], l = (e[0] - n) / r, u = (e[1] - i) / r, m = [l, f - u];
    return m[0] -= (s - this.store.adjustedSpaceSize) / 2, m[1] -= (f - this.store.adjustedSpaceSize) / 2, m;
  }
  convertSpaceToScreenPosition(e) {
    const n = this.eventTransform.applyX(this.store.scaleX(e[0])), i = this.eventTransform.applyY(this.store.scaleY(e[1]));
    return [n, i];
  }
  convertSpaceToScreenRadius(e) {
    const { config: { scalePointsOnZoom: n }, store: { maxPointSize: i }, eventTransform: { k: r } } = this;
    let o = e * 2;
    return n ? o *= r : o *= Math.min(5, Math.max(1, r * 0.01)), Math.min(o, i) / 2;
  }
};
var rb = class {
  constructor(e, n) {
    this.isActive = false, this.behavior = Yx().subject((i) => this.store.hoveredPoint && !this.store.isSpaceKeyPressed ? { x: i.x, y: i.y } : void 0).on("start", (i) => {
      var r, o;
      this.store.hoveredPoint && (this.store.draggingPointIndex = this.store.hoveredPoint.index, this.isActive = true, (o = (r = this.config) == null ? void 0 : r.onDragStart) == null || o.call(r, i));
    }).on("drag", (i) => {
      var r, o;
      (o = (r = this.config) == null ? void 0 : r.onDrag) == null || o.call(r, i);
    }).on("end", (i) => {
      var r, o;
      this.isActive = false, this.store.draggingPointIndex = void 0, (o = (r = this.config) == null ? void 0 : r.onDragEnd) == null || o.call(r, i);
    }), this.store = e, this.config = n;
  }
};
function ob(t3) {
  const e = document.createElement("div");
  return e.style.cssText = `
    color: var(--cosmosgl-error-message-color);
    padding: 0em 2em;
    position: absolute;
    top: 50%; left: 0; right: 0;
    transform: translateY(-50%);
    z-index: 1000;
    font-family: inherit;
    font-size: 1rem;
    text-align: center;
    user-select: none;
  `, e.textContent = "Sorry, your device or browser does not support the required WebGL features for this visualization", t3.appendChild(e), e;
}
var ab = class {
  constructor(e, n) {
    this.config = new Lg(), this.graph = new ny(this.config), this.requestAnimationFrameId = 0, this.isRightClickMouse = false, this.store = new $x(), this.zoomInstance = new ib(this.store, this.config), this.dragInstance = new rb(this.store, this.config), this._findHoveredItemExecutionCount = 0, this._isMouseOnCanvas = false, this._isFirstRenderAfterInit = true, this.isPointPositionsUpdateNeeded = false, this.isPointColorUpdateNeeded = false, this.isPointSizeUpdateNeeded = false, this.isPointShapeUpdateNeeded = false, this.isPointImageIndicesUpdateNeeded = false, this.isLinksUpdateNeeded = false, this.isLinkColorUpdateNeeded = false, this.isLinkWidthUpdateNeeded = false, this.isLinkArrowUpdateNeeded = false, this.isPointClusterUpdateNeeded = false, this.isForceManyBodyUpdateNeeded = false, this.isForceLinkUpdateNeeded = false, this.isForceCenterUpdateNeeded = false, this.isPointImageSizesUpdateNeeded = false, this._isDestroyed = false, n && this.config.init(n), this.store.div = e;
    const i = document.createElement("canvas");
    i.style.width = "100%", i.style.height = "100%", this.store.div.appendChild(i), this.addAttribution();
    const r = i.clientWidth, o = i.clientHeight;
    i.width = r * this.config.pixelRatio, i.height = o * this.config.pixelRatio, this.canvas = i;
    let s;
    try {
      s = Wv({
        canvas: this.canvas,
        attributes: {
          antialias: false,
          preserveDrawingBuffer: true
        },
        extensions: ["OES_texture_float", "ANGLE_instanced_arrays"]
      });
    } catch {
      ob(this.store.div), this._isDestroyed = true;
      return;
    }
    this.reglInstance = s, this.store.adjustSpaceSize(this.config.spaceSize, this.reglInstance.limits.maxTextureSize), this.store.setWebGLMaxTextureSize(this.reglInstance.limits.maxTextureSize), this.store.updateScreenSize(r, o), this.canvasD3Selection = zt(this.canvas), this.canvasD3Selection.on("mouseenter.cosmos", () => {
      this._isMouseOnCanvas = true;
    }).on("mousemove.cosmos", () => {
      this._isMouseOnCanvas = true;
    }).on("mouseleave.cosmos", (f) => {
      this._isMouseOnCanvas = false, this.currentEvent = f, this.store.hoveredPoint !== void 0 && this.config.onPointMouseOut && this.config.onPointMouseOut(f), this.store.hoveredLinkIndex !== void 0 && this.config.onLinkMouseOut && this.config.onLinkMouseOut(f), this.isRightClickMouse = false, this.store.hoveredPoint = void 0, this.store.hoveredLinkIndex = void 0, this.updateCanvasCursor();
    }), zt(document).on("keydown.cosmos", (f) => {
      f.code === "Space" && (this.store.isSpaceKeyPressed = true);
    }).on("keyup.cosmos", (f) => {
      f.code === "Space" && (this.store.isSpaceKeyPressed = false);
    }), this.zoomInstance.behavior.on("start.detect", (f) => {
      this.currentEvent = f;
    }).on("zoom.detect", (f) => {
      !!f.sourceEvent && this.updateMousePosition(f.sourceEvent), this.currentEvent = f;
    }).on("end.detect", (f) => {
      this.currentEvent = f;
    }), this.dragInstance.behavior.on("start.detect", (f) => {
      this.currentEvent = f, this.updateCanvasCursor();
    }).on("drag.detect", (f) => {
      this.dragInstance.isActive && this.updateMousePosition(f), this.currentEvent = f;
    }).on("end.detect", (f) => {
      this.currentEvent = f, this.updateCanvasCursor();
    }), this.canvasD3Selection.call(this.dragInstance.behavior).call(this.zoomInstance.behavior).on("click", this.onClick.bind(this)).on("mousemove", this.onMouseMove.bind(this)).on("contextmenu", this.onRightClickMouse.bind(this)), (!this.config.enableZoom || !this.config.enableDrag) && this.updateZoomDragBehaviors(), this.setZoomLevel(this.config.initialZoomLevel ?? 1), this.store.maxPointSize = (this.reglInstance.limits.pointSizeDims[1] ?? Xs) / this.config.pixelRatio, this.points = new Ky(this.reglInstance, this.config, this.store, this.graph), this.lines = new Oy(this.reglInstance, this.config, this.store, this.graph, this.points), this.config.enableSimulation && (this.forceGravity = new Og(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceCenter = new Rg(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceManyBody = this.config.useClassicQuadtree ? new $g(this.reglInstance, this.config, this.store, this.graph, this.points) : new Ug(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceLinkIncoming = new Tu(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceLinkOutgoing = new Tu(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceMouse = new Wg(this.reglInstance, this.config, this.store, this.graph, this.points)), this.clusters = new Yg(this.reglInstance, this.config, this.store, this.graph, this.points), this.store.backgroundColor = Kn(this.config.backgroundColor), this.store.setHoveredPointRingColor(this.config.hoveredPointRingColor ?? Ge.hoveredPointRingColor), this.store.setFocusedPointRingColor(this.config.focusedPointRingColor ?? Ge.focusedPointRingColor), this.config.focusedPointIndex !== void 0 && this.store.setFocusedPoint(this.config.focusedPointIndex), this.store.setGreyoutPointColor(this.config.pointGreyoutColor ?? Rs), this.store.setHoveredLinkColor(this.config.hoveredLinkColor ?? Ge.hoveredLinkColor), this.store.updateLinkHoveringEnabled(this.config), this.config.showFPSMonitor && (this.fpsMonitor = new Au(this.canvas)), this.config.randomSeed !== void 0 && this.store.addRandomSeed(this.config.randomSeed);
  }
  /**
   * Returns the current simulation progress
   */
  get progress() {
    return this._isDestroyed ? 0 : this.store.simulationProgress;
  }
  /**
   * A value that gives information about the running simulation status.
   */
  get isSimulationRunning() {
    return this._isDestroyed ? false : this.store.isSimulationRunning;
  }
  /**
   * The maximum point size.
   * This value is the maximum size of the `gl.POINTS` primitive that WebGL can render on the user's hardware.
   */
  get maxPointSize() {
    return this._isDestroyed ? 0 : this.store.maxPointSize;
  }
  /**
   * Set or update Cosmos configuration. The changes will be applied in real time.
   * @param config Cosmos configuration object.
   */
  setConfig(e) {
    var i;
    if (this._isDestroyed || !this.reglInstance || !this.points || !this.lines || !this.clusters) return;
    const n = { ...this.config };
    this.config.init(e), n.pointColor !== this.config.pointColor && (this.graph.updatePointColor(), this.points.updateColor()), n.pointSize !== this.config.pointSize && (this.graph.updatePointSize(), this.points.updateSize()), n.linkColor !== this.config.linkColor && (this.graph.updateLinkColor(), this.lines.updateColor()), n.linkWidth !== this.config.linkWidth && (this.graph.updateLinkWidth(), this.lines.updateWidth()), n.linkArrows !== this.config.linkArrows && (this.graph.updateArrows(), this.lines.updateArrow()), (n.curvedLinkSegments !== this.config.curvedLinkSegments || n.curvedLinks !== this.config.curvedLinks) && this.lines.updateCurveLineGeometry(), n.backgroundColor !== this.config.backgroundColor && (this.store.backgroundColor = Kn(this.config.backgroundColor ?? yc)), n.hoveredPointRingColor !== this.config.hoveredPointRingColor && this.store.setHoveredPointRingColor(this.config.hoveredPointRingColor ?? Ge.hoveredPointRingColor), n.focusedPointRingColor !== this.config.focusedPointRingColor && this.store.setFocusedPointRingColor(this.config.focusedPointRingColor ?? Ge.focusedPointRingColor), n.pointGreyoutColor !== this.config.pointGreyoutColor && this.store.setGreyoutPointColor(this.config.pointGreyoutColor ?? Rs), n.hoveredLinkColor !== this.config.hoveredLinkColor && this.store.setHoveredLinkColor(this.config.hoveredLinkColor ?? Ge.hoveredLinkColor), n.focusedPointIndex !== this.config.focusedPointIndex && this.store.setFocusedPoint(this.config.focusedPointIndex), (n.spaceSize !== this.config.spaceSize || n.simulationRepulsionQuadtreeLevels !== this.config.simulationRepulsionQuadtreeLevels) && (this.store.adjustSpaceSize(this.config.spaceSize, this.reglInstance.limits.maxTextureSize), this.resizeCanvas(true), this.update(this.store.isSimulationRunning ? this.store.alpha : 0)), n.showFPSMonitor !== this.config.showFPSMonitor && (this.config.showFPSMonitor ? this.fpsMonitor = new Au(this.canvas) : ((i = this.fpsMonitor) == null || i.destroy(), this.fpsMonitor = void 0)), n.pixelRatio !== this.config.pixelRatio && (this.store.maxPointSize = (this.reglInstance.limits.pointSizeDims[1] ?? Xs) / this.config.pixelRatio), (n.enableZoom !== this.config.enableZoom || n.enableDrag !== this.config.enableDrag) && this.updateZoomDragBehaviors(), (n.onLinkClick !== this.config.onLinkClick || n.onLinkMouseOver !== this.config.onLinkMouseOver || n.onLinkMouseOut !== this.config.onLinkMouseOut) && this.store.updateLinkHoveringEnabled(this.config);
  }
  /**
   * Sets the positions for the graph points.
   *
   * @param {Float32Array} pointPositions - A Float32Array representing the positions of points in the format [x1, y1, x2, y2, ..., xn, yn],
   * where `n` is the index of the point.
   * Example: `new Float32Array([1, 2, 3, 4, 5, 6])` sets the first point to (1, 2), the second point to (3, 4), and so on.
   * @param {boolean | undefined} dontRescale - For this call only, don't rescale the points.
   *   - `true`: Don't rescale.
   *   - `false` or `undefined` (default): Use the behavior defined by `config.rescalePositions`.
   */
  setPointPositions(e, n) {
    this._isDestroyed || !this.points || (this.graph.inputPointPositions = e, this.points.shouldSkipRescale = n, this.isPointPositionsUpdateNeeded = true, this.isLinksUpdateNeeded = true, this.isPointColorUpdateNeeded = true, this.isPointSizeUpdateNeeded = true, this.isPointShapeUpdateNeeded = true, this.isPointImageIndicesUpdateNeeded = true, this.isPointClusterUpdateNeeded = true, this.isForceManyBodyUpdateNeeded = true, this.isForceLinkUpdateNeeded = true, this.isForceCenterUpdateNeeded = true);
  }
  /**
   * Sets the colors for the graph points.
   *
   * @param {Float32Array} pointColors - A Float32Array representing the colors of points in the format [r1, g1, b1, a1, r2, g2, b2, a2, ..., rn, gn, bn, an],
   * where each color is represented in RGBA format.
   * Example: `new Float32Array([255, 0, 0, 1, 0, 255, 0, 1])` sets the first point to red and the second point to green.
  */
  setPointColors(e) {
    this._isDestroyed || (this.graph.inputPointColors = e, this.isPointColorUpdateNeeded = true);
  }
  /**
   * Gets the current colors of the graph points.
   *
   * @returns {Float32Array} A Float32Array representing the colors of points in the format [r1, g1, b1, a1, r2, g2, b2, a2, ..., rn, gn, bn, an],
   * where each color is in RGBA format. Returns an empty Float32Array if no point colors are set.
   */
  getPointColors() {
    return this._isDestroyed ? new Float32Array() : this.graph.pointColors ?? new Float32Array();
  }
  /**
   * Sets the sizes for the graph points.
   *
   * @param {Float32Array} pointSizes - A Float32Array representing the sizes of points in the format [size1, size2, ..., sizen],
   * where `n` is the index of the point.
   * Example: `new Float32Array([10, 20, 30])` sets the first point to size 10, the second point to size 20, and the third point to size 30.
   */
  setPointSizes(e) {
    this._isDestroyed || (this.graph.inputPointSizes = e, this.isPointSizeUpdateNeeded = true);
  }
  /**
   * Sets the shapes for the graph points.
   *
   * @param {Float32Array} pointShapes - A Float32Array representing the shapes of points in the format [shape1, shape2, ..., shapen],
   * where `n` is the index of the point and each shape value corresponds to a PointShape enum:
   * 0 = Circle, 1 = Square, 2 = Triangle, 3 = Diamond, 4 = Pentagon, 5 = Hexagon, 6 = Star, 7 = Cross, 8 = None.
   * Example: `new Float32Array([0, 1, 2])` sets the first point to Circle, the second point to Square, and the third point to Triangle.
   * Images are rendered above shapes.
   */
  setPointShapes(e) {
    this._isDestroyed || (this.graph.inputPointShapes = e, this.isPointShapeUpdateNeeded = true);
  }
  /**
   * Sets the images for the graph points using ImageData objects.
   * Images are rendered above shapes.
   * To use images, provide image indices via setPointImageIndices().
   *
   * @param {ImageData[]} imageDataArray - Array of ImageData objects to use as point images.
   * Example: `setImageData([imageData1, imageData2, imageData3])`
   */
  setImageData(e) {
    this._isDestroyed || !this.points || (this.graph.inputImageData = e, this.points.createAtlas());
  }
  /**
   * Sets which image each point should use from the images array.
   * Images are rendered above shapes.
   *
   * @param {Float32Array} imageIndices - A Float32Array representing which image each point uses in the format [index1, index2, ..., indexn],
   * where `n` is the index of the point and each value is an index into the images array provided to `setImageData`.
   * Example: `new Float32Array([0, 1, 0])` sets the first point to use image 0, second point to use image 1, third point to use image 0.
   */
  setPointImageIndices(e) {
    this._isDestroyed || (this.graph.inputPointImageIndices = e, this.isPointImageIndicesUpdateNeeded = true);
  }
  /**
   * Sets the sizes for the point images.
   *
   * @param {Float32Array} imageSizes - A Float32Array representing the sizes of point images in the format [size1, size2, ..., sizen],
   * where `n` is the index of the point.
   * Example: `new Float32Array([10, 20, 30])` sets the first image to size 10, the second image to size 20, and the third image to size 30.
   */
  setPointImageSizes(e) {
    this._isDestroyed || (this.graph.inputPointImageSizes = e, this.isPointImageSizesUpdateNeeded = true);
  }
  /**
   * Gets the current sizes of the graph points.
   *
   * @returns {Float32Array} A Float32Array representing the sizes of points in the format [size1, size2, ..., sizen],
   * where `n` is the index of the point. Returns an empty Float32Array if no point sizes are set.
   */
  getPointSizes() {
    return this._isDestroyed ? new Float32Array() : this.graph.pointSizes ?? new Float32Array();
  }
  /**
   * Sets the links for the graph.
   *
   * @param {Float32Array} links - A Float32Array representing the links between points
   * in the format [source1, target1, source2, target2, ..., sourcen, targetn],
   * where `source` and `target` are the indices of the points being linked.
   * Example: `new Float32Array([0, 1, 1, 2])` creates a link from point 0 to point 1 and another link from point 1 to point 2.
   */
  setLinks(e) {
    this._isDestroyed || (this.graph.inputLinks = e, this.isLinksUpdateNeeded = true, this.isLinkColorUpdateNeeded = true, this.isLinkWidthUpdateNeeded = true, this.isLinkArrowUpdateNeeded = true, this.isForceLinkUpdateNeeded = true);
  }
  /**
   * Sets the colors for the graph links.
   *
   * @param {Float32Array} linkColors - A Float32Array representing the colors of links in the format [r1, g1, b1, a1, r2, g2, b2, a2, ..., rn, gn, bn, an],
   * where each color is in RGBA format.
   * Example: `new Float32Array([255, 0, 0, 1, 0, 255, 0, 1])` sets the first link to red and the second link to green.
   */
  setLinkColors(e) {
    this._isDestroyed || (this.graph.inputLinkColors = e, this.isLinkColorUpdateNeeded = true);
  }
  /**
   * Gets the current colors of the graph links.
   *
   * @returns {Float32Array} A Float32Array representing the colors of links in the format [r1, g1, b1, a1, r2, g2, b2, a2, ..., rn, gn, bn, an],
   * where each color is in RGBA format. Returns an empty Float32Array if no link colors are set.
   */
  getLinkColors() {
    return this._isDestroyed ? new Float32Array() : this.graph.linkColors ?? new Float32Array();
  }
  /**
   * Sets the widths for the graph links.
   *
   * @param {Float32Array} linkWidths - A Float32Array representing the widths of links in the format [width1, width2, ..., widthn],
   * where `n` is the index of the link.
   * Example: `new Float32Array([1, 2, 3])` sets the first link to width 1, the second link to width 2, and the third link to width 3.
   */
  setLinkWidths(e) {
    this._isDestroyed || (this.graph.inputLinkWidths = e, this.isLinkWidthUpdateNeeded = true);
  }
  /**
   * Gets the current widths of the graph links.
   *
   * @returns {Float32Array} A Float32Array representing the widths of links in the format [width1, width2, ..., widthn],
   * where `n` is the index of the link. Returns an empty Float32Array if no link widths are set.
   */
  getLinkWidths() {
    return this._isDestroyed ? new Float32Array() : this.graph.linkWidths ?? new Float32Array();
  }
  /**
   * Sets the arrows for the graph links.
   *
   * @param {boolean[]} linkArrows - An array of booleans indicating whether each link should have an arrow,
   * in the format [arrow1, arrow2, ..., arrown], where `n` is the index of the link.
   * Example: `[true, false, true]` sets arrows on the first and third links, but not on the second link.
   */
  setLinkArrows(e) {
    this._isDestroyed || (this.graph.linkArrowsBoolean = e, this.isLinkArrowUpdateNeeded = true);
  }
  /**
   * Sets the strength for the graph links.
   *
   * @param {Float32Array} linkStrength - A Float32Array representing the strength of each link in the format [strength1, strength2, ..., strengthn],
   * where `n` is the index of the link.
   * Example: `new Float32Array([1, 2, 3])` sets the first link to strength 1, the second link to strength 2, and the third link to strength 3.
   */
  setLinkStrength(e) {
    this._isDestroyed || (this.graph.inputLinkStrength = e, this.isForceLinkUpdateNeeded = true);
  }
  /**
   * Sets the point clusters for the graph.
   *
   * @param {(number | undefined)[]} pointClusters - Array of cluster indices for each point in the graph.
   *   - Index: Each index corresponds to a point.
   *   - Values: Integers starting from 0; `undefined` indicates that a point does not belong to any cluster and will not be affected by cluster forces.
   * @example
   *   `[0, 1, 0, 2, undefined, 1]` maps points to clusters: point 0 and 2 to cluster 0, point 1 to cluster 1, and point 3 to cluster 2.
   * Points 4 is unclustered.
   * @note Clusters without specified positions via `setClusterPositions` will be positioned at their centermass by default.
   */
  setPointClusters(e) {
    this._isDestroyed || (this.graph.inputPointClusters = e, this.isPointClusterUpdateNeeded = true);
  }
  /**
   * Sets the positions of the point clusters for the graph.
   *
   * @param {(number | undefined)[]} clusterPositions - Array of cluster positions.
   *   - Every two elements represent the x and y coordinates for a cluster position.
   *   - `undefined` means the cluster's position is not defined and will use centermass positioning instead.
   * @example
   *   `[10, 20, 30, 40, undefined, undefined]` places the first cluster at (10, 20) and the second at (30, 40);
   * the third cluster will be positioned at its centermass automatically.
   */
  setClusterPositions(e) {
    this._isDestroyed || (this.graph.inputClusterPositions = e, this.isPointClusterUpdateNeeded = true);
  }
  /**
   * Sets the force strength coefficients for clustering points in the graph.
   *
   * This method allows you to customize the forces acting on individual points during the clustering process.
   * The force coefficients determine the strength of the forces applied to each point.
   *
   * @param {Float32Array} clusterStrength - A Float32Array of force strength coefficients for each point in the format [coeff1, coeff2, ..., coeffn],
   * where `n` is the index of the point.
   * Example: `new Float32Array([1, 0.4, 0.3])` sets the force coefficient for point 0 to 1, point 1 to 0.4, and point 2 to 0.3.
   */
  setPointClusterStrength(e) {
    this._isDestroyed || (this.graph.inputClusterStrength = e, this.isPointClusterUpdateNeeded = true);
  }
  /**
   * Renders the graph.
   *
   * @param {number} [simulationAlpha] - Optional value between 0 and 1
   * that controls the initial energy of the simulation.The higher the value,
   * the more initial energy the simulation will get. Zero value stops the simulation.
   */
  render(e) {
    if (this._isDestroyed || !this.reglInstance) return;
    this.graph.update();
    const { fitViewOnInit: n, fitViewDelay: i, fitViewPadding: r, fitViewDuration: o, fitViewByPointsInRect: s, fitViewByPointIndices: f, initialZoomLevel: l } = this.config;
    if (!this.graph.pointsNumber && !this.graph.linksNumber) {
      this.stopFrames(), zt(this.canvas).style("cursor", null), this.reglInstance.clear({
        color: this.store.backgroundColor,
        depth: 1,
        stencil: 0
      });
      return;
    }
    this._isFirstRenderAfterInit && n && l === void 0 && (this._fitViewOnInitTimeoutID = window.setTimeout(() => {
      f ? this.fitViewByPointIndices(f, o, r) : s ? this.setZoomTransformByPointPositions(s, o, void 0, r) : this.fitView(o, r);
    }, i)), this._isFirstRenderAfterInit = false, this.update(e);
  }
  /**
   * Center the view on a point and zoom in, by point index.
   * @param index The index of the point in the array of points.
   * @param duration Duration of the animation transition in milliseconds (`700` by default).
   * @param scale Scale value to zoom in or out (`3` by default).
   * @param canZoomOut Set to `false` to prevent zooming out from the point (`true` by default).
   */
  zoomToPointByIndex(e, n = 700, i = ng, r = true) {
    if (this._isDestroyed || !this.reglInstance || !this.points || !this.canvasD3Selection) return;
    const { store: { screenSize: o } } = this, s = tn(this.reglInstance, this.points.currentPositionFbo);
    if (e === void 0) return;
    const f = s[e * 4 + 0], l = s[e * 4 + 1];
    if (f === void 0 || l === void 0) return;
    const u = this.zoomInstance.getDistanceToPoint([f, l]), m = r ? i : Math.max(this.getZoomLevel(), i);
    if (u < Math.min(o[0], o[1]))
      this.setZoomTransformByPointPositions([f, l], n, m);
    else {
      const y = this.zoomInstance.getTransform([[f, l]], m), S = this.zoomInstance.getMiddlePointTransform([f, l]);
      this.canvasD3Selection.transition().ease(zv).duration(n / 2).call(this.zoomInstance.behavior.transform, S).transition().ease(Rv).duration(n / 2).call(this.zoomInstance.behavior.transform, y);
    }
  }
  /**
   * Zoom the view in or out to the specified zoom level.
   * @param value Zoom level
   * @param duration Duration of the zoom in/out transition.
   */
  zoom(e, n = 0) {
    this._isDestroyed || this.setZoomLevel(e, n);
  }
  /**
   * Zoom the view in or out to the specified zoom level.
   * @param value Zoom level
   * @param duration Duration of the zoom in/out transition.
   */
  setZoomLevel(e, n = 0) {
    this._isDestroyed || !this.canvasD3Selection || (n === 0 ? this.canvasD3Selection.call(this.zoomInstance.behavior.scaleTo, e) : this.canvasD3Selection.transition().duration(n).call(this.zoomInstance.behavior.scaleTo, e));
  }
  /**
   * Get zoom level.
   * @returns Zoom level value of the view.
   */
  getZoomLevel() {
    return this._isDestroyed ? 0 : this.zoomInstance.eventTransform.k;
  }
  /**
   * Get current X and Y coordinates of the points.
   * @returns Array of point positions.
   */
  getPointPositions() {
    if (this._isDestroyed || !this.reglInstance || !this.points) return [];
    if (this.graph.pointsNumber === void 0) return [];
    const e = [], n = tn(this.reglInstance, this.points.currentPositionFbo);
    e.length = this.graph.pointsNumber * 2;
    for (let i = 0; i < this.graph.pointsNumber; i += 1) {
      const r = n[i * 4 + 0], o = n[i * 4 + 1];
      r !== void 0 && o !== void 0 && (e[i * 2] = r, e[i * 2 + 1] = o);
    }
    return e;
  }
  /**
   * Get current X and Y coordinates of the clusters.
   * @returns Array of point cluster.
   */
  getClusterPositions() {
    if (this._isDestroyed || !this.reglInstance || !this.clusters) return [];
    if (this.graph.pointClusters === void 0 || this.clusters.clusterCount === void 0) return [];
    this.clusters.calculateCentermass();
    const e = [], n = tn(this.reglInstance, this.clusters.centermassFbo);
    e.length = this.clusters.clusterCount * 2;
    for (let i = 0; i < e.length / 2; i += 1) {
      const r = n[i * 4 + 0], o = n[i * 4 + 1], s = n[i * 4 + 2];
      r !== void 0 && o !== void 0 && s !== void 0 && (e[i * 2] = r / s, e[i * 2 + 1] = o / s);
    }
    return e;
  }
  /**
   * Center and zoom in/out the view to fit all points in the scene.
   * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
   * @param padding Padding around the viewport in percentage (`0.1` by default).
   */
  fitView(e = 250, n = 0.1) {
    this._isDestroyed || this.setZoomTransformByPointPositions(this.getPointPositions(), e, void 0, n);
  }
  /**
   * Center and zoom in/out the view to fit points by their indices in the scene.
   * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
   * @param padding Padding around the viewport in percentage
   */
  fitViewByPointIndices(e, n = 250, i = 0.1) {
    if (this._isDestroyed) return;
    const r = this.getPointPositions(), o = new Array(e.length * 2);
    for (const [s, f] of e.entries())
      o[s * 2] = r[f * 2], o[s * 2 + 1] = r[f * 2 + 1];
    this.setZoomTransformByPointPositions(o, n, void 0, i);
  }
  /**
   * Center and zoom in/out the view to fit points by their positions in the scene.
   * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
   * @param padding Padding around the viewport in percentage
   */
  fitViewByPointPositions(e, n = 250, i = 0.1) {
    this._isDestroyed || this.setZoomTransformByPointPositions(e, n, void 0, i);
  }
  /**
   * Get points indices inside a rectangular area.
   * @param selection - Array of two corner points `[[left, top], [right, bottom]]`.
   * The `left` and `right` coordinates should be from 0 to the width of the canvas.
   * The `top` and `bottom` coordinates should be from 0 to the height of the canvas.
   * @returns A Float32Array containing the indices of points inside a rectangular area.
   */
  getPointsInRect(e) {
    if (this._isDestroyed || !this.reglInstance || !this.points) return new Float32Array();
    const n = this.store.screenSize[1];
    return this.store.selectedArea = [[e[0][0], n - e[1][1]], [e[1][0], n - e[0][1]]], this.points.findPointsOnAreaSelection(), tn(this.reglInstance, this.points.selectedFbo).map((r, o) => o % 4 === 0 && r !== 0 ? o / 4 : -1).filter((r) => r !== -1);
  }
  /**
   * Get points indices inside a rectangular area.
   * @param selection - Array of two corner points `[[left, top], [right, bottom]]`.
   * The `left` and `right` coordinates should be from 0 to the width of the canvas.
   * The `top` and `bottom` coordinates should be from 0 to the height of the canvas.
   * @returns A Float32Array containing the indices of points inside a rectangular area.
   * @deprecated Use `getPointsInRect` instead. This method will be removed in a future version.
   */
  getPointsInRange(e) {
    return this.getPointsInRect(e);
  }
  /**
   * Get points indices inside a polygon area.
   * @param polygonPath - Array of points `[[x1, y1], [x2, y2], ..., [xn, yn]]` that defines the polygon.
   * The coordinates should be from 0 to the width/height of the canvas.
   * @returns A Float32Array containing the indices of points inside the polygon area.
   */
  getPointsInPolygon(e) {
    if (this._isDestroyed || !this.reglInstance || !this.points) return new Float32Array();
    if (e.length < 3) return new Float32Array();
    const n = this.store.screenSize[1], i = e.map(([o, s]) => [o, n - s]);
    return this.points.updatePolygonPath(i), this.points.findPointsOnPolygonSelection(), tn(this.reglInstance, this.points.selectedFbo).map((o, s) => s % 4 === 0 && o !== 0 ? s / 4 : -1).filter((o) => o !== -1);
  }
  /** Select points inside a rectangular area.
   * @param selection - Array of two corner points `[[left, top], [right, bottom]]`.
   * The `left` and `right` coordinates should be from 0 to the width of the canvas.
   * The `top` and `bottom` coordinates should be from 0 to the height of the canvas. */
  selectPointsInRect(e) {
    if (!(this._isDestroyed || !this.reglInstance || !this.points)) {
      if (e) {
        const n = this.store.screenSize[1];
        this.store.selectedArea = [[e[0][0], n - e[1][1]], [e[1][0], n - e[0][1]]], this.points.findPointsOnAreaSelection();
        const i = tn(this.reglInstance, this.points.selectedFbo);
        this.store.selectedIndices = i.map((r, o) => o % 4 === 0 && r !== 0 ? o / 4 : -1).filter((r) => r !== -1);
      } else
        this.store.selectedIndices = null;
      this.points.updateGreyoutStatus();
    }
  }
  /** Select points inside a rectangular area.
   * @param selection - Array of two corner points `[[left, top], [right, bottom]]`.
   * The `left` and `right` coordinates should be from 0 to the width of the canvas.
   * The `top` and `bottom` coordinates should be from 0 to the height of the canvas.
   * @deprecated Use `selectPointsInRect` instead. This method will be removed in a future version.
   */
  selectPointsInRange(e) {
    return this.selectPointsInRect(e);
  }
  /** Select points inside a polygon area.
   * @param polygonPath - Array of points `[[x1, y1], [x2, y2], ..., [xn, yn]]` that defines the polygon.
   * The coordinates should be from 0 to the width/height of the canvas.
   * Set to null to clear selection. */
  selectPointsInPolygon(e) {
    if (!(this._isDestroyed || !this.reglInstance || !this.points)) {
      if (e) {
        if (e.length < 3) {
          console.warn("Polygon path requires at least 3 points to form a polygon.");
          return;
        }
        const n = this.store.screenSize[1], i = e.map(([o, s]) => [o, n - s]);
        this.points.updatePolygonPath(i), this.points.findPointsOnPolygonSelection();
        const r = tn(this.reglInstance, this.points.selectedFbo);
        this.store.selectedIndices = r.map((o, s) => s % 4 === 0 && o !== 0 ? s / 4 : -1).filter((o) => o !== -1);
      } else
        this.store.selectedIndices = null;
      this.points.updateGreyoutStatus();
    }
  }
  /**
   * Select a point by index. If you want the adjacent points to get selected too, provide `true` as the second argument.
   * @param index The index of the point in the array of points.
   * @param selectAdjacentPoints When set to `true`, selects adjacent points (`false` by default).
   */
  selectPointByIndex(e, n = false) {
    if (!this._isDestroyed)
      if (n) {
        const i = this.graph.getAdjacentIndices(e) ?? [];
        this.selectPointsByIndices([e, ...i]);
      } else this.selectPointsByIndices([e]);
  }
  /**
   * Select multiples points by their indices.
   * @param indices Array of points indices.
   */
  selectPointsByIndices(e) {
    this._isDestroyed || !this.points || (e ? e.length === 0 ? this.store.selectedIndices = new Float32Array() : this.store.selectedIndices = new Float32Array(e.filter((n) => n !== void 0)) : this.store.selectedIndices = null, this.points.updateGreyoutStatus());
  }
  /**
   * Unselect all points.
   */
  unselectPoints() {
    this._isDestroyed || !this.points || (this.store.selectedIndices = null, this.points.updateGreyoutStatus());
  }
  /**
   * Get indices of points that are currently selected.
   * @returns Array of selected indices of points.
   */
  getSelectedIndices() {
    if (this._isDestroyed) return null;
    const { selectedIndices: e } = this.store;
    return e ? Array.from(e) : null;
  }
  /**
   * Get indices that are adjacent to a specific point by its index.
   * @param index Index of the point.
   * @returns Array of adjacent indices.
   */
  getAdjacentIndices(e) {
    if (!this._isDestroyed)
      return this.graph.getAdjacentIndices(e);
  }
  /**
   * Converts the X and Y point coordinates from the space coordinate system to the screen coordinate system.
   * @param spacePosition Array of x and y coordinates in the space coordinate system.
   * @returns Array of x and y coordinates in the screen coordinate system.
   */
  spaceToScreenPosition(e) {
    return this._isDestroyed ? [0, 0] : this.zoomInstance.convertSpaceToScreenPosition(e);
  }
  /**
   * Converts the X and Y point coordinates from the screen coordinate system to the space coordinate system.
   * @param screenPosition Array of x and y coordinates in the screen coordinate system.
   * @returns Array of x and y coordinates in the space coordinate system.
   */
  screenToSpacePosition(e) {
    return this._isDestroyed ? [0, 0] : this.zoomInstance.convertScreenToSpacePosition(e);
  }
  /**
   * Converts the point radius value from the space coordinate system to the screen coordinate system.
   * @param spaceRadius Radius of point in the space coordinate system.
   * @returns Radius of point in the screen coordinate system.
   */
  spaceToScreenRadius(e) {
    return this._isDestroyed ? 0 : this.zoomInstance.convertSpaceToScreenRadius(e);
  }
  /**
   * Get point radius by its index.
   * @param index Index of the point.
   * @returns Radius of the point.
   */
  getPointRadiusByIndex(e) {
    var n;
    if (!this._isDestroyed)
      return (n = this.graph.pointSizes) == null ? void 0 : n[e];
  }
  /**
   * Track multiple point positions by their indices on each Cosmos tick.
   * @param indices Array of points indices.
   */
  trackPointPositionsByIndices(e) {
    this._isDestroyed || !this.points || this.points.trackPointsByIndices(e);
  }
  /**
   * Get current X and Y coordinates of the tracked points.
   * Do not mutate the returned map - it may affect future calls.
   * @returns A ReadonlyMap where keys are point indices and values are their corresponding X and Y coordinates in the [number, number] format.
   * @see trackPointPositionsByIndices To set which points should be tracked
   */
  getTrackedPointPositionsMap() {
    return this._isDestroyed || !this.points ? /* @__PURE__ */ new Map() : this.points.getTrackedPositionsMap();
  }
  /**
   * Get current X and Y coordinates of the tracked points as an array.
   * @returns Array of point positions in the format [x1, y1, x2, y2, ..., xn, yn] for tracked points only.
   * The positions are ordered by the tracking indices (same order as provided to trackPointPositionsByIndices).
   * Returns an empty array if no points are being tracked.
   */
  getTrackedPointPositionsArray() {
    return this._isDestroyed || !this.points ? [] : this.points.getTrackedPositionsArray();
  }
  /**
   * For the points that are currently visible on the screen, get a sample of point indices with their coordinates.
   * The resulting number of points will depend on the `pointSamplingDistance` configuration property,
   * and the sampled points will be evenly distributed.
   * @returns A Map object where keys are the index of the points and values are their corresponding X and Y coordinates in the [number, number] format.
   */
  getSampledPointPositionsMap() {
    return this._isDestroyed || !this.points ? /* @__PURE__ */ new Map() : this.points.getSampledPointPositionsMap();
  }
  /**
   * For the points that are currently visible on the screen, get a sample of point indices and positions.
   * The resulting number of points will depend on the `pointSamplingDistance` configuration property,
   * and the sampled points will be evenly distributed.
   * @returns An object containing arrays of point indices and positions.
   */
  getSampledPoints() {
    return this._isDestroyed || !this.points ? { indices: [], positions: [] } : this.points.getSampledPoints();
  }
  /**
   * Gets the X-axis of rescaling function.
   *
   * This scale is automatically created when position rescaling is enabled.
   */
  getScaleX() {
    if (!(this._isDestroyed || !this.points))
      return this.points.scaleX;
  }
  /**
   * Gets the Y-axis of rescaling function.
   *
   * This scale is automatically created when position rescaling is enabled.
   */
  getScaleY() {
    if (!(this._isDestroyed || !this.points))
      return this.points.scaleY;
  }
  /**
   * Start the simulation.
   * @param alpha Value from 0 to 1. The higher the value, the more initial energy the simulation will get.
   */
  start(e = 1) {
    var n, i;
    this._isDestroyed || this.graph.pointsNumber && (e > 0 && (this.store.isSimulationRunning = true, this.store.simulationProgress = 0, (i = (n = this.config).onSimulationStart) == null || i.call(n)), this.store.alpha = e, this.stopFrames(), this.frame());
  }
  /**
   * Pause the simulation. When paused, the simulation stops running
   * and can be resumed using the unpause method.
   */
  pause() {
    var e, n;
    this._isDestroyed || (this.store.isSimulationRunning = false, (n = (e = this.config).onSimulationPause) == null || n.call(e));
  }
  /**
   * Unpause the simulation. This method resumes a paused
   * simulation and continues its execution.
   */
  unpause() {
    var e, n;
    this._isDestroyed || (this.store.isSimulationRunning = true, (n = (e = this.config).onSimulationUnpause) == null || n.call(e));
  }
  /**
   * Restart/Resume the simulation. This method unpauses a paused
   * simulation and resumes its execution.
   * @deprecated Use `unpause()` instead. This method will be removed in a future version.
   */
  restart() {
    var e, n;
    this._isDestroyed || (this.store.isSimulationRunning = true, (n = (e = this.config).onSimulationRestart) == null || n.call(e));
  }
  /**
   * Render only one frame of the simulation (stops the simulation if it was running).
   */
  step() {
    this._isDestroyed || (this.store.isSimulationRunning = false, this.stopFrames(), this.frame());
  }
  /**
   * Destroy this Cosmos instance.
   */
  destroy() {
    var e, n, i, r;
    this._isDestroyed || !this.reglInstance || (window.clearTimeout(this._fitViewOnInitTimeoutID), this.stopFrames(), this.canvasD3Selection && this.canvasD3Selection.on("mouseenter.cosmos", null).on("mousemove.cosmos", null).on("mouseleave.cosmos", null).on("click", null).on("mousemove", null).on("contextmenu", null).on(".drag", null).on(".zoom", null), zt(document).on("keydown.cosmos", null).on("keyup.cosmos", null), (e = this.zoomInstance) != null && e.behavior && this.zoomInstance.behavior.on("start.detect", null).on("zoom.detect", null).on("end.detect", null), (n = this.dragInstance) != null && n.behavior && this.dragInstance.behavior.on("start.detect", null).on("drag.detect", null).on("end.detect", null), (i = this.fpsMonitor) == null || i.destroy(), this.reglInstance.destroy(), this.reglInstance.clear({
      color: this.store.backgroundColor,
      depth: 1,
      stencil: 0
    }), this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.attributionDivElement && this.attributionDivElement.parentNode && this.attributionDivElement.parentNode.removeChild(this.attributionDivElement), (r = document.getElementById("gl-bench-style")) == null || r.remove(), this.canvasD3Selection = void 0, this.reglInstance = void 0, this.attributionDivElement = void 0, this._isDestroyed = true);
  }
  /**
   * Updates and recreates the graph visualization based on pending changes.
   */
  create() {
    var e, n, i, r, o;
    this._isDestroyed || !this.points || !this.lines || (this.isPointPositionsUpdateNeeded && this.points.updatePositions(), this.isPointColorUpdateNeeded && this.points.updateColor(), this.isPointSizeUpdateNeeded && this.points.updateSize(), this.isPointShapeUpdateNeeded && this.points.updateShape(), this.isPointImageIndicesUpdateNeeded && this.points.updateImageIndices(), this.isPointImageSizesUpdateNeeded && this.points.updateImageSizes(), this.isLinksUpdateNeeded && this.lines.updatePointsBuffer(), this.isLinkColorUpdateNeeded && this.lines.updateColor(), this.isLinkWidthUpdateNeeded && this.lines.updateWidth(), this.isLinkArrowUpdateNeeded && this.lines.updateArrow(), this.isForceManyBodyUpdateNeeded && ((e = this.forceManyBody) == null || e.create()), this.isForceLinkUpdateNeeded && ((n = this.forceLinkIncoming) == null || n.create(Ns.INCOMING), (i = this.forceLinkOutgoing) == null || i.create(Ns.OUTGOING)), this.isForceCenterUpdateNeeded && ((r = this.forceCenter) == null || r.create()), this.isPointClusterUpdateNeeded && ((o = this.clusters) == null || o.create()), this.isPointPositionsUpdateNeeded = false, this.isPointColorUpdateNeeded = false, this.isPointSizeUpdateNeeded = false, this.isPointShapeUpdateNeeded = false, this.isPointImageIndicesUpdateNeeded = false, this.isPointImageSizesUpdateNeeded = false, this.isLinksUpdateNeeded = false, this.isLinkColorUpdateNeeded = false, this.isLinkWidthUpdateNeeded = false, this.isLinkArrowUpdateNeeded = false, this.isPointClusterUpdateNeeded = false, this.isForceManyBodyUpdateNeeded = false, this.isForceLinkUpdateNeeded = false, this.isForceCenterUpdateNeeded = false);
  }
  /**
   * Converts an array of tuple positions to a single array containing all coordinates sequentially
   * @param pointPositions An array of tuple positions
   * @returns A flatten array of coordinates
   */
  flatten(e) {
    return e.flat();
  }
  /**
   * Converts a flat array of point positions to a tuple pairs representing coordinates
   * @param pointPositions A flattened array of coordinates
   * @returns An array of tuple positions
   */
  pair(e) {
    const n = new Array(e.length / 2);
    for (let i = 0; i < e.length / 2; i++)
      n[i] = [e[i * 2], e[i * 2 + 1]];
    return n;
  }
  update(e = this.store.alpha) {
    const { graph: n } = this;
    this.store.pointsTextureSize = Math.ceil(Math.sqrt(n.pointsNumber ?? 0)), this.store.linksTextureSize = Math.ceil(Math.sqrt((n.linksNumber ?? 0) * 2)), this.create(), this.initPrograms(), this.store.hoveredPoint = void 0, this.start(e);
  }
  initPrograms() {
    var e, n, i, r, o, s;
    this._isDestroyed || !this.points || !this.lines || !this.clusters || (this.points.initPrograms(), this.lines.initPrograms(), (e = this.forceGravity) == null || e.initPrograms(), (n = this.forceLinkIncoming) == null || n.initPrograms(), (i = this.forceLinkOutgoing) == null || i.initPrograms(), (r = this.forceMouse) == null || r.initPrograms(), (o = this.forceManyBody) == null || o.initPrograms(), (s = this.forceCenter) == null || s.initPrograms(), this.clusters.initPrograms());
  }
  frame() {
    if (this._isDestroyed) return;
    const { config: { simulationGravity: e, simulationCenter: n, renderLinks: i, enableSimulation: r }, store: { alpha: o, isSimulationRunning: s } } = this;
    o < Ws && s && this.end(), this.store.pointsTextureSize && (this.requestAnimationFrameId = window.requestAnimationFrame((f) => {
      var l, u, m, y, S, D, q, Te, we, fe, Oe, Ve, V, se, Le, Be, Xe, nt, lt, Ee, ut, rt, N, Pe, ie, ke;
      (l = this.fpsMonitor) == null || l.begin(), this.resizeCanvas(), this.dragInstance.isActive || this.findHoveredItem(), r && (this.isRightClickMouse && this.config.enableRightClickRepulsion && ((u = this.forceMouse) == null || u.run(), (m = this.points) == null || m.updatePosition()), s && !(this.zoomInstance.isRunning && !this.config.enableSimulationDuringZoom) && (e && ((y = this.forceGravity) == null || y.run(), (S = this.points) == null || S.updatePosition()), n && ((D = this.forceCenter) == null || D.run(), (q = this.points) == null || q.updatePosition()), (Te = this.forceManyBody) == null || Te.run(), (we = this.points) == null || we.updatePosition(), this.store.linksTextureSize && ((fe = this.forceLinkIncoming) == null || fe.run(), (Oe = this.points) == null || Oe.updatePosition(), (Ve = this.forceLinkOutgoing) == null || Ve.run(), (V = this.points) == null || V.updatePosition()), (this.graph.pointClusters || this.graph.clusterPositions) && ((se = this.clusters) == null || se.run(), (Le = this.points) == null || Le.updatePosition()), this.store.alpha += this.store.addAlpha(this.config.simulationDecay ?? Ge.simulation.decay), this.isRightClickMouse && this.config.enableRightClickRepulsion && (this.store.alpha = Math.max(this.store.alpha, 0.1)), this.store.simulationProgress = Math.sqrt(Math.min(1, Ws / this.store.alpha)), (lt = (nt = this.config).onSimulationTick) == null || lt.call(
        nt,
        this.store.alpha,
        (Be = this.store.hoveredPoint) == null ? void 0 : Be.index,
        (Xe = this.store.hoveredPoint) == null ? void 0 : Xe.position
      )), (Ee = this.points) == null || Ee.trackPoints()), (ut = this.reglInstance) == null || ut.clear({
        color: this.store.backgroundColor,
        depth: 1,
        stencil: 0
      }), i && this.store.linksTextureSize && ((rt = this.lines) == null || rt.draw()), (N = this.points) == null || N.draw(), this.dragInstance.isActive && ((Pe = this.points) == null || Pe.drag(), (ie = this.points) == null || ie.drag()), (ke = this.fpsMonitor) == null || ke.end(f), this.currentEvent = void 0, this._isDestroyed || this.frame();
    }));
  }
  stopFrames() {
    this.requestAnimationFrameId && window.cancelAnimationFrame(this.requestAnimationFrameId);
  }
  end() {
    var e, n;
    this.store.isSimulationRunning = false, this.store.simulationProgress = 1, (n = (e = this.config).onSimulationEnd) == null || n.call(e);
  }
  onClick(e) {
    var n, i, r, o, s, f, l, u, m, y;
    (o = (r = this.config).onClick) == null || o.call(
      r,
      (n = this.store.hoveredPoint) == null ? void 0 : n.index,
      (i = this.store.hoveredPoint) == null ? void 0 : i.position,
      e
    ), this.store.hoveredPoint ? (f = (s = this.config).onPointClick) == null || f.call(
      s,
      this.store.hoveredPoint.index,
      this.store.hoveredPoint.position,
      e
    ) : this.store.hoveredLinkIndex !== void 0 ? (u = (l = this.config).onLinkClick) == null || u.call(
      l,
      this.store.hoveredLinkIndex,
      e
    ) : (y = (m = this.config).onBackgroundClick) == null || y.call(
      m,
      e
    );
  }
  updateMousePosition(e) {
    if (!e) return;
    const n = e.offsetX ?? e.x, i = e.offsetY ?? e.y;
    n === void 0 || i === void 0 || (this.store.mousePosition = this.zoomInstance.convertScreenToSpacePosition([n, i]), this.store.screenMousePosition = [n, this.store.screenSize[1] - i]);
  }
  onMouseMove(e) {
    var n, i, r, o;
    this.currentEvent = e, this.updateMousePosition(e), this.isRightClickMouse = e.which === 3, (o = (r = this.config).onMouseMove) == null || o.call(
      r,
      (n = this.store.hoveredPoint) == null ? void 0 : n.index,
      (i = this.store.hoveredPoint) == null ? void 0 : i.position,
      this.currentEvent
    );
  }
  onRightClickMouse(e) {
    e.preventDefault();
  }
  resizeCanvas(e = false) {
    var s, f, l, u;
    if (this._isDestroyed) return;
    const n = this.canvas.width, i = this.canvas.height, r = this.canvas.clientWidth, o = this.canvas.clientHeight;
    if (e || n !== r * this.config.pixelRatio || i !== o * this.config.pixelRatio) {
      const [m, y] = this.store.screenSize, { k: S } = this.zoomInstance.eventTransform, D = this.zoomInstance.convertScreenToSpacePosition([m / 2, y / 2]);
      this.store.updateScreenSize(r, o), this.canvas.width = r * this.config.pixelRatio, this.canvas.height = o * this.config.pixelRatio, (s = this.reglInstance) == null || s.poll(), (f = this.canvasD3Selection) == null || f.call(this.zoomInstance.behavior.transform, this.zoomInstance.getTransform([D], S)), (l = this.points) == null || l.updateSampledPointsGrid(), this.store.isLinkHoveringEnabled && ((u = this.lines) == null || u.updateLinkIndexFbo());
    }
  }
  setZoomTransformByPointPositions(e, n = 250, i, r) {
    var s;
    this.resizeCanvas();
    const o = this.zoomInstance.getTransform(this.pair(e), i, r);
    (s = this.canvasD3Selection) == null || s.transition().ease(Mv).duration(n).call(this.zoomInstance.behavior.transform, o);
  }
  updateZoomDragBehaviors() {
    var e, n, i, r;
    this.config.enableDrag ? (e = this.canvasD3Selection) == null || e.call(this.dragInstance.behavior) : (n = this.canvasD3Selection) == null || n.call(this.dragInstance.behavior).on(".drag", null), this.config.enableZoom ? (i = this.canvasD3Selection) == null || i.call(this.zoomInstance.behavior) : (r = this.canvasD3Selection) == null || r.call(this.zoomInstance.behavior).on("wheel.zoom", null);
  }
  findHoveredItem() {
    if (!(this._isDestroyed || !this._isMouseOnCanvas || !this.reglInstance)) {
      if (this._findHoveredItemExecutionCount < Vx) {
        this._findHoveredItemExecutionCount += 1;
        return;
      }
      if (this._findHoveredItemExecutionCount = 0, this.findHoveredPoint(), this.graph.linksNumber && this.store.isLinkHoveringEnabled)
        this.findHoveredLine();
      else if (this.store.hoveredLinkIndex !== void 0) {
        const e = this.store.hoveredLinkIndex !== void 0;
        this.store.hoveredLinkIndex = void 0, e && this.config.onLinkMouseOut && this.config.onLinkMouseOut(this.currentEvent);
      }
      this.updateCanvasCursor();
    }
  }
  findHoveredPoint() {
    var o, s, f, l, u;
    if (this._isDestroyed || !this.reglInstance || !this.points) return;
    this.points.findHoveredPoint();
    let e = false, n = false;
    const i = tn(this.reglInstance, this.points.hoveredFbo);
    if (i[1]) {
      const m = i[0];
      ((o = this.store.hoveredPoint) == null ? void 0 : o.index) !== m && (e = true);
      const y = i[2], S = i[3];
      this.store.hoveredPoint = {
        index: m,
        position: [y, S]
      };
    } else
      this.store.hoveredPoint && (n = true), this.store.hoveredPoint = void 0;
    e && this.store.hoveredPoint && ((f = (s = this.config).onPointMouseOver) == null || f.call(
      s,
      this.store.hoveredPoint.index,
      this.store.hoveredPoint.position,
      this.currentEvent
    )), n && ((u = (l = this.config).onPointMouseOut) == null || u.call(l, this.currentEvent));
  }
  findHoveredLine() {
    var o, s, f, l, u, m;
    if (this._isDestroyed || !this.reglInstance || !this.lines) return;
    if (this.store.hoveredPoint) {
      this.store.hoveredLinkIndex !== void 0 && (this.store.hoveredLinkIndex = void 0, (s = (o = this.config).onLinkMouseOut) == null || s.call(o, this.currentEvent));
      return;
    }
    this.lines.findHoveredLine();
    let e = false, n = false;
    const r = tn(this.reglInstance, this.lines.hoveredLineIndexFbo)[0];
    r >= 0 ? (this.store.hoveredLinkIndex !== r && (e = true), this.store.hoveredLinkIndex = r) : (this.store.hoveredLinkIndex !== void 0 && (n = true), this.store.hoveredLinkIndex = void 0), e && this.store.hoveredLinkIndex !== void 0 && ((l = (f = this.config).onLinkMouseOver) == null || l.call(f, this.store.hoveredLinkIndex)), n && ((m = (u = this.config).onLinkMouseOut) == null || m.call(u, this.currentEvent));
  }
  updateCanvasCursor() {
    const { hoveredPointCursor: e, hoveredLinkCursor: n } = this.config;
    this.dragInstance.isActive ? zt(this.canvas).style("cursor", "grabbing") : this.store.hoveredPoint ? !this.config.enableDrag || this.store.isSpaceKeyPressed ? zt(this.canvas).style("cursor", e) : zt(this.canvas).style("cursor", "grab") : this.store.isLinkHoveringEnabled && this.store.hoveredLinkIndex !== void 0 ? zt(this.canvas).style("cursor", n) : zt(this.canvas).style("cursor", null);
  }
  addAttribution() {
    var e;
    this.config.attribution && (this.attributionDivElement = document.createElement("div"), this.attributionDivElement.style.cssText = `
      user-select: none;
      position: absolute;
      bottom: 0;
      right: 0;
      color: var(--cosmosgl-attribution-color);
      margin: 0 0.6rem 0.6rem 0;
      font-size: 0.7rem;
      font-family: inherit;
    `, this.attributionDivElement.innerHTML = Ig(this.config.attribution, {
      ALLOWED_TAGS: ["a", "b", "i", "em", "strong", "span", "div", "p", "br", "img"],
      ALLOWED_ATTR: ["href", "target", "class", "id", "style", "src", "alt", "title"]
    }), (e = this.store.div) == null || e.appendChild(this.attributionDivElement));
  }
};
export {
  ab as Graph,
  ty as PointShape,
  kg as clamp,
  Kn as getRgbaColor,
  Cg as isAClassInstance,
  wc as isArray,
  Ag as isFunction,
  fn as isNumber,
  Eg as isObject,
  Su as isPlainObject,
  tn as readPixels,
  Pg as rgbToBrightness,
  Ig as sanitizeHtml
};
/*! Bundled license information:

@cosmos.gl/graph/dist/index.js:
  (*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE *)
*/
//# sourceMappingURL=@cosmos__gl_graph.js.map
